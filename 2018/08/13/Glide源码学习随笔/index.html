<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Android,源码,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="Glide是什么？Glide是一个Android的图片加载和缓存库，它主要专注于大量图片的流畅加载。是google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方App。 简介WIKI地址：WIKI官网 Github地址:Github 特点1、多样化媒体加载 Glide 不仅是一个图片缓存，它支持 Gif、">
<meta name="keywords" content="Android,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide源码学习随笔">
<meta property="og:url" content="https://junbin1011.github.io/2018/08/13/Glide源码学习随笔/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="Glide是什么？Glide是一个Android的图片加载和缓存库，它主要专注于大量图片的流畅加载。是google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方App。 简介WIKI地址：WIKI官网 Github地址:Github 特点1、多样化媒体加载 Glide 不仅是一个图片缓存，它支持 Gif、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-b89371e35681b7ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-53e1cf2300e601e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-4cc50012bc64e4ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-6656137177d24574?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-04-24T08:12:18.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide源码学习随笔">
<meta name="twitter:description" content="Glide是什么？Glide是一个Android的图片加载和缓存库，它主要专注于大量图片的流畅加载。是google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方App。 简介WIKI地址：WIKI官网 Github地址:Github 特点1、多样化媒体加载 Glide 不仅是一个图片缓存，它支持 Gif、">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5125122-b89371e35681b7ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/2018/08/13/Glide源码学习随笔/">





  <title> Glide源码学习随笔 | JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/13/Glide源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Glide源码学习随笔
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:23:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/13/Glide源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/13/Glide源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Glide是什么？"><a href="#Glide是什么？" class="headerlink" title="Glide是什么？"></a>Glide是什么？</h1><p>Glide是一个Android的图片加载和缓存库，它主要专注于大量图片的流畅加载。是google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方App。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WIKI地址：<a href="https://github.com/bumptech/glide/wiki" target="_blank" rel="noopener">WIKI官网</a></p>
<p>Github地址:<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、多样化媒体加载</p>
<p>Glide 不仅是一个图片缓存，它支持 Gif、WebP等格式</p>
<p>2、生命周期集成</p>
<p>我们可以更加高效的使用Glide提供的方式进行绑定，这样可以更好的让加载图片的请求的生命周期动态管理起来</p>
<p>3、高效的缓存策略</p>
<ul>
<li>支持Memory和Disk图片缓存</li>
<li>根据 ImageView 的大小来缓存相应大小的图片尺寸</li>
<li>内存开销小，默认的 Bitmap 格式是 RGB_565 格式</li>
</ul>
<p>4、 提供丰富的图片转换Api，支持圆形裁剪、平滑显示等特性</p>
<h1 id="Glide怎么用？"><a href="#Glide怎么用？" class="headerlink" title="Glide怎么用？"></a>Glide怎么用？</h1><p> 1、gradle引入库，implementation ‘com.github.bumptech.glide:glide:4.7.1’</p>
<p> 2、配置Glide的with load apply into等方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void loadImageView(ImageView view,String url)&#123;</span><br><span class="line">      //属性的配置</span><br><span class="line">      RequestOptions options = new RequestOptions()</span><br><span class="line">              //加载成功之前占位图</span><br><span class="line">              .placeholder(R.mipmap.ic_launcher)</span><br><span class="line">              //加载错误之后的错误图</span><br><span class="line">              .error(R.mipmap.ic_launcher)</span><br><span class="line">              //指定图片的尺寸</span><br><span class="line">              .override(1000,800)</span><br><span class="line">              //指定图片的缩放类型为fitCenter （等比例缩放图片，宽或者是高等于ImageView的宽或者是高。）</span><br><span class="line">              .fitCenter()</span><br><span class="line">              //指定图片的缩放类型为centerCrop （等比例缩放图片，直到图片的狂高都大于等于ImageView的宽度，然后截取中间的显示。）</span><br><span class="line">              .centerCrop()</span><br><span class="line">              .circleCrop()//指定图片的缩放类型为centerCrop （圆形）</span><br><span class="line">              //跳过内存缓存</span><br><span class="line">              .skipMemoryCache(true)</span><br><span class="line">              //缓存所有版本的图像</span><br><span class="line">              .diskCacheStrategy(DiskCacheStrategy.ALL)</span><br><span class="line">              //跳过磁盘缓存</span><br><span class="line">              .diskCacheStrategy(DiskCacheStrategy.NONE)</span><br><span class="line">              //只缓存原来分辨率的图片</span><br><span class="line">              .diskCacheStrategy(DiskCacheStrategy.DATA)</span><br><span class="line">              //只缓存最终的图片</span><br><span class="line">              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)</span><br><span class="line">              .priority(Priority.HIGH)</span><br><span class="line">              ;</span><br><span class="line">      //加载图片</span><br><span class="line">      Glide.with(getApplicationContext())</span><br><span class="line">              .load(url)</span><br><span class="line">              .apply(options)</span><br><span class="line">              .into(view);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、执行ImageView的加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadImageView(ivPic,&quot;http://b.hiphotos.baidu.com/image/pic/item/d52a2834349b033bda94010519ce36d3d439bdd5.jpg&quot;);</span><br></pre></td></tr></table></figure>
<p>详细的使用教程及option的配置，推荐参考</p>
<p><a href="https://blog.csdn.net/guolin_blog/article/details/78582548" target="_blank" rel="noopener">Android图片加载框架最全解析（八），带你全面了解Glide 4的用法</a></p>
<h1 id="Glide核心执行流程是怎样？"><a href="#Glide核心执行流程是怎样？" class="headerlink" title="Glide核心执行流程是怎样？"></a>Glide核心执行流程是怎样？</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data</td>
<td>代表原始的，未修改过的资源，对应dataClass</td>
</tr>
<tr>
<td>Resource</td>
<td>修改过的资源，对应resourceClass</td>
</tr>
<tr>
<td>Transcoder</td>
<td>资源转换器，比如BitmapBytesTranscoder（Bitmap转换为Bytes），GifDrawableBytesTranscoder</td>
</tr>
<tr>
<td>ResourceEncoder</td>
<td>持久化数据的接口，注意，该类并不与decoder相对应，而是用于本地缓存的接口</td>
</tr>
<tr>
<td>ResourceDecoder</td>
<td>数据解码器,比如ByteBufferGifDecoder（将ByteBuffer转换为Gif），StreamBitmapDecoder（Stream转换为Bitmap）</td>
</tr>
<tr>
<td>ResourceTranscoder</td>
<td>资源转换器，将给定的资源类型，转换为另一种资源类型，比如将Bitmap转换为Drawable，Bitmap转换为Bytes</td>
</tr>
<tr>
<td>Transformation</td>
<td>比如对图片进行FitCenter，CircleCrop，CenterCrop的transformation，或者根据给定宽高对Bitmap进行处理的BitmapDrawableTransformation</td>
</tr>
<tr>
<td>Target</td>
<td>request的载体，各种资源对应的加载类，含有生命周期的回调方法，方便开发人员进行相应的准备以及资源回收工作</td>
</tr>
</tbody>
</table>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-b89371e35681b7ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、构建Request，实现类为SingleRequest，用于发起一个加载的请求</p>
<p>2、通过EngineJob和DecodeJob负责任务创建，发起，回调，资源的管理</p>
<p>3、根据请求的资源类型，最后匹配对应的DateFetcher进行Data数据的获取</p>
<p>4、获取数据进行相应的缓存配置</p>
<p>5、根据原始数据Data进行解码及转换，生成最终需要显示的Resource</p>
<p>6、通过回调Target对应的方法，最后进行图片的显示</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Glide</td>
<td>向外暴露单例静态接口，构建Request，配置资源类型，缓存策略，图片处理等，可以直接通过该类完成简单的图片请求和填充。内部持有一些内存变量BitmapPool，MemoryCache，ByteArrayPool，便于低内存情况时自动清理内存</td>
</tr>
<tr>
<td>RequestManagerRetriever</td>
<td>用于创建RequestManager对象，并与Context做相应的生命周期绑定</td>
</tr>
<tr>
<td>RequestManagerFragment</td>
<td>Glide向Activity或Fragment中添加的空Fragment，用于控制绑定生命周期</td>
</tr>
<tr>
<td>LifecycleListener</td>
<td>用于监听Activity或者Fragment的生命周期方法的接口</td>
</tr>
<tr>
<td>RequestManager</td>
<td>用户管理及发起请求，支持resume、pause、clear等操作</td>
</tr>
<tr>
<td>RequestBuilder</td>
<td>创建请求，资源类型配置，缩略图配置，以及通过BaseRequestOptions进行一些默认图，图片处理的配置</td>
</tr>
<tr>
<td>Engine</td>
<td>任务创建，发起，回调，管理存活和缓存的资源</td>
</tr>
<tr>
<td>EngineJob</td>
<td>调度DecodeJob，添加，移除资源回调，并notify回调</td>
</tr>
<tr>
<td>DecodeJob</td>
<td>实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</td>
</tr>
<tr>
<td>ResourceCacheGenerator</td>
<td>尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</td>
</tr>
<tr>
<td>DataCacheGenerator</td>
<td>尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</td>
</tr>
<tr>
<td>SourceGenerator</td>
<td>从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源</td>
</tr>
<tr>
<td>DataFetcher</td>
<td>数据加载接口，通过loadData加载数据并执行对应的回调</td>
</tr>
<tr>
<td>LoadPath</td>
<td>根据给定的数据类型的DataFetcher尝试获取数据，然后尝试通过一个或多个decodePath进行decode</td>
</tr>
<tr>
<td>DecodePath</td>
<td>根据指定的数据类型对resource进行decode和transcode</td>
</tr>
<tr>
<td>Registry</td>
<td>管理组件（数据类型＋数据处理）的注册</td>
</tr>
<tr>
<td>ModelLoaderRegistry</td>
<td>注册所有数据加载的loader</td>
</tr>
<tr>
<td>ResourceDecoderRegistry</td>
<td>注册所有资源转换的decoder</td>
</tr>
<tr>
<td>TranscoderRegistry</td>
<td>注册所有对decoder之后进行特殊处理的transcoder</td>
</tr>
<tr>
<td>ResourceEncoderRegistry</td>
<td>注册所有持久化resource（处理过的资源）数据的encoder</td>
</tr>
<tr>
<td>EncoderRegistry</td>
<td>注册所有的持久化原始数据的encoder</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>先贴一下流程图，建议通过源码结合流程图进行分析，下面再分步骤进行分析。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-53e1cf2300e601e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>下面主要从with()、load()、into()3个方法进行分析。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with()"></a>with()</h3><p>1、with()方法，最后会返回一个RequestManger对象用于发起Request。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">   return getRetriever(context).get(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、getRetriever(context),最后返回一个RequestManagerRetriever对象用于生成RequestManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">   // Context could be null for other reasons (ie the user passes in null), but in practice it will</span><br><span class="line">   // only occur due to errors with the Fragment lifecycle.</span><br><span class="line">   Preconditions.checkNotNull(</span><br><span class="line">       context,</span><br><span class="line">       &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span><br><span class="line">           + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span><br><span class="line">           + &quot;is attached or after the Fragment is destroyed).&quot;);</span><br><span class="line">   return Glide.get(context).getRequestManagerRetriever();</span><br></pre></td></tr></table></figure></p>
<p>这里Glide.get(contenxt),会对glide进行初始化，模块扫描、组件注册等工作。</p>
<p>3、RequestManagerRetriever的get(context)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">   if (context == null) &#123;</span><br><span class="line">     throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">   &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">     if (context instanceof FragmentActivity) &#123;</span><br><span class="line">       return get((FragmentActivity) context);</span><br><span class="line">     &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">       return get((Activity) context);</span><br><span class="line">     &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">       return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return getApplicationManager(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要根据context的类型，去创建不同的RequestManager的对象，绑定生命周期。<br>如果context是Application对象的话，则调用,绑定了ApplicationLifecycle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">   // Either an application context or we&apos;re on a background thread.</span><br><span class="line">   if (applicationManager == null) &#123;</span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">       if (applicationManager == null) &#123;</span><br><span class="line">         // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">         // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">         // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">         // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">         // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">         Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">         applicationManager =</span><br><span class="line">             factory.build(</span><br><span class="line">                 glide,</span><br><span class="line">                 new ApplicationLifecycle(),</span><br><span class="line">                 new EmptyRequestManagerTreeNode(),</span><br><span class="line">                 context.getApplicationContext());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、如果context是Activity或Fragment的话，则会调用supportFragmentGet、FragmentGetd方法，创建RequestManagerFragment进行生命周期绑定ActivityFragmentLifecycle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private RequestManager fragmentGet(@NonNull Context context,</span><br><span class="line">    @NonNull android.app.FragmentManager fm,</span><br><span class="line">    @Nullable android.app.Fragment parentHint,</span><br><span class="line">    boolean isParentVisible) &#123;</span><br><span class="line">  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  if (requestManager == null) &#123;</span><br><span class="line">    // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下：with()方法，最后会返回一个根据context类型绑定生命周期的RequestManger对象。</p>
<h3 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h3><p>1.load()方法最后会生成一个RequestBuilder对象，用于构建Request，并执行请求操作.。首先会通过as方法生成一个RequestBuilder对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(</span><br><span class="line">    @NonNull Class&lt;ResourceType&gt; resourceClass) &#123;</span><br><span class="line">  return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、执行load()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) &#123;</span><br><span class="line">  return loadGeneric(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、执行loadGeneric方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;</span><br><span class="line">   this.model = model;</span><br><span class="line">   isModelSet = true;</span><br><span class="line">   return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>保存load传进行的参数，并设置isModelSet为true</p>
<p>4、设置请求的配置参数，apply(RequestOptions requestOptions)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public RequestBuilder&lt;TranscodeType&gt; apply(@NonNull RequestOptions requestOptions) &#123;</span><br><span class="line">  Preconditions.checkNotNull(requestOptions);</span><br><span class="line">  this.requestOptions = getMutableOptions().apply(requestOptions);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下load()方法，最后会返回一个RequestBuilder对象，通过apply设置请求的参数，用于构建Request。</p>
<h3 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h3><p>into()是整个过程最复杂的一步，简单来说就是通过缓存策略及注册的Moderload，最终去加载源数据Data，并进行转换为配置的Resource，最后显示再Target上。</p>
<p>1、RequestBuilder的into方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(</span><br><span class="line">     @NonNull Y target,</span><br><span class="line">     @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">     @NonNull RequestOptions options) &#123;</span><br><span class="line">   Util.assertMainThread();</span><br><span class="line">   Preconditions.checkNotNull(target);</span><br><span class="line">   if (!isModelSet) &#123;</span><br><span class="line">     throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   options = options.autoClone();</span><br><span class="line">   Request request = buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">   Request previous = target.getRequest();</span><br><span class="line">   if (request.isEquivalentTo(previous)</span><br><span class="line">       &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">     request.recycle();</span><br><span class="line">     // If the request is completed, beginning again will ensure the result is re-delivered,</span><br><span class="line">     // triggering RequestListeners and Targets. If the request is failed, beginning again will</span><br><span class="line">     // restart the request, giving it another chance to complete. If the request is already</span><br><span class="line">     // running, we can let it continue running without interruption.</span><br><span class="line">     if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">       // Use the previous request rather than the new one to allow for optimizations like skipping</span><br><span class="line">       // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span><br><span class="line">       // that are done in the individual Request.</span><br><span class="line">       previous.begin();</span><br><span class="line">     &#125;</span><br><span class="line">     return target;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   requestManager.clear(target);</span><br><span class="line">   target.setRequest(request);</span><br><span class="line">   requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">   return target;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、会执行BuildRequest()生成Request对象。经过一系列的调用，最后执行的方法如下，会返回一个SingleRequest对象实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Request obtainRequest(</span><br><span class="line">     Target&lt;TranscodeType&gt; target,</span><br><span class="line">     RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">     RequestOptions requestOptions,</span><br><span class="line">     RequestCoordinator requestCoordinator,</span><br><span class="line">     TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,</span><br><span class="line">     Priority priority,</span><br><span class="line">     int overrideWidth,</span><br><span class="line">     int overrideHeight) &#123;</span><br><span class="line">   return SingleRequest.obtain(</span><br><span class="line">       context,</span><br><span class="line">       glideContext,</span><br><span class="line">       model,</span><br><span class="line">       transcodeClass,</span><br><span class="line">       requestOptions,</span><br><span class="line">       overrideWidth,</span><br><span class="line">       overrideHeight,</span><br><span class="line">       priority,</span><br><span class="line">       target,</span><br><span class="line">       targetListener,</span><br><span class="line">       requestListener,</span><br><span class="line">       requestCoordinator,</span><br><span class="line">       glideContext.getEngine(),</span><br><span class="line">       transitionOptions.getTransitionFactory());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、接着会调用 requestManager.track(target, request);实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) &#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、这里涉及到一个新类RequestTracker，用于管理Request的生命周期。runRequest实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void runRequest(@NonNull Request request) &#123;</span><br><span class="line">   requests.add(request);</span><br><span class="line">   if (!isPaused) &#123;</span><br><span class="line">     request.begin();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       Log.v(TAG, &quot;Paused, delaying request&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     pendingRequests.add(request);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>5、最后会调用Request的begin()方法开始执行请求，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void begin() &#123;</span><br><span class="line">   assertNotCallingCallbacks();</span><br><span class="line">   stateVerifier.throwIfRecycled();</span><br><span class="line">   startTime = LogTime.getLogTime();</span><br><span class="line">   if (model == null) &#123;</span><br><span class="line">     if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">       width = overrideWidth;</span><br><span class="line">       height = overrideHeight;</span><br><span class="line">     &#125;</span><br><span class="line">     // Only log at more verbose log levels if the user has set a fallback drawable, because</span><br><span class="line">     // fallback Drawables indicate the user expects null models occasionally.</span><br><span class="line">     int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;</span><br><span class="line">     onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel);</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (status == Status.RUNNING) &#123;</span><br><span class="line">     throw new IllegalArgumentException(&quot;Cannot restart a running request&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (status == Status.COMPLETE) &#123;</span><br><span class="line">     onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Restarts for requests that are neither complete nor running can be treated as new requests</span><br><span class="line">   // and can run again from the beginning.</span><br><span class="line"></span><br><span class="line">   status = Status.WAITING_FOR_SIZE;</span><br><span class="line">   if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">     onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     target.getSize(this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">       &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">     target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">   &#125;</span><br><span class="line">   if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">     logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要会根据status进行判断，如果COMPLETE已完成，则直接回调 onResourceReady，如果是WAITING_FOR_SIZE，则会执行onSizeReady方法，我们都知道Glide会根据实际显示的View宽高去生成最后的Resource进行显示。</p>
<p>6、onResourceReady实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void onSizeReady(int width, int height) &#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  if (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">  float sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">  this.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">  this.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  loadStatus = engine.load(</span><br><span class="line">      glideContext,</span><br><span class="line">      model,</span><br><span class="line">      requestOptions.getSignature(),</span><br><span class="line">      this.width,</span><br><span class="line">      this.height,</span><br><span class="line">      requestOptions.getResourceClass(),</span><br><span class="line">      transcodeClass,</span><br><span class="line">      priority,</span><br><span class="line">      requestOptions.getDiskCacheStrategy(),</span><br><span class="line">      requestOptions.getTransformations(),</span><br><span class="line">      requestOptions.isTransformationRequired(),</span><br><span class="line">      requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">      requestOptions.getOptions(),</span><br><span class="line">      requestOptions.isMemoryCacheable(),</span><br><span class="line">      requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">      requestOptions.getUseAnimationPool(),</span><br><span class="line">      requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">      this);</span><br><span class="line"></span><br><span class="line">  // This is a hack that&apos;s only useful for testing right now where loads complete synchronously</span><br><span class="line">  // even though under any executor running on any thread but the main thread, the load would</span><br><span class="line">  // have completed asynchronously.</span><br><span class="line">  if (status != Status.RUNNING) &#123;</span><br><span class="line">    loadStatus = null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会通过engine的load方法去执行请求，后续的缓存策略、数据加载、图片转换都是在下面步骤执行</p>
<p>7、具体看Engine的load方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public &lt;R&gt; LoadStatus load(</span><br><span class="line">    GlideContext glideContext,</span><br><span class="line">    Object model,</span><br><span class="line">    Key signature,</span><br><span class="line">    int width,</span><br><span class="line">    int height,</span><br><span class="line">    Class&lt;?&gt; resourceClass,</span><br><span class="line">    Class&lt;R&gt; transcodeClass,</span><br><span class="line">    Priority priority,</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">    boolean isTransformationRequired,</span><br><span class="line">    boolean isScaleOnlyOrNoTransform,</span><br><span class="line">    Options options,</span><br><span class="line">    boolean isMemoryCacheable,</span><br><span class="line">    boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">    boolean useAnimationPool,</span><br><span class="line">    boolean onlyRetrieveFromCache,</span><br><span class="line">    ResourceCallback cb) &#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;</span><br><span class="line"></span><br><span class="line">  EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">      resourceClass, transcodeClass, options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">  if (active != null) &#123;</span><br><span class="line">    cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">  if (cached != null) &#123;</span><br><span class="line">    cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">  if (current != null) &#123;</span><br><span class="line">    current.addCallback(cb);</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return new LoadStatus(cb, current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      decodeJobFactory.build(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          key,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          options,</span><br><span class="line">          engineJob);</span><br><span class="line"></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">  engineJob.addCallback(cb);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">    logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">  &#125;</span><br><span class="line">  return new LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先通过构建EngineKey，判断内存缓存中是否命中。接着判断jobs队列中是否已存在该任务。否则会构建EngineJob、DecodeJob，并通过engineJob.start(decodeJob)，通过线程池去执行DecodeJob任务。DecodeJob实现了Runnable接口，所以我们接着分析DecodeJob的run方法</p>
<p>8、DecodeJob的run方法最后执行了runWrapped方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void runWrapped() &#123;</span><br><span class="line">    switch (runReason) &#123;</span><br><span class="line">      case INITIALIZE:</span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        runGenerators();</span><br><span class="line">        break;</span><br><span class="line">      case SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">        runGenerators();</span><br><span class="line">        break;</span><br><span class="line">      case DECODE_DATA:</span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据不同的runReason执行不同的任务，共两种任务类型：</p>
<p>runGenerators():load数据</p>
<p>decodeFromRetrievedData()：处理已经load到的数据</p>
<p>RunReason再次执行任务的原因，三种枚举值：<br>INITIALIZE:第一次调度任务</p>
<p>WITCH_TO_SOURCE_SERVICE:本地缓存策略失败，尝试重新获取数据，两种情况；当stage为Stage.SOURCE，或者获取数据失败并且执行和回调发生在了不同的线程</p>
<p>DECODE_DATA:获取数据成功，但执行和回调不在同一线程，希望回到自己的线程去处理数据。</p>
<p>9、getNextStage()是获取加载资源的策略，一共5种策略：<br>INITIALIZE，RESOURCE_CACHE，DATA_CACHE，SOURCE，FINISHED</p>
<p>其中加载数据的策略有三种：<br>RESOURCE_CACHE，DATA_CACHE，SOURCE，<br>分别对应的Generator:</p>
<p>ResourceCacheGenerator ：尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</p>
<p>DataCacheGenerator ：尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</p>
<p>SourceGenerator ：从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源<br>策略的配置在DiskCacheStrategy。开发者可通过BaseRequestOptions设置：<br>ALL<br>NONE<br>DATA<br>RESOURCE<br>AUTOMATIC（默认方式，依赖于DataFetcher的数据源和ResourceEncoder的EncodeStrategy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Stage getNextStage(Stage current) &#123;</span><br><span class="line">    switch (current) &#123;</span><br><span class="line">      case INITIALIZE:</span><br><span class="line">        return diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      case RESOURCE_CACHE:</span><br><span class="line">        return diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      case DATA_CACHE:</span><br><span class="line">        // Skip loading from source if the user opted to only retrieve the resource from cache.</span><br><span class="line">        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      case SOURCE:</span><br><span class="line">      case FINISHED:</span><br><span class="line">        return Stage.FINISHED;</span><br><span class="line">      default:</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>10、getNextGenerator，根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void runGenerators() &#123;</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  boolean isStarted = false;</span><br><span class="line">  while (!isCancelled &amp;&amp; currentGenerator != null</span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">    if (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // We&apos;ve run out of stages and generators, give up.</span><br><span class="line">  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Otherwise a generator started a new load and we expect to be called back in</span><br><span class="line">  // onDataFetcherReady.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>11、这里我们分析最后SourceGenerator的startNext的执行，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean startNext() &#123;</span><br><span class="line">  if (dataToCache != null) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = null;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  sourceCacheGenerator = null;</span><br><span class="line"></span><br><span class="line">  loadData = null;</span><br><span class="line">  boolean started = false;</span><br><span class="line">  while (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    if (loadData != null</span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = true;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后会通过Glide初始化时，Register注册的ModelLoader去执行对应的loadData方法，最后回调onDataFetcherReady(),获取得到DataSource，并将 runReason = RunReason.DECODE_DATA。触发调用decodeFromRetrievedData()进行源数据的转换</p>
<p>12、decodeFromRetrievedData，获取数据成功后，进行处理，内部调用的是runLoadPath(Data data, DataSource dataSource,LoadPath&lt;Data, ResourceType, R&gt; path),decode完成后的回调，对decode的资源进行transform。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void decodeFromRetrievedData() &#123;</span><br><span class="line">   if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">     logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,</span><br><span class="line">         &quot;data: &quot; + currentData</span><br><span class="line">             + &quot;, cache key: &quot; + currentSourceKey</span><br><span class="line">             + &quot;, fetcher: &quot; + currentFetcher);</span><br><span class="line">   &#125;</span><br><span class="line">   Resource&lt;R&gt; resource = null;</span><br><span class="line">   try &#123;</span><br><span class="line">     resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">   &#125; catch (GlideException e) &#123;</span><br><span class="line">     e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">     throwables.add(e);</span><br><span class="line">   &#125;</span><br><span class="line">   if (resource != null) &#123;</span><br><span class="line">     notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     runGenerators();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"> private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)</span><br><span class="line">     throws GlideException &#123;</span><br><span class="line">   LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">   return runLoadPath(data, dataSource, path);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>13、decodeFromRetrievedData()中，数据decode和transform后会执行notifyEncodeAndRelease方法，在该方法中调用 notifyComplete(result, dataSource)，接着调用callback.onResourceReady，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResourceReady(Resource&lt;R&gt; resource, DataSource dataSource) &#123;</span><br><span class="line">  this.resource = resource;</span><br><span class="line">  this.dataSource = dataSource;</span><br><span class="line">  MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>14、通过Handler将回调切换到主线程， 最后调用EngineJob的handleResultOnMainThread方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void handleResultOnMainThread() &#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    if (isCancelled) &#123;</span><br><span class="line">      resource.recycle();</span><br><span class="line">      release(false /*isRemovedFromQueue*/);</span><br><span class="line">      return;</span><br><span class="line">    &#125; else if (cbs.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;);</span><br><span class="line">    &#125; else if (hasResource) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Already have resource&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class="line">    hasResource = true;</span><br><span class="line"></span><br><span class="line">    // Hold on to resource for duration of request so we don&apos;t recycle it in the middle of</span><br><span class="line">    // notifying if it synchronously released by one of the callbacks.</span><br><span class="line">    engineResource.acquire();</span><br><span class="line">    listener.onEngineJobComplete(this, key, engineResource);</span><br><span class="line"></span><br><span class="line">    //noinspection ForLoopReplaceableByForEach to improve perf</span><br><span class="line">    for (int i = 0, size = cbs.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ResourceCallback cb = cbs.get(i);</span><br><span class="line">      if (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class="line">        engineResource.acquire();</span><br><span class="line">        cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Our request is complete, so we can release the resource.</span><br><span class="line">    engineResource.release();</span><br><span class="line"></span><br><span class="line">    release(false /*isRemovedFromQueue*/);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>15、进行相关的资源清理后，最后调用SingleRequest的onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) 方法，最后调用target.onResourceReady(result, animation)方法，实现资源的显示，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123;</span><br><span class="line">  // We must call isFirstReadyResource before setting status.</span><br><span class="line">  boolean isFirstResource = isFirstReadyResource();</span><br><span class="line">  status = Status.COMPLETE;</span><br><span class="line">  this.resource = resource;</span><br><span class="line"></span><br><span class="line">  if (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;</span><br><span class="line">    Log.d(GLIDE_TAG, &quot;Finished loading &quot; + result.getClass().getSimpleName() + &quot; from &quot;</span><br><span class="line">        + dataSource + &quot; for &quot; + model + &quot; with size [&quot; + width + &quot;x&quot; + height + &quot;] in &quot;</span><br><span class="line">        + LogTime.getElapsedMillis(startTime) + &quot; ms&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isCallingCallbacks = true;</span><br><span class="line">  try &#123;</span><br><span class="line">    if ((requestListener == null</span><br><span class="line">        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))</span><br><span class="line">        &amp;&amp; (targetListener == null</span><br><span class="line">        || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) &#123;</span><br><span class="line">      Transition&lt;? super R&gt; animation =</span><br><span class="line">          animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">      target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    isCallingCallbacks = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyLoadSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Glide是如何与Activity及Fragment等的生命周期绑定？"><a href="#Glide是如何与Activity及Fragment等的生命周期绑定？" class="headerlink" title="Glide是如何与Activity及Fragment等的生命周期绑定？"></a>Glide是如何与Activity及Fragment等的生命周期绑定？</h1><p> Glide在执行with的阶段，会根据context的类型，将Glide的Request请求与context类型进行绑定。Application类型为整个应用的生命周期。Fragment及Activity类型，通过巧妙的设计一个RequestManagerFragment,加入到Activity或Fragment当中，从而实现生命周期的监听。</p>
<p> 1、Application的绑定为ApplicationLifecycle，与App的生命周期一致<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void addListener(@NonNull LifecycleListener listener) &#123;</span><br><span class="line">  listener.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void removeListener(@NonNull LifecycleListener listener) &#123;</span><br><span class="line">  // Do nothing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、Activity或Fragment的绑定为ActivityFragmentLifecycle，与宿主对应的生命周期一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface LifecycleListener &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Callback for when &#123;@link android.app.Fragment#onStart()&#125;&#125; or &#123;@link</span><br><span class="line">   * android.app.Activity#onStart()&#125; is called.</span><br><span class="line">   */</span><br><span class="line">  void onStart();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Callback for when &#123;@link android.app.Fragment#onStop()&#125;&#125; or &#123;@link</span><br><span class="line">   * android.app.Activity#onStop()&#125;&#125; is called.</span><br><span class="line">   */</span><br><span class="line">  void onStop();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Callback for when &#123;@link android.app.Fragment#onDestroy()&#125;&#125; or &#123;@link</span><br><span class="line">   * android.app.Activity#onDestroy()&#125; is called.</span><br><span class="line">   */</span><br><span class="line">  void onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、在RequestManger中实现了监听接口的注册，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable addSelfToLifecycle = new Runnable() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    lifecycle.addListener(RequestManager.this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里注意，一个页面拥有一个RequestManagerFragment，RequestManagerFragment会持有RequestManger的引用。一个页面发起多个Glide显示图片请求，会优先从Fragment中获取RequestManger,不会重复创建多个RequestManger对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private RequestManager fragmentGet(@NonNull Context context,</span><br><span class="line">      @NonNull android.app.FragmentManager fm,</span><br><span class="line">      @Nullable android.app.Fragment parentHint,</span><br><span class="line">      boolean isParentVisible) &#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、RequestManger中绑定的回调执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Lifecycle callback that registers for connectivity events (if the</span><br><span class="line"> * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused</span><br><span class="line"> * requests.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">  resumeRequests();</span><br><span class="line">  targetTracker.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lifecycle callback that unregisters for connectivity events (if the</span><br><span class="line"> * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">  pauseRequests();</span><br><span class="line">  targetTracker.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lifecycle callback that cancels all in progress requests and clears and recycles resources for</span><br><span class="line"> * all completed requests.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">  targetTracker.onDestroy();</span><br><span class="line">  for (Target&lt;?&gt; target : targetTracker.getAll()) &#123;</span><br><span class="line">    clear(target);</span><br><span class="line">  &#125;</span><br><span class="line">  targetTracker.clear();</span><br><span class="line">  requestTracker.clearRequests();</span><br><span class="line">  lifecycle.removeListener(this);</span><br><span class="line">  lifecycle.removeListener(connectivityMonitor);</span><br><span class="line">  mainHandler.removeCallbacks(addSelfToLifecycle);</span><br><span class="line">  glide.unregisterRequestManager(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从实现可知，当Activity或Fragment退到后台时，会调用pauseRequests()暂停请求，回到前台时会重新执行请求，当页面销毁时，会进行对应的资源清理及回收。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4cc50012bc64e4ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="Glide的缓存实现原理是怎样的？"><a href="#Glide的缓存实现原理是怎样的？" class="headerlink" title="Glide的缓存实现原理是怎样的？"></a>Glide的缓存实现原理是怎样的？</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-6656137177d24574?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Glide的缓存使用内存缓存及硬盘缓存进行处理。</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ActiveResources</td>
<td>ActiveResources是一个以弱引用资源为value。用于缓存正在使用的资源</td>
</tr>
<tr>
<td>MemoryCache</td>
<td>MemoryCache是使用LruResourceCache实现,用于缓存非正在使用的资源</td>
</tr>
<tr>
<td>DiskCache</td>
<td>进行资源磁盘缓存</td>
</tr>
<tr>
<td>Http</td>
<td>通过网络地址，从服务端加载资源文件</td>
</tr>
</tbody>
</table>
<p>假如用户配置了使用内存缓存及磁盘缓存，则主要的加载实现流程如下:</p>
<p>1、当发起Request时，首先会从ActiveResources中进行缓存查找。如果命中则返回显示，如果不命中，则从MemoryCache中获取。当资源从ActiveResources中移除后，加入到MemoryCache中</p>
<p>2、当在MemoryCache中命中时，则会将资源加入到ActiveResources中，并在该Cache中移除，如果不命中则会尝试从磁盘缓存中进行加载</p>
<p>3、根据用于配置的策略，如果在磁盘缓存中命中，则会返回，并将资源缓存到ActiveResources当中，如果不命中，则会将进行网络的请求</p>
<p>4、根据ModelLoader的配置实现，从网络中加载资源，并根据配置，缓存到磁盘及内存缓存中</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>根据流程分析，我们知道Key的生成在Engine的load方法中，具体的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">       resourceClass, transcodeClass, options);</span><br></pre></td></tr></table></figure>
<p>可见为了兼容复杂的资源转换，保证key的唯一性，包含了非常多的参数进行构建。主要有model（目标地址）、signature（设置的签名）、图片的width、heigh、资源的转换配置等。</p>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>根据上面的简介，我们可以知道，Glide主要的内存缓存策略采用了2级缓存，为ActiveResources和MemoryCache。下面我们从源码的角度分析这2个缓存的机制。</p>
<h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p>1、 根据源码，我们可知内存采用了一个HashMap进行内存的缓存，使用了弱引用ResourceWeakReference持有了Resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>2、当获取资源时，主要采用get方法进行获取，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">    ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">    if (activeRef == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">    if (active == null) &#123;</span><br><span class="line">      cleanupActiveReference(activeRef);</span><br><span class="line">    &#125;</span><br><span class="line">    return active;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果命中，就返回资源。这里注意，如果当active==null，引用被回收时，会调用cleanupActiveReference方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    activeEngineResources.remove(ref.key);</span><br><span class="line"></span><br><span class="line">    if (!ref.isCacheable || ref.resource == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    EngineResource&lt;?&gt; newResource =</span><br><span class="line">        new EngineResource&lt;&gt;(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);</span><br><span class="line">    newResource.setResourceListener(ref.key, listener);</span><br><span class="line">    listener.onResourceReleased(ref.key, newResource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果ref.resource！=null，则会重新生成一个EngineResource对象，并回调onResourceReleased方法，我们看具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  activeResources.deactivate(cacheKey);</span><br><span class="line">  if (resource.isCacheable()) &#123;</span><br><span class="line">    cache.put(cacheKey, resource);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resourceRecycler.recycle(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可知，会调用deactivate方法，从activeResources中移除，然后加入到MemoryCache中。</p>
<p>3、写入资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void activate(Key key, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line">   ResourceWeakReference toPut =</span><br><span class="line">       new ResourceWeakReference(</span><br><span class="line">           key,</span><br><span class="line">           resource,</span><br><span class="line">           getReferenceQueue(),</span><br><span class="line">           isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">   ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">   if (removed != null) &#123;</span><br><span class="line">     removed.reset();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="EngineResource"><a href="#EngineResource" class="headerlink" title="EngineResource"></a>EngineResource</h3><p>EngineResource中主要为了一个acquired变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int acquired;</span><br></pre></td></tr></table></figure></p>
<p>当资源被使用时，会调用acquire,将变量值+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void acquire() &#123;</span><br><span class="line">  if (isRecycled) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Cannot acquire a recycled resource&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;</span><br><span class="line">    throw new IllegalThreadStateException(&quot;Must call acquire on the main thread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ++acquired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当资源被释放时，会调用release()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void release() &#123;</span><br><span class="line">   if (acquired &lt;= 0) &#123;</span><br><span class="line">     throw new IllegalStateException(&quot;Cannot release a recycled or not yet acquired resource&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;</span><br><span class="line">     throw new IllegalThreadStateException(&quot;Must call release on the main thread&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (--acquired == 0) &#123;</span><br><span class="line">     listener.onResourceReleased(key, this);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里注意，当acquired == 0，表明资源没有被使用时，则会调用onResourceReleased，将资源存储到MemoryCache中。这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。</p>
<h3 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>Glide在Build的过程中会创建具体的MemoryCache对象，具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (memoryCache == null) &#123;</span><br><span class="line">     memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可知，MemoryCache的主要实现是采用了LRU算法，我们具体查看LruResourceCache的实现。发现其继承与LruCache，LruCache的关键实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;T, Y&gt; cache = new LinkedHashMap&lt;&gt;(100, 0.75f, true);</span><br></pre></td></tr></table></figure>
<p>从源码可知，Glide的内存缓存的LRU算法实现主要是使用了LinkedHashMap。</p>
<p>这里详细的说明可参考：<br><a href="https://blog.csdn.net/exceptional_derek/article/details/11713255" target="_blank" rel="noopener">如何用LinkedHashMap实现LRU缓存算法</a></p>
<p><strong>总结一下</strong></p>
<p>glide采用了2级的内存缓存，activeResources是一个以弱引用资源为value,的map,memory是使用LruResourceCache实现的。就是activeResources是一个随时有可能被回收资源。它存在的意义在于，memory的强引用的频繁读写也有可能造成内存激增频繁GC,而造成内存抖动。资源在使用的过程中将会保存在activeResources中，而activeResources是弱引用的，可以随时被系统回收，不会造成内存泄漏和过多的使用</p>
<h2 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>Glide缓存的资源分为两种（1，原图（SOURCE）原始图片   2，处理图（RESULT）经过压缩和变形等转化的图片）</p>
<p>硬盘缓存分为五种，具体看一面。可以通过调用diskCacheStrategy()方法并传入五种不同的参数</p>
<p>1，DiskCacheStrategy.NONE// 表示不缓存任何内容</p>
<p>2，DiskCacheStrategy.DATA// 表示只缓存原始图片</p>
<p>3，DiskCacheStrategy.RESOURCE// 表示只缓存转换过后的图片</p>
<p>4，DiskCacheStrategy.ALL // 表示既缓存原始图片，也缓存转换过后的图片</p>
<p>5，DiskCacheStrategy.AUTOMATIC//表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）</p>
<h3 id="缓存的获取"><a href="#缓存的获取" class="headerlink" title="缓存的获取"></a>缓存的获取</h3><p>1、根据上述的流程分析，我们知道具体磁盘缓存在DecodeJob中执行，当任务开始时，调用了runWrapped()方法，接着会调用getNextStage,这里会获取磁盘的加载策略Stage，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Stage getNextStage(Stage current) &#123;</span><br><span class="line">    switch (current) &#123;</span><br><span class="line">      case INITIALIZE:</span><br><span class="line">        return diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      case RESOURCE_CACHE:</span><br><span class="line">        return diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      case DATA_CACHE:</span><br><span class="line">        // Skip loading from source if the user opted to only retrieve the resource from cache.</span><br><span class="line">        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      case SOURCE:</span><br><span class="line">      case FINISHED:</span><br><span class="line">        return Stage.FINISHED;</span><br><span class="line">      default:</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着会调用getNextGenerator方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private DataFetcherGenerator getNextGenerator() &#123;</span><br><span class="line">   switch (stage) &#123;</span><br><span class="line">     case RESOURCE_CACHE:</span><br><span class="line">       return new ResourceCacheGenerator(decodeHelper, this);</span><br><span class="line">     case DATA_CACHE:</span><br><span class="line">       return new DataCacheGenerator(decodeHelper, this);</span><br><span class="line">     case SOURCE:</span><br><span class="line">       return new SourceGenerator(decodeHelper, this);</span><br><span class="line">     case FINISHED:</span><br><span class="line">       return null;</span><br><span class="line">     default:</span><br><span class="line">       throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里获取下一步执行的策略，一共5种策略：<br>INITIALIZE，RESOURCE_CACHE，DATA_CACHE，SOURCE，FINISHED</p>
<p>其中加载数据的策略有三种：<br>RESOURCE_CACHE，DATA_CACHE，SOURCE，<br>分别对应的Generator:</p>
<p>ResourceCacheGenerator ：尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</p>
<p>DataCacheGenerator ：尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</p>
<p>SourceGenerator ：从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源</p>
<p>接着调用具体的Generator的startNext方法。磁盘的缓存获取实现在这个方法中获取。<br>这里ResourceCacheGenerator的关键缓存获取代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">     Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">     Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">     // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,</span><br><span class="line">     // we only run until the first one succeeds, the loop runs for only a limited</span><br><span class="line">     // number of iterations on the order of 10-20 in the worst case.</span><br><span class="line">     currentKey =</span><br><span class="line">         new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops</span><br><span class="line">             helper.getArrayPool(),</span><br><span class="line">             sourceId,</span><br><span class="line">             helper.getSignature(),</span><br><span class="line">             helper.getWidth(),</span><br><span class="line">             helper.getHeight(),</span><br><span class="line">             transformation,</span><br><span class="line">             resourceClass,</span><br><span class="line">             helper.getOptions());</span><br><span class="line">     cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">     if (cacheFile != null) &#123;</span><br><span class="line">       sourceKey = sourceId;</span><br><span class="line">       modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">       modelLoaderIndex = 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>DataCacheGenerator的关键缓存获取代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">    // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times</span><br><span class="line">    // and the actions it performs are much more expensive than a single allocation.</span><br><span class="line">    @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)</span><br><span class="line">    Key originalKey = new DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">    cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">    if (cacheFile != null) &#123;</span><br><span class="line">      this.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存的写入"><a href="#缓存的写入" class="headerlink" title="缓存的写入"></a>缓存的写入</h3><p>1、Data数据的缓存</p>
<p>从服务端获取数据的主要实现在SourceGenerator中，我们查看源码onDataReady可知其中判断了isDataCacheable（）会将数据赋值到dataToCache中。重新触发reschedule()；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onDataReady(Object data) &#123;</span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">  if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = data;</span><br><span class="line">    // We might be being called back on someone else&apos;s thread. Before doing anything, we should</span><br><span class="line">    // reschedule to get back onto Glide&apos;s thread.</span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当再次出发startNext，关键实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public boolean startNext() &#123;</span><br><span class="line">   if (dataToCache != null) &#123;</span><br><span class="line">     Object data = dataToCache;</span><br><span class="line">     dataToCache = null;</span><br><span class="line">     cacheData(data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的cacheData,将原始的Data数据缓存到磁盘文件中，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void cacheData(Object dataToCache) &#123;</span><br><span class="line">   long startTime = LogTime.getLogTime();</span><br><span class="line">   try &#123;</span><br><span class="line">     Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">     DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">         new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">     originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class="line">     helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       Log.v(TAG, &quot;Finished encoding source to cache&quot;</span><br><span class="line">           + &quot;, key: &quot; + originalKey</span><br><span class="line">           + &quot;, data: &quot; + dataToCache</span><br><span class="line">           + &quot;, encoder: &quot; + encoder</span><br><span class="line">           + &quot;, duration: &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     loadData.fetcher.cleanup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sourceCacheGenerator =</span><br><span class="line">       new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、Resource数据的缓存</p>
<p>根据上述的流程分析，再DecodeJob中的onResourceDecoded回调中，关键的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,</span><br><span class="line">       encodeStrategy)) &#123;</span><br><span class="line">     if (encoder == null) &#123;</span><br><span class="line">       throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">     &#125;</span><br><span class="line">     final Key key;</span><br><span class="line">     switch (encodeStrategy) &#123;</span><br><span class="line">       case SOURCE:</span><br><span class="line">         key = new DataCacheKey(currentSourceKey, signature);</span><br><span class="line">         break;</span><br><span class="line">       case TRANSFORMED:</span><br><span class="line">         key =</span><br><span class="line">             new ResourceCacheKey(</span><br><span class="line">                 decodeHelper.getArrayPool(),</span><br><span class="line">                 currentSourceKey,</span><br><span class="line">                 signature,</span><br><span class="line">                 width,</span><br><span class="line">                 height,</span><br><span class="line">                 appliedTransformation,</span><br><span class="line">                 resourceSubClass,</span><br><span class="line">                 options);</span><br><span class="line">         break;</span><br><span class="line">       default:</span><br><span class="line">         throw new IllegalArgumentException(&quot;Unknown strategy: &quot; + encodeStrategy);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">     deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">     result = lockedResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>会初始化DeferredEncodeManager对象。接着会执行到notifyEncodeAndRelease()方法，其中关键的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     if (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">       deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (lockedResource != null) &#123;</span><br><span class="line">       lockedResource.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在encode中进行了resource数据的缓存，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void encode(DiskCacheProvider diskCacheProvider, Options options) &#123;</span><br><span class="line">   GlideTrace.beginSection(&quot;DecodeJob.encode&quot;);</span><br><span class="line">   try &#123;</span><br><span class="line">     diskCacheProvider.getDiskCache().put(key,</span><br><span class="line">         new DataCacheWriter&lt;&gt;(encoder, toEncode, options));</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     toEncode.unlock();</span><br><span class="line">     GlideTrace.endSection();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><p>1、在Glide的Build方法中，我们可以看到磁盘缓存的工厂实例，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (diskCacheFactory == null) &#123;</span><br><span class="line">      diskCacheFactory = new InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、InternalCacheDiskCacheFactory继承了DiskLruCacheFactory，工厂关键的build方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public DiskCache build() &#123;</span><br><span class="line">   File cacheDir = cacheDirectoryGetter.getCacheDirectory();</span><br><span class="line"></span><br><span class="line">   if (cacheDir == null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!cacheDir.mkdirs() &amp;&amp; (!cacheDir.exists() || !cacheDir.isDirectory())) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、可见实际的磁盘缓存对象为DiskLruCacheWrapper类，我们看对应的get、put方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public File get(Key key) &#123;</span><br><span class="line">   String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">   if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">     Log.v(TAG, &quot;Get: Obtained: &quot; + safeKey + &quot; for for Key: &quot; + key);</span><br><span class="line">   &#125;</span><br><span class="line">   File result = null;</span><br><span class="line">   try &#123;</span><br><span class="line">     // It is possible that the there will be a put in between these two gets. If so that shouldn&apos;t</span><br><span class="line">     // be a problem because we will always put the same value at the same key so our input streams</span><br><span class="line">     // will still represent the same data.</span><br><span class="line">     final DiskLruCache.Value value = getDiskCache().get(safeKey);</span><br><span class="line">     if (value != null) &#123;</span><br><span class="line">       result = value.getFile(0);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; catch (IOException e) &#123;</span><br><span class="line">     if (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">       Log.w(TAG, &quot;Unable to get from disk cache&quot;, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void put(Key key, Writer writer) &#123;</span><br><span class="line">   // We want to make sure that puts block so that data is available when put completes. We may</span><br><span class="line">   // actually not write any data if we find that data is written by the time we acquire the lock.</span><br><span class="line">   String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">   writeLocker.acquire(safeKey);</span><br><span class="line">   try &#123;</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       Log.v(TAG, &quot;Put: Obtained: &quot; + safeKey + &quot; for for Key: &quot; + key);</span><br><span class="line">     &#125;</span><br><span class="line">     try &#123;</span><br><span class="line">       // We assume we only need to put once, so if data was written while we were trying to get</span><br><span class="line">       // the lock, we can simply abort.</span><br><span class="line">       DiskLruCache diskCache = getDiskCache();</span><br><span class="line">       Value current = diskCache.get(safeKey);</span><br><span class="line">       if (current != null) &#123;</span><br><span class="line">         return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       DiskLruCache.Editor editor = diskCache.edit(safeKey);</span><br><span class="line">       if (editor == null) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Had two simultaneous puts for: &quot; + safeKey);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">         File file = editor.getFile(0);</span><br><span class="line">         if (writer.write(file)) &#123;</span><br><span class="line">           editor.commit();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">         editor.abortUnlessCommitted();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       if (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">         Log.w(TAG, &quot;Unable to put to disk cache&quot;, e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     writeLocker.release(safeKey);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、最终可知磁盘缓存的实现为DiskLruCache，关于DiskLruCache缓存可参考如下博文</p>
<p><a href="https://www.jianshu.com/p/0c56dc217917" target="_blank" rel="noopener">DiskLruCache缓存</a></p>
<h1 id="Glide的底层网络实现是什么？"><a href="#Glide的底层网络实现是什么？" class="headerlink" title="Glide的底层网络实现是什么？"></a>Glide的底层网络实现是什么？</h1><p>通过上述的流程分析，我们可知最后的网络加载在SourceGenerator中的startNext()方法，通过初始注册的ModelLoader对应的DataFetcher去加载数据。我们以load一个GlideUrl地址来分析</p>
<p>在Glide的构造函数中，Register会注册ModelLoader，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())</span><br></pre></td></tr></table></figure></p>
<p>在SourceGenerator中的startNext()方法中会循环匹配出对应的ModelLoader，实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boolean started = false;</span><br><span class="line">  while (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    if (loadData != null</span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = true;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们查看HttpGlideUrlLoader，其最后的LoadData实现为HttpUrlFetcher，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height,</span><br><span class="line">     @NonNull Options options) &#123;</span><br><span class="line">   // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span><br><span class="line">   // spent parsing urls.</span><br><span class="line">   GlideUrl url = model;</span><br><span class="line">   if (modelCache != null) &#123;</span><br><span class="line">     url = modelCache.get(model, 0, 0);</span><br><span class="line">     if (url == null) &#123;</span><br><span class="line">       modelCache.put(model, 0, 0, model);</span><br><span class="line">       url = model;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   int timeout = options.get(TIMEOUT);</span><br><span class="line">   return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>HttpUrlFetcher具体加载网络的数据的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void loadData(@NonNull Priority priority,</span><br><span class="line">      @NonNull DataCallback&lt;? super InputStream&gt; callback) &#123;</span><br><span class="line">    long startTime = LogTime.getLogTime();</span><br><span class="line">    try &#123;</span><br><span class="line">      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());</span><br><span class="line">      callback.onDataReady(result);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, &quot;Failed to load data for url&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      callback.onLoadFailed(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, &quot;Finished http url fetcher fetch in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,</span><br><span class="line">      Map&lt;String, String&gt; headers) throws IOException &#123;</span><br><span class="line">    if (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">      throw new HttpException(&quot;Too many (&gt; &quot; + MAXIMUM_REDIRECTS + &quot;) redirects!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Comparing the URLs using .equals performs additional network I/O and is generally broken.</span><br><span class="line">      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.</span><br><span class="line">      try &#123;</span><br><span class="line">        if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">          throw new HttpException(&quot;In re-direct loop&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (URISyntaxException e) &#123;</span><br><span class="line">        // Do nothing, this is best effort.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    urlConnection.setConnectTimeout(timeout);</span><br><span class="line">    urlConnection.setReadTimeout(timeout);</span><br><span class="line">    urlConnection.setUseCaches(false);</span><br><span class="line">    urlConnection.setDoInput(true);</span><br><span class="line"></span><br><span class="line">    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that</span><br><span class="line">    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.</span><br><span class="line">    urlConnection.setInstanceFollowRedirects(false);</span><br><span class="line"></span><br><span class="line">    // Connect explicitly to avoid errors in decoders if connection fails.</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    // Set the stream so that it&apos;s closed in cleanup to avoid resource leaks. See #2352.</span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">    if (isCancelled) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    final int statusCode = urlConnection.getResponseCode();</span><br><span class="line">    if (isHttpOk(statusCode)) &#123;</span><br><span class="line">      return getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">    &#125; else if (isHttpRedirect(statusCode)) &#123;</span><br><span class="line">      String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);</span><br><span class="line">      if (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">        throw new HttpException(&quot;Received empty or null redirect url&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      URL redirectUrl = new URL(url, redirectUrlString);</span><br><span class="line">      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition</span><br><span class="line">      // to disconnecting the url connection below. See #2352.</span><br><span class="line">      cleanup();</span><br><span class="line">      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);</span><br><span class="line">    &#125; else if (statusCode == INVALID_STATUS_CODE) &#123;</span><br><span class="line">      throw new HttpException(statusCode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过分析可知，Glide默认的网络加载使用的是urlConnection。当然我们也可以通过自定义ModelLoader，使用okhttp、volley等的网络框架进行加载。</p>
<p>具体可参考博文<br> <a href="https://blog.csdn.net/chunqiuwei/article/details/78493288?locationNum=3&amp;fps=1" target="_blank" rel="noopener">Glide 4.x添加自定义组件原理</a></p>
<h1 id="Glide中代码运用了那些设计模式，有什么巧妙的设计？"><a href="#Glide中代码运用了那些设计模式，有什么巧妙的设计？" class="headerlink" title="Glide中代码运用了那些设计模式，有什么巧妙的设计？"></a>Glide中代码运用了那些设计模式，有什么巧妙的设计？</h1><p>1、建造者模式</p>
<p>Glide对象的创建使用Build模式，将复杂对象的创建和表示分离，调用者不需要知道复杂的创建过程，使用Build的相关方法进行配置创建对象。</p>
<p>2、外观模式</p>
<p>Glide对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、策略模式</p>
<p>关于DecodeJob中的DataFetcherGenerator资源获取，采用了策略模式，将数据加载的不同算法进行封装。</p>
<p>4、工厂模式 </p>
<p>ModelLoader的创建使用了ModelLoaderFactory、Engine中的EngineJobFactory、DiskLruCacheFactory等</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Glide正因为其强大的功能，高效的运行机制，所以源码的实现非常复杂。在学习的过程中也遇到很多的困难，最终还是一步一步坚持下来了。有时候放弃就是一瞬间的念头，但坚持下来，终究会有收获。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://blog.csdn.net/guolin_blog/article/details/78582548" target="_blank" rel="noopener">Android图片加载框架最全解析（八），带你全面了解Glide 4的用法</a></p>
<p>  <a href="https://blog.csdn.net/exceptional_derek/article/details/11713255" target="_blank" rel="noopener">如何用LinkedHashMap实现LRU缓存算法</a></p>
<p>  <a href="https://www.jianshu.com/p/0c56dc217917" target="_blank" rel="noopener">DiskLruCache缓存</a></p>
<p> <a href="https://blog.csdn.net/u011803341/article/details/62434085" target="_blank" rel="noopener">Glide解析-cache</a></p>
<p>  <a href="https://blog.csdn.net/chunqiuwei/article/details/78493288?locationNum=3&amp;fps=1" target="_blank" rel="noopener">Glide 4.x添加自定义组件原理</a></p>
<p> <a href="https://www.cnblogs.com/android-blogs/p/5735655.html" target="_blank" rel="noopener">Android Glide源码分析</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/07/Retrofit源码学习随笔/" rel="next" title="Retrofit源码学习随笔">
                <i class="fa fa-chevron-left"></i> Retrofit源码学习随笔
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/17/EventBus源码学习随笔/" rel="prev" title="EventBus源码学习随笔">
                EventBus源码学习随笔 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/08/13/Glide源码学习随笔/" data-title="Glide源码学习随笔" data-url="https://junbin1011.github.io/2018/08/13/Glide源码学习随笔/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide是什么？"><span class="nav-number">1.</span> <span class="nav-text">Glide是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特点"><span class="nav-number">1.2.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide怎么用？"><span class="nav-number">2.</span> <span class="nav-text">Glide怎么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide核心执行流程是怎样？"><span class="nav-number">3.</span> <span class="nav-text">Glide核心执行流程是怎样？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概念"><span class="nav-number">3.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总体设计"><span class="nav-number">3.2.</span> <span class="nav-text">总体设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键类功能说明"><span class="nav-number">3.3.</span> <span class="nav-text">关键类功能说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码执行流程"><span class="nav-number">3.4.</span> <span class="nav-text">代码执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#with"><span class="nav-number">3.4.1.</span> <span class="nav-text">with()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load"><span class="nav-number">3.4.2.</span> <span class="nav-text">load()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#into"><span class="nav-number">3.4.3.</span> <span class="nav-text">into()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide是如何与Activity及Fragment等的生命周期绑定？"><span class="nav-number">4.</span> <span class="nav-text">Glide是如何与Activity及Fragment等的生命周期绑定？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide的缓存实现原理是怎样的？"><span class="nav-number">5.</span> <span class="nav-text">Glide的缓存实现原理是怎样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介-1"><span class="nav-number">5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Key"><span class="nav-number">5.2.</span> <span class="nav-text">Key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存缓存"><span class="nav-number">5.3.</span> <span class="nav-text">内存缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ActiveResources"><span class="nav-number">5.3.1.</span> <span class="nav-text">ActiveResources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EngineResource"><span class="nav-number">5.3.2.</span> <span class="nav-text">EngineResource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryCache"><span class="nav-number">5.3.3.</span> <span class="nav-text">MemoryCache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬盘缓存"><span class="nav-number">5.4.</span> <span class="nav-text">硬盘缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存策略"><span class="nav-number">5.4.1.</span> <span class="nav-text">缓存策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的获取"><span class="nav-number">5.4.2.</span> <span class="nav-text">缓存的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的写入"><span class="nav-number">5.4.3.</span> <span class="nav-text">缓存的写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的实现"><span class="nav-number">5.4.4.</span> <span class="nav-text">缓存的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide的底层网络实现是什么？"><span class="nav-number">6.</span> <span class="nav-text">Glide的底层网络实现是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide中代码运用了那些设计模式，有什么巧妙的设计？"><span class="nav-number">7.</span> <span class="nav-text">Glide中代码运用了那些设计模式，有什么巧妙的设计？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#思考"><span class="nav-number">8.1.</span> <span class="nav-text">思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">8.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
