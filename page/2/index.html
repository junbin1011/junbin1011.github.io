<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/2/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/2/"/>





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/07/Retrofit源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/07/Retrofit源码学习随笔/" itemprop="url">
                  Retrofit源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T17:06:09+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/07/Retrofit源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/07/Retrofit源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Retrofit是什么？"><a href="#Retrofit是什么？" class="headerlink" title="Retrofit是什么？"></a>Retrofit是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Retrofit，中文的翻译为“式样翻新”的意思，是一个基于OKHttp的RESTful网络请求框架。通俗一点来说，Retrofit就是一个网络请求框架的封装。同样是由Square公司开源的Android热门网络框架之一，其具有功能强大、简洁易用及高可拓展性特点。</p>
<p>官网网址：<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a></p>
<p>Github地址:<a href="https://github.com/square/retrofit" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、基于OkHttp并遵循Restful API设计风格</p>
<p>2、通过注解的形式，可简便的配置网络请求参数</p>
<p>3、支持同步及异步的网络请求方式</p>
<p>4、支持RxJava</p>
<p>5、支持多种数据格式的解析（Json、XML、Protobuf等）</p>
<h1 id="Retrofit怎么用？"><a href="#Retrofit怎么用？" class="headerlink" title="Retrofit怎么用？"></a>Retrofit怎么用？</h1><p>1、gradle引入库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.4.0&apos;</div><div class="line">implementation &apos;com.squareup.retrofit2:converter-gson:2.4.0&apos; //配置使用Gson解析响应数据 可选</div><div class="line">implementation &apos;com.squareup.retrofit2:adapter-rxjava:2.4.0&apos; //配置支持RxJava 可选</div></pre></td></tr></table></figure></p>
<p>2、初始化Retrofit对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">              .baseUrl(BASE_URL) //配置baseUrl</div><div class="line">              .addConverterFactory(GsonConverterFactory.create()) //配置使用Gson解析响应数据</div><div class="line">              .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) //配置支持RxJava</div><div class="line">              .build();</div></pre></td></tr></table></figure>
<h2 id="网络接口定义"><a href="#网络接口定义" class="headerlink" title="网络接口定义"></a>网络接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface WeatherService &#123;</div><div class="line">        //使用GET请求 直接返回原始数据</div><div class="line">        @GET(&quot;weather?location=%E5%98%89%E5%85%B4&amp;output=json&amp;ak=5slgyqGDENN7Sy7pw29IUvrZ&quot;)</div><div class="line">        Call&lt;ResponseBody&gt; cityNameQueryWeather();</div><div class="line">        </div><div class="line">        //使用GET请求 返回Json映射对象</div><div class="line">        @GET(&quot;&#123;weather&#125;?location=%E5%98%89%E5%85%B4&amp;output=json&quot;)</div><div class="line">        Call&lt;WeatherResp&gt; cityWeatherPath(@Path(&quot;weather&quot;) String weather, @Query(&quot;ak&quot;) String ak);</div><div class="line">        </div><div class="line">       //使用POST请求 支持RxJava返回</div><div class="line">        @FormUrlEncoded()</div><div class="line">        @POST(&quot;&#123;weather&#125;&quot;)</div><div class="line">        rx.Observable&lt;WeatherResp&gt; cityWeatherPost(@Path(&quot;weather&quot;) String weather, @Field(&quot;ak&quot;) String ak, @Field(&quot;location&quot;) String location, @Field(&quot;output&quot;) String output);</div><div class="line">        </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">        Call&lt;ResponseBody&gt; responseBodyCall = weatherService.cityNameQueryWeather();</div><div class="line">        try &#123;</div><div class="line">            Response&lt;ResponseBody&gt; responseBody = responseBodyCall.execute();</div><div class="line">            System.out.println(&quot;call:&quot; + responseBody.body().string());</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">       Call&lt;WeatherResp&gt; responseBodyCall = weatherService.cityWeatherPath(&quot;weather&quot;, &quot;5slgyqGDENN7Sy7pw29IUvrZ&quot;);</div><div class="line">       responseBodyCall.enqueue(new Callback&lt;WeatherResp&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;WeatherResp&gt; call, Response&lt;WeatherResp&gt; response) &#123;</div><div class="line">               System.out.println(&quot;call:&quot; + response.toString());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;WeatherResp&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<h2 id="RxJava支持"><a href="#RxJava支持" class="headerlink" title="RxJava支持"></a>RxJava支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">       weatherService.rxCityWeatherPost(&quot;weather&quot;, &quot;5slgyqGDENN7Sy7pw29IUvrZ&quot;, &quot;%E5%98%89%E5%85%B4&quot;, &quot;json&quot;)</div><div class="line">               .subscribeOn(Schedulers.io())        //在新线程里面处理网络请求</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())  //在主线程里面接受返回的数据</div><div class="line">               .subscribe(new rx.Observer&lt;WeatherResp&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void onCompleted() &#123;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   @Override</div><div class="line">                   public void onError(Throwable e) &#123;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   @Override</div><div class="line">                   public void onNext(WeatherResp weatherResp) &#123;</div><div class="line">                       System.out.println(&quot;call:&quot; + weatherResp.toString());</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div></pre></td></tr></table></figure>
<p>详细的Retrofit的注解配置及各注解的使用，推荐参考</p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="external">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>
<h1 id="Retrofit核心执行流程是怎样？"><a href="#Retrofit核心执行流程是怎样？" class="headerlink" title="Retrofit核心执行流程是怎样？"></a>Retrofit核心执行流程是怎样？</h1><h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retrofit</td>
<td>里面包含了很多对象，serviceMethodCache(自定义的接口映射对象集合)、baseUrl（请求地址）、callFactory（默认为OKHttpCall）、converterFactories（数据解析器工厂集合）、callAdapterFactories（Call适配器工厂集合）、callbackExecutor（回调执行，Android平台默认为MainThreadExecutor）使用Builder模型构建</td>
</tr>
<tr>
<td>Platform</td>
<td>Retrofit中用来管理多平台的方法，支持Android、Java8。通过findPlatform获取对应的平台，同时也初始化了defaultCallAdapterFactory工厂</td>
</tr>
<tr>
<td>ServiceMethod</td>
<td>接口映射的网络请求对象，通过动态代理，将自定义接口的标注转换为该对象，将标注及参数生成OkHttp所需的Request对象。Retrofit的create通过动态代理拦截，将每一个自定义接口转换成为一个ServiceMethod对象，并通过通过serviceMethodCache进行缓存。</td>
</tr>
<tr>
<td>Call<t></t></td>
<td>Retrofit定义的网络请求接口，包含execute、enqueue等方法</td>
</tr>
<tr>
<td>OkHttpCall</td>
<td>Ohttp的Call实现，通过createRawCall得到真正的 okhttp3.Call对象，用于进行实际的网络请求</td>
</tr>
<tr>
<td>CallAdapter.Factory</td>
<td>CallAdapter的静态工厂，包含get的抽象方法，用于生产CallAdapter对象</td>
</tr>
<tr>
<td>ExecutorCallAdapterFactory</td>
<td>Android平台默认的CallAdapter工厂，get方法使用匿名内部类实现CallAdapter，返回ExecutorCallbackCall，实现了Call</td>
</tr>
<tr>
<td>ExecutorCallbackCall</td>
<td>采用静态代理设计，delegate实际为OkHttpCall，使用callbackExecutor实现回调在主线程中执行</td>
</tr>
<tr>
<td>RxJavaCallAdapterFactory</td>
<td>Rxjava平台的CallAdapter工厂，get方法返回RxJavaCallAdapter对象</td>
</tr>
<tr>
<td>RxJavaCallAdapter</td>
<td>Rxjava平台的设配器，返回observable对象</td>
</tr>
<tr>
<td>Converter.Factory</td>
<td>数据解析器工厂，用于生产Converter实例</td>
</tr>
<tr>
<td>GsonConverterFactory</td>
<td>数据解析工厂实例，返回了GsonResponseBodyConverter数据解析器</td>
</tr>
<tr>
<td>GsonResponseBodyConverter</td>
<td>Gson的数据解析器，将服务端返回的json对象转换成对应的java模型</td>
</tr>
<tr>
<td>Response<t></t></td>
<td>Retrofit网络请求响应的Response</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-e251df442d1596cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>通过Build模式构建Retrofit对象</li>
<li>自定义的接口interface，包含接口方法及相关标注</li>
<li>执行定义的接口方法</li>
<li>通过Proxy.newProxyInstance进行动态代理拦截</li>
<li>通过反射将定义的标注方法解析生成ServiceMethod对象（表示一个网络请求的封装对象）并加入serviceMethodCache队列中，避免重复解析</li>
<li>创建OkHttpCall对象， 继承了Call<t>接口，桥接okhttp3.Call rawCall</t></li>
<li>从Retrofit对象的callAdapterFactories工厂集合获取CallAdapter，并调用adapt方法。如果是默认的使用ExecutorCallAdapterFactory设配返回Call<object>，如果设置了RxJavaCallAdapterFactory，返回observable。</object></li>
<li>获取适配器转换后的对象，执行同步请求或者异步请求。</li>
<li>创建Okhttp的RealCall对象</li>
<li>通过反射的arg参数，调用serviceMethod.toCall()，构建生成Okhttp的RealCall所需要的Request对象</li>
<li>通过OkHttp的RealCall执行对应的同步或异步请求</li>
<li>请求成功，通过parseResponse解析请求参数</li>
<li>通过数据转换器responseConverter.convert(body)，将原始数据转换为对象</li>
<li>回调解析完的数据对象Respone(T)</li>
</ol>
<h1 id="Retrofit-如何将定义的interface转换成网络请求？"><a href="#Retrofit-如何将定义的interface转换成网络请求？" class="headerlink" title="Retrofit 如何将定义的interface转换成网络请求？"></a>Retrofit 如何将定义的interface转换成网络请求？</h1><p>我们都知道，Retrofit通过自定义interface及相关的标注来描述一个http的请求，使用非常简便，且易于维护。</p>
<p>这是Retrofit设计的精髓之一，，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象，ServiceMethod中封装了OKHttp网络请求所需的相关参数。</p>
<p>源码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">   Utils.validateServiceInterface(service);</div><div class="line">   if (validateEagerly) &#123;</div><div class="line">     eagerlyValidateMethods(service);</div><div class="line">   &#125;</div><div class="line">   return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">       new InvocationHandler() &#123;</div><div class="line">         private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">         @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</div><div class="line">             throws Throwable &#123;</div><div class="line">           // If the method is a method from Object then defer to normal invocation.</div><div class="line">           if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">             return method.invoke(this, args);</div><div class="line">           &#125;</div><div class="line">           if (platform.isDefaultMethod(method)) &#123;</div><div class="line">             return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">           &#125;</div><div class="line">           //生成ServiceMethod</div><div class="line">           ServiceMethod&lt;Object, Object&gt; serviceMethod =o</div><div class="line">               (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">           OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">           return serviceMethod.adapt(okHttpCall);</div><div class="line">         &#125;</div><div class="line">       &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>通过源码我们知道，具体的转换方法为 (ServiceMethod<object, object="">) loadServiceMethod(method)，具体的实现如下：</object,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">    if (result != null) return result;</div><div class="line"></div><div class="line">    synchronized (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      if (result == null) &#123;</div><div class="line">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过Builder构建模式，创建一个ServiceMethod对象，并加入缓存，具体的构造实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">     this.retrofit = retrofit;</div><div class="line">     this.method = method;</div><div class="line">     this.methodAnnotations = method.getAnnotations();</div><div class="line">     this.parameterTypes = method.getGenericParameterTypes();</div><div class="line">     this.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public ServiceMethod build() &#123;</div><div class="line">     callAdapter = createCallAdapter();</div><div class="line">     responseType = callAdapter.responseType();</div><div class="line">     if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</div><div class="line">       throw methodError(&quot;&apos;&quot;</div><div class="line">           + Utils.getRawType(responseType).getName()</div><div class="line">           + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</div><div class="line">     &#125;</div><div class="line">     responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">     for (Annotation annotation : methodAnnotations) &#123;</div><div class="line">       parseMethodAnnotation(annotation);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (httpMethod == null) &#123;</div><div class="line">       throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (!hasBody) &#123;</div><div class="line">       if (isMultipart) &#123;</div><div class="line">         throw methodError(</div><div class="line">             &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</div><div class="line">       &#125;</div><div class="line">       if (isFormEncoded) &#123;</div><div class="line">         throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</div><div class="line">             + &quot;request body (e.g., @POST).&quot;);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     int parameterCount = parameterAnnotationsArray.length;</div><div class="line">     parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">     for (int p = 0; p &lt; parameterCount; p++) &#123;</div><div class="line">       Type parameterType = parameterTypes[p];</div><div class="line">       if (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">         throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</div><div class="line">             parameterType);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">       if (parameterAnnotations == null) &#123;</div><div class="line">         throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</div><div class="line">       throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</div><div class="line">     &#125;</div><div class="line">     if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</div><div class="line">       throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</div><div class="line">     &#125;</div><div class="line">     if (isFormEncoded &amp;&amp; !gotField) &#123;</div><div class="line">       throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</div><div class="line">     &#125;</div><div class="line">     if (isMultipart &amp;&amp; !gotPart) &#123;</div><div class="line">       throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     return new ServiceMethod&lt;&gt;(this);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>build()方法会通过反射去解析method的标注、参数的类型等。详细的解析可参考源码ParameterHandler相关实现，这里主要对流程进行剖析。</p>
<p>总结一下，Retrofit通过自定义interface及相关的标注来描述一个http的请求，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象，ServiceMethod中封装了OKHttp网络请求所需的相关参数。这就是Retrofit将定义的interface转换成网络请求对象的过程。</p>
<h1 id="Retrofit的Converter机制是如何实现？"><a href="#Retrofit的Converter机制是如何实现？" class="headerlink" title="Retrofit的Converter机制是如何实现？"></a>Retrofit的Converter机制是如何实现？</h1><h2 id="Converter种类"><a href="#Converter种类" class="headerlink" title="Converter种类"></a>Converter种类</h2><p>Retrofit支持多种数据解析方式，使用时需要在Gradle添加依赖。</p>
<table>
<thead>
<tr>
<th>数据解析器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.4.0</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.4.0</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.4.0</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.4.0</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.4.0</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.4.0</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.4.0</td>
</tr>
</tbody>
</table>
<h2 id="Converter实现流程"><a href="#Converter实现流程" class="headerlink" title="Converter实现流程"></a>Converter实现流程</h2><h3 id="添加Converter工厂"><a href="#添加Converter工厂" class="headerlink" title="添加Converter工厂"></a>添加Converter工厂</h3><p>首先在Retrofit的初始化添加Converter，addConverterFactory(GsonConverterFactory.create())。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Builder addConverterFactory(Converter.Factory factory) &#123;</div><div class="line">    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>将Converter的工厂加入到converterFactories集合中。</p>
<h3 id="触发数据转换"><a href="#触发数据转换" class="headerlink" title="触发数据转换"></a>触发数据转换</h3><p>通过上述的流程分析，我们知道Retrofit当网络请求成功后会执行，OkHttpCall中的parseResponse方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">   ResponseBody rawBody = rawResponse.body();</div><div class="line"></div><div class="line">   // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</div><div class="line">   rawResponse = rawResponse.newBuilder()</div><div class="line">       .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">       .build();</div><div class="line"></div><div class="line">   int code = rawResponse.code();</div><div class="line">   if (code &lt; 200 || code &gt;= 300) &#123;</div><div class="line">     try &#123;</div><div class="line">       // Buffer the entire body to avoid future I/O.</div><div class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class="line">       return Response.error(bufferedBody, rawResponse);</div><div class="line">     &#125; finally &#123;</div><div class="line">       rawBody.close();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (code == 204 || code == 205) &#123;</div><div class="line">     rawBody.close();</div><div class="line">     return Response.success(null, rawResponse);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">   try &#123;</div><div class="line">     T body = serviceMethod.toResponse(catchingBody);</div><div class="line">     return Response.success(body, rawResponse);</div><div class="line">   &#125; catch (RuntimeException e) &#123;</div><div class="line">     // If the underlying source threw an exception, propagate that rather than indicating it was</div><div class="line">     // a runtime exception.</div><div class="line">     catchingBody.throwIfCaught();</div><div class="line">     throw e;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>其中关键的代码为 T body = serviceMethod.toResponse(catchingBody)，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Builds a method return value from an HTTP response body. */</div><div class="line"> R toResponse(ResponseBody body) throws IOException &#123;</div><div class="line">   return responseConverter.convert(body);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="数据转换器的创建"><a href="#数据转换器的创建" class="headerlink" title="数据转换器的创建"></a>数据转换器的创建</h3><p>这里就是 Converter实现转换的地方，那么responseConverter在哪里进行初始化呢？在ServiceMethod的Build方法中，会调用createResponseConverter()进行数据解析器的创建，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123;</div><div class="line">     Annotation[] annotations = method.getAnnotations();</div><div class="line">     try &#123;</div><div class="line">       return retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">     &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</div><div class="line">       throw methodError(e, &quot;Unable to create converter for %s&quot;, responseType);</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用了 retrofit.responseBodyConverter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;</div><div class="line">   return nextResponseBodyConverter(null, type, annotations);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>调用了 retrofit.nextResponseBodyConverter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</div><div class="line">     @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</div><div class="line">   checkNotNull(type, &quot;type == null&quot;);</div><div class="line">   checkNotNull(annotations, &quot;annotations == null&quot;);</div><div class="line"></div><div class="line">   int start = converterFactories.indexOf(skipPast) + 1;</div><div class="line">   for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">     Converter&lt;ResponseBody, ?&gt; converter =</div><div class="line">         converterFactories.get(i).responseBodyConverter(type, annotations, this);</div><div class="line">     if (converter != null) &#123;</div><div class="line">       //noinspection unchecked</div><div class="line">       return (Converter&lt;ResponseBody, T&gt;) converter;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   StringBuilder builder = new StringBuilder(&quot;Could not locate ResponseBody converter for &quot;)</div><div class="line">       .append(type)</div><div class="line">       .append(&quot;.\n&quot;);</div><div class="line">   if (skipPast != null) &#123;</div><div class="line">     builder.append(&quot;  Skipped:&quot;);</div><div class="line">     for (int i = 0; i &lt; start; i++) &#123;</div><div class="line">       builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</div><div class="line">     &#125;</div><div class="line">     builder.append(&apos;\n&apos;);</div><div class="line">   &#125;</div><div class="line">   builder.append(&quot;  Tried:&quot;);</div><div class="line">   for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">     builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</div><div class="line">   &#125;</div><div class="line">   throw new IllegalArgumentException(builder.toString());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>通过Retrofit的converterFactories工厂集合匹配获取开始添加的数据转换工厂</p>
<h3 id="默认的数据转换工厂"><a href="#默认的数据转换工厂" class="headerlink" title="默认的数据转换工厂"></a>默认的数据转换工厂</h3><p>通过Retrofit build() 中发现如下代码，converterFactories.add(new BuiltInConverters())，可知Retrofit默认的数据转换器工厂为BuiltInConverters。主要实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</div><div class="line">     Retrofit retrofit) &#123;</div><div class="line">   if (type == ResponseBody.class) &#123;</div><div class="line">     return Utils.isAnnotationPresent(annotations, Streaming.class)</div><div class="line">         ? StreamingResponseBodyConverter.INSTANCE</div><div class="line">         : BufferingResponseBodyConverter.INSTANCE;</div><div class="line">   &#125;</div><div class="line">   if (type == Void.class) &#123;</div><div class="line">     return VoidResponseBodyConverter.INSTANCE;</div><div class="line">   &#125;</div><div class="line">   return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>会将数据转换为ResponseBody对象，所以如果Retrofit默认不使用任何数据解析器，定义interface方法时接收数据对象使用 Call<responsebody>。</responsebody></p>
<h1 id="Retrofit的CallAdapter机制是如何实现？"><a href="#Retrofit的CallAdapter机制是如何实现？" class="headerlink" title="Retrofit的CallAdapter机制是如何实现？"></a>Retrofit的CallAdapter机制是如何实现？</h1><p>Retrofit支持多种网络请求适配器方式：guava、Java8和rxjava 。Android默认的适配器工厂为ExecutorCallAdapterFactory，最后的回调通过ExecutorCallbackCall切换至主线程运行。</p>
<h2 id="CallAdapter种类"><a href="#CallAdapter种类" class="headerlink" title="CallAdapter种类"></a>CallAdapter种类</h2><table>
<thead>
<tr>
<th>网络请求适配器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.4.0</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.4.0</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.4.0</td>
</tr>
</tbody>
</table>
<h2 id="CallAdapter实现流程"><a href="#CallAdapter实现流程" class="headerlink" title="CallAdapter实现流程"></a>CallAdapter实现流程</h2><h3 id="添加CallAdapter工厂"><a href="#添加CallAdapter工厂" class="headerlink" title="添加CallAdapter工厂"></a>添加CallAdapter工厂</h3><p>首先在Retrofit的初始化添加CallAdapter工厂，addCallAdapterFactory(RxJavaCallAdapterFactory.create())。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123;</div><div class="line">  callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将CallAdapter的工厂加入到callAdapterFactories集合中。</p>
<h3 id="CallAdapter的adapt实现"><a href="#CallAdapter的adapt实现" class="headerlink" title="CallAdapter的adapt实现"></a>CallAdapter的adapt实现</h3><p>通过上述Retrofit的create方法中分析可知，当拦截到interface的方法调用后最后会执行 return serviceMethod.adapt(okHttpCall)。adapt的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T adapt(Call&lt;R&gt; call) &#123;</div><div class="line">  return callAdapter.adapt(call);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是在这个地方触发了callAdapter的adapt方法。返回最终适配的具体对象。</p>
<h3 id="默认的CallAdapter工厂"><a href="#默认的CallAdapter工厂" class="headerlink" title="默认的CallAdapter工厂"></a>默认的CallAdapter工厂</h3><p>Android平台默认的CallAdapter工厂为ExecutorCallAdapterFactory。通过Retrofit的build()方法可知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Make a defensive copy of the adapters and add the default Call adapter.</div><div class="line">     List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">     callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div></pre></td></tr></table></figure></p>
<p>platform.defaultCallAdapterFactory的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</div><div class="line">   if (callbackExecutor != null) &#123;</div><div class="line">     return new ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">   &#125;</div><div class="line">   return DefaultCallAdapterFactory.INSTANCE;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>ExecutorCallAdapterFactory的CallAdapter创建如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">       if (getRawType(returnType) != Call.class) &#123;</div><div class="line">           return null;</div><div class="line">       &#125; else &#123;</div><div class="line">           final Type responseType = Utils.getCallResponseType(returnType);</div><div class="line">           return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">               public Type responseType() &#123;</div><div class="line">                   return responseType;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">                   return new ExecutorCallAdapterFactory.ExecutorCallbackCall(ExecutorCallAdapterFactory.this.callbackExecutor, call);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>adapt方法最后返回还是Call<object>对象，具体的适配实现由ExecutorCallbackCall执行，具体源码如下：</object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">        final Executor callbackExecutor;</div><div class="line">        final Call&lt;T&gt; delegate;</div><div class="line"></div><div class="line">        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">            this.callbackExecutor = callbackExecutor;</div><div class="line">            this.delegate = delegate;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">            Utils.checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line">            this.delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">                public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">                    ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() &#123;</div><div class="line">                        public void run() &#123;</div><div class="line">                            if (ExecutorCallbackCall.this.delegate.isCanceled()) &#123;</div><div class="line">                                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">                            &#125; else &#123;</div><div class="line">                                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">                    ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() &#123;</div><div class="line">                        public void run() &#123;</div><div class="line">                            callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       </div><div class="line"></div><div class="line">        public Response&lt;T&gt; execute() throws IOException &#123;</div><div class="line">            return this.delegate.execute();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的执行还是通过delegate（OkHttpCall）来执行，但是在回调使用了 ExecutorCallbackCall.this.callbackExecutor.execute()方法，Android平台的callbackExecutor实现为MainThreadExecutor。具体源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class MainThreadExecutor implements Executor &#123;</div><div class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">      @Override public void execute(Runnable r) &#123;</div><div class="line">        handler.post(r);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>所以ExecutorCallAdapterFactory中适配最后的设配对象还是Call<object>,实现还是OkHttpCall，通过 MainThreadExecutor，将回调切换在UI线程中运行</object></p>
<h3 id="CallAdapter的创建"><a href="#CallAdapter的创建" class="headerlink" title="CallAdapter的创建"></a>CallAdapter的创建</h3><p>在ServiceMethod的Build方法中，createCallAdapter()进行适配器的的创建，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</div><div class="line">    Type returnType = method.getGenericReturnType();</div><div class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</div><div class="line">      throw methodError(</div><div class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</div><div class="line">    &#125;</div><div class="line">    if (returnType == void.class) &#123;</div><div class="line">      throw methodError(&quot;Service methods cannot return void.&quot;);</div><div class="line">    &#125;</div><div class="line">    Annotation[] annotations = method.getAnnotations();</div><div class="line">    try &#123;</div><div class="line">      //noinspection unchecked</div><div class="line">      return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</div><div class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</div><div class="line">      throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用了 retrofit.callAdapter</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</div><div class="line">  return nextCallAdapter(null, returnType, annotations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了 retrofit.nextCallAdapter</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</div><div class="line">    Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(returnType, &quot;returnType == null&quot;);</div><div class="line">  checkNotNull(annotations, &quot;annotations == null&quot;);</div><div class="line"></div><div class="line">  int start = callAdapterFactories.indexOf(skipPast) + 1;</div><div class="line">  for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);</div><div class="line">    if (adapter != null) &#123;</div><div class="line">      return adapter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</div><div class="line">      .append(returnType)</div><div class="line">      .append(&quot;.\n&quot;);</div><div class="line">  if (skipPast != null) &#123;</div><div class="line">    builder.append(&quot;  Skipped:&quot;);</div><div class="line">    for (int i = 0; i &lt; start; i++) &#123;</div><div class="line">      builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</div><div class="line">    &#125;</div><div class="line">    builder.append(&apos;\n&apos;);</div><div class="line">  &#125;</div><div class="line">  builder.append(&quot;  Tried:&quot;);</div><div class="line">  for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</div><div class="line">  &#125;</div><div class="line">  throw new IllegalArgumentException(builder.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Retrofit的callAdapterFactories工厂集合匹配获取开始添加的适配器工厂</p>
<h1 id="如何自定义一个Converter及CallAdapter？"><a href="#如何自定义一个Converter及CallAdapter？" class="headerlink" title="如何自定义一个Converter及CallAdapter？"></a>如何自定义一个Converter及CallAdapter？</h1><h2 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h2><p>1、需要定义一个工厂类继承Converter.Factory</p>
<p>2、复写responseBodyConverter及requestBodyConverter方法</p>
<p>3、在Retrofit定义时加入自定义的Converter，addConverterFactory(new CustomConverterFactory())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author allen</div><div class="line"> * @date 2018/8/7</div><div class="line"> * 返回服务端返回的string结果</div><div class="line"> */</div><div class="line">public class CustomConverterFactory extends Converter.Factory &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        return StringResponseBodyConverter.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</div><div class="line">        return StringRequestBodyConverter.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static final class StringResponseBodyConverter implements Converter&lt;ResponseBody, String&gt; &#123;</div><div class="line">        static final CustomConverterFactory.StringResponseBodyConverter INSTANCE = new CustomConverterFactory.StringResponseBodyConverter();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String convert(ResponseBody value) &#123;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;CustomConverterFactory&quot;);</div><div class="line">                return value.string();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    static final class StringRequestBodyConverter implements Converter&lt;RequestBody, RequestBody&gt; &#123;</div><div class="line">        static final CustomConverterFactory.StringRequestBodyConverter INSTANCE = new CustomConverterFactory.StringRequestBodyConverter();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public RequestBody convert(@NonNull RequestBody value) &#123;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义CallAdapter"><a href="#自定义CallAdapter" class="headerlink" title="自定义CallAdapter"></a>自定义CallAdapter</h2><p>1、需要定义一个工厂类继承CallAdapter.Factory</p>
<p>2、复写CallAdapter&lt;?, ?&gt; get方法</p>
<p>3、在Retrofit定义时加入自定义的CallAdapter， addCallAdapterFactory(new CustomCallAdapterFactory())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author allen</div><div class="line"> * @date 2018/8/7</div><div class="line"> */</div><div class="line">public class CustomCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line"></div><div class="line">        return new CallAdapter&lt;Object, Object&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Type responseType() &#123;</div><div class="line">                return String.class;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public Object adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">                System.out.println(&quot;CustomCallAdapterFactory adapt(&quot;);</div><div class="line">                return call;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Retrofit中运用了那些设计模式？"><a href="#Retrofit中运用了那些设计模式？" class="headerlink" title="Retrofit中运用了那些设计模式？"></a>Retrofit中运用了那些设计模式？</h1><p>1、建造者模式</p>
<p>Retrofit对象的创建、ServiceMethod对象创建都使用Build模式，将复杂对象的创建和表示分离，调用者不需要知道复杂的创建过程，使用Build的相关方法进行配置创建对象。</p>
<p>2、外观模式 </p>
<p>Retrofit对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、动态代理模式</p>
<p>通过动态代理的方式，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象。</p>
<p>4、静态代理模式<br>Android平台默认的适配器ExecutorCallbackCall，采用静态代理的模式。具体的实现delegate为OkHttpCall。</p>
<p>5、工厂模式<br>Converter及CallAdapter的创建都采用了工厂模式进行创建。</p>
<p>6、适配器模式<br>CallAdapter的adapt采用了适配器模式，使得interface的返回对象可以动态扩展，增强了灵活性</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>大多数流行的开源框架都是经过顶级coder的设计，包含了很多精妙的设计。多学习分析，收益良多。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="external">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73732115" target="_blank" rel="external">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/02/OkHttp源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/02/OkHttp源码学习随笔/" itemprop="url">
                  OkHttp源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T15:13:51+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/02/OkHttp源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/OkHttp源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OkHttp是什么？"><a href="#OkHttp是什么？" class="headerlink" title="OkHttp是什么？"></a>OkHttp是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OkHttp是一款优秀的HTTP框架，它支持get请求和post请求，支持基于Http的文件上传和下载，支持加载图片，支持下载文件透明的GZIP压缩，支持响应缓存避免重复的网络请求，支持使用连接池来降低响应延迟问题。OkHttp由Square公司开发，是目前Android最热门的网络框架之一。</p>
<p>官网网址：<a href="http://square.github.io/okhttp/" target="_blank" rel="external">OKHttp官网</a></p>
<p>Github地址:<a href="https://github.com/square/okhttp" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>支持HTTP2/SPDY</li>
<li>socket自动选择最好路线，并支持自动重连</li>
<li>拥有自动维护的socket连接池，减少握手次数</li>
<li>拥有队列线程池，轻松写并发</li>
<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）基于Headers的缓存策略</li>
</ol>
<h1 id="OkHttp怎么用？"><a href="#OkHttp怎么用？" class="headerlink" title="OkHttp怎么用？"></a>OkHttp怎么用？</h1><p>1、gradle引入库，implementation ‘com.squareup.okhttp3:okhttp:3.11.0’</p>
<p>2、初始化OkHttpClient对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client = new OkHttpClient.Builder()</div><div class="line">               .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .readTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .writeTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .build();</div></pre></td></tr></table></figure>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void okHttpSync() &#123;</div><div class="line">        Request request = new Request.Builder()</div><div class="line">                .url(&quot;https://www.baidu.com&quot;)</div><div class="line">                .build();</div><div class="line">        Call call = client.newCall(request);</div><div class="line">        try &#123;</div><div class="line">            Response response = call.execute();</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                System.out.println(&quot;response.code()==&quot; + response.code());</div><div class="line">                System.out.println(&quot;response.heard()==&quot; + response.headers());</div><div class="line">                System.out.println(&quot;response.message()==&quot; + response.message());</div><div class="line">                System.out.println(&quot;res==&quot; + response.body().string());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void okHttpAsync() &#123;</div><div class="line">    Request request = new Request.Builder()</div><div class="line">            .url(&quot;https://www.baidu.com&quot;)</div><div class="line">            .build();</div><div class="line">    Call call = client.newCall(request);</div><div class="line">    call.enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;</div><div class="line">            needCancelled.set(true);</div><div class="line">            System.out.println(&quot;url==&quot; + call.request().url());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                System.out.println(&quot;response.code()==&quot; + response.code());</div><div class="line">                System.out.println(&quot;response.heard()==&quot; + response.headers());</div><div class="line">                System.out.println(&quot;response.message()==&quot; + response.message());</div><div class="line">                System.out.println(&quot;res==&quot; + response.body().string());</div><div class="line">                needCancelled.set(true);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细的OkHttp使用可参考<a href="https://blog.csdn.net/fightingXia/article/details/70947701" target="_blank" rel="external">OKHttp使用详解</a></p>
<h1 id="OkHttp核心执行流程是怎样？"><a href="#OkHttp核心执行流程是怎样？" class="headerlink" title="OkHttp核心执行流程是怎样？"></a>OkHttp核心执行流程是怎样？</h1><h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OKHttpClient</td>
<td>里面包含了很多对象，OKhttp的很多功能模块都包装进这个类，让这个类单独提供对外的API，使用Builder模型构建</td>
</tr>
<tr>
<td>Request、Response</td>
<td>抽象的网络输入及响应模型</td>
</tr>
<tr>
<td>Call</td>
<td>HTTP请求任务封装，是一个接口</td>
</tr>
<tr>
<td>RealCall</td>
<td>Call的实现，实现execute()同步方法、enqueue(Callback responseCallback)异步方法， getResponseWithInterceptorChain() 获取拦截器响应</td>
</tr>
<tr>
<td>AsyncCall</td>
<td>RealCall的内部类。继承了Runnable接口，后续在异步的线程池中执行</td>
</tr>
<tr>
<td>Dispatcher</td>
<td>核心调度类，内部维护为了readyAsyncCalls、runningAsyncCalls、runningSyncCalls队列，实际RealCall后续也是调用该类进行同步、异步的具体实现。内部维护了一个线程池，限制了最大并发数maxRequests=64。</td>
</tr>
<tr>
<td>RealInterceptorChain</td>
<td>拦截器链，维护了一个interceptors队列，每次proceed通过index + 1会执行下一拦截器的intercept方法</td>
</tr>
<tr>
<td>RetryAndFollowUpInterceptor</td>
<td>负责失败重连以及重定向</td>
</tr>
<tr>
<td>BridgeInterceptor</td>
<td>负责对Request和Response报文进行加工</td>
</tr>
<tr>
<td>CacheInterceptor</td>
<td>负责缓存拦截器</td>
</tr>
<tr>
<td>ConnectInterceptor</td>
<td>负责维护连接拦截器</td>
</tr>
<tr>
<td>CallServerInterceptor</td>
<td>负责最后网络IO的读写</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-308f8d448174afa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、通过Builder模式统一构建OkHttpClient对象</p>
<p>2、通过Call，实现类RealCall进行请求发送</p>
<p>3、RealCall通过调用了Dispatcher的execute()及enqueue()方法进行同步及异步的请求</p>
<p>4、最终调用ReallCall的getResponseWithInterceptorChain()方法进行拦截链的拦截</p>
<p>5、依次通过重定向拦截器、桥接拦截器、缓存拦截器、连接拦截器、网络拦截器依次进行处理</p>
<p>6、最后通过intercept的return往回返回Response，最终返回给客户端请求的结果</p>
<h1 id="OkHttp如何进行线程调度控制？"><a href="#OkHttp如何进行线程调度控制？" class="headerlink" title="OkHttp如何进行线程调度控制？"></a>OkHttp如何进行线程调度控制？</h1><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在Dispatcher中维护了一个线程池，异步的请求会将任务加入到线程池中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public synchronized ExecutorService executorService() &#123;</div><div class="line">   if (executorService == null) &#123;</div><div class="line">     executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</div><div class="line">         new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">   &#125;</div><div class="line">   return executorService;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>默认的最大并发数为maxRequests=64，如果超过限制会加入到等待队列中，执行异步的方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">   if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">     runningAsyncCalls.add(call);</div><div class="line">     executorService().execute(call);</div><div class="line">   &#125; else &#123;</div><div class="line">     readyAsyncCalls.add(call);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>最后线程池执行AsyncCall中的execute()方法，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override protected void execute() &#123;</div><div class="line">   boolean signalledCallback = false;</div><div class="line">   try &#123;</div><div class="line">     Response response = getResponseWithInterceptorChain();</div><div class="line">     if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">       signalledCallback = true;</div><div class="line">       responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">     &#125; else &#123;</div><div class="line">       signalledCallback = true;</div><div class="line">       responseCallback.onResponse(RealCall.this, response);</div><div class="line">     &#125;</div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">     if (signalledCallback) &#123;</div><div class="line">       // Do not signal the callback twice!</div><div class="line">       Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">     &#125; else &#123;</div><div class="line">       eventListener.callFailed(RealCall.this, e);</div><div class="line">       responseCallback.onFailure(RealCall.this, e);</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     client.dispatcher().finished(this);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="队列机制"><a href="#队列机制" class="headerlink" title="队列机制"></a>队列机制</h2><p>Dispathcer中维护了3个队列，分别为异步等待队列、异步执行队列、同步执行队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** Ready async calls in the order they&apos;ll be run. */</div><div class="line"> private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"> /** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line"> private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"> /** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line"> private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>不管是同步还是异步，最终在finally块都会调用dispatcher的finished方法，会移除掉该队列任务，最后实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int runningCallsCount;</div><div class="line">   Runnable idleCallback;</div><div class="line">   synchronized (this) &#123;</div><div class="line">     if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</div><div class="line">     if (promoteCalls) promoteCalls();</div><div class="line">     runningCallsCount = runningCallsCount();</div><div class="line">     idleCallback = this.idleCallback;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</div><div class="line">     idleCallback.run();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>在finish中会再调用promoteCalls方法，会重新检索准备中的队列，将队列加入到线程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void promoteCalls() &#123;</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="OkHttp的拦截器及调用链是怎么执行？"><a href="#OkHttp的拦截器及调用链是怎么执行？" class="headerlink" title="OkHttp的拦截器及调用链是怎么执行？"></a>OkHttp的拦截器及调用链是怎么执行？</h1><h2 id="调用链执行流程"><a href="#调用链执行流程" class="headerlink" title="调用链执行流程"></a>调用链执行流程</h2><p>通过上述的分析，我们知道不管同步还是异步，最终调用到的都是RealCall的getResponseWithInterceptorChain()方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">   // Build a full stack of interceptors.</div><div class="line">   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">   interceptors.addAll(client.interceptors());</div><div class="line">   interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">   interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">   interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">   interceptors.add(new ConnectInterceptor(client));</div><div class="line">   if (!forWebSocket) &#123;</div><div class="line">     interceptors.addAll(client.networkInterceptors());</div><div class="line">   &#125;</div><div class="line">   interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">   Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</div><div class="line">       originalRequest, this, eventListener, client.connectTimeoutMillis(),</div><div class="line">       client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line"></div><div class="line">   return chain.proceed(originalRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>其中定义了拦截器集合及RealInterceptorChain拦截链，具体执行了拦截链的proceed方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">     RealConnection connection) throws IOException &#123;</div><div class="line">   if (index &gt;= interceptors.size()) throw new AssertionError();</div><div class="line"></div><div class="line">   calls++;</div><div class="line"></div><div class="line">   // If we already have a stream, confirm that the incoming request will use it.</div><div class="line">   if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">         + &quot; must retain the same host and port&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we already have a stream, confirm that this is the only call to chain.proceed().</div><div class="line">   if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">         + &quot; must call proceed() exactly once&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Call the next interceptor in the chain.</div><div class="line">   RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</div><div class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</div><div class="line">       writeTimeout);</div><div class="line">   Interceptor interceptor = interceptors.get(index);</div><div class="line">   Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">   // Confirm that the next interceptor made its required call to chain.proceed().</div><div class="line">   if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</div><div class="line">         + &quot; must call proceed() exactly once&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Confirm that the intercepted response isn&apos;t null.</div><div class="line">   if (response == null) &#123;</div><div class="line">     throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (response.body() == null) &#123;</div><div class="line">     throw new IllegalStateException(</div><div class="line">         &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return response;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>1、先判断是否超过list的size，如果超过则遍历结束，如果没有超过则继续执行</p>
<p>2、calls+1</p>
<p>3、new了一个RealInterceptorChain，其中然后下标index+1</p>
<p>4、从list取出下一个interceptor对象</p>
<p>5、执行interceptor的intercept方法</p>
<p>总结一下就是每一个RealInterceptorChain对应一个interceptor,然后每一个interceptor再产生下一个RealInterceptorChain，直到List迭代完成。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-0e1febbb5a84fe77?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>从上面的调用关系可以看出除了红色圈出的拦截器之外都是系统提供的拦截器，这整个过程是递归的执行过程，在 CallServerInterceptor 中得到最终的 Response 之后，将 response 按递归逐级进行返回，期间会经过 NetworkInterceptor 最后到达  Application Interceptor 。</p>
<h1 id="OkHttp是如何进行数据缓存？"><a href="#OkHttp是如何进行数据缓存？" class="headerlink" title="OkHttp是如何进行数据缓存？"></a>OkHttp是如何进行数据缓存？</h1><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>OkHttp使用了CacheInterceptor拦截器进行数据缓存的控制使用了CacheStrategy实现了上面的流程图，它根据之前缓存的结果与当前将要发送Request的header进行策略，并得出是否进行请求的结果。根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下：</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>result 结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>null</td>
<td>only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误)</td>
</tr>
<tr>
<td>null</td>
<td>non-null</td>
<td>不进行网络请求，直接返回缓存，不请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td>null</td>
<td>需要进行网络请求，而且缓存不存在或者过去，直接访问网络</td>
</tr>
<tr>
<td>non-null</td>
<td>non-null</td>
<td>Header中包含ETag/Last-Modified标签，需要在满足条件下请求，还是需要访问网络</td>
</tr>
</tbody>
</table>
<h2 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h2><p>通过分析CacheInterceptor拦截器的intercept方法，我们可以发现具体的缓存都是使用了Cache类进行，最后具体的实现在DiskLruCache类中。缓存实际上是一个比较复杂的逻辑，单独的功能块，实际上不属于OKhttp上的功能，实际上是通过是http协议和DiskLruCache做了处理。LinkedHashMap可以实现LRU算法，并且在这个case里，它被用作对DiskCache的内存索引</p>
<p>有兴趣可以参考如下2篇文章的具体实现：</p>
<p><a href="https://www.jianshu.com/p/b32d13655be7" target="_blank" rel="external">OKHttp源码解析(六)–中阶之缓存基础</a></p>
<p><a href="https://www.jianshu.com/p/a68dc1ca6120" target="_blank" rel="external">OKHttp源码解析(七)–中阶之缓存机制</a></p>
<h1 id="OkHttp的连接池复用机制是怎么样？"><a href="#OkHttp的连接池复用机制是怎么样？" class="headerlink" title="OkHttp的连接池复用机制是怎么样？"></a>OkHttp的连接池复用机制是怎么样？</h1><h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><p>RealConnection是Connection的实现类，代表着链接socket的链路，如果拥有了一个RealConnection就代表了我们已经跟服务器有了一条通信链路，而且通过<br>RealConnection代表是连接socket链路，RealConnection对象意味着我们已经跟服务端有了一条通信链路。<br>另外StreamAllocation类为流的桥梁，在RetryAndFollowUpInterceptor中进行初始化，在ConnectInterceptor中进行newStream操作，具体的连接拦截器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">   RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">   Request request = realChain.request();</div><div class="line">   StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">   // We need the network to satisfy this request. Possibly for validating a conditional GET.</div><div class="line">   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</div><div class="line">   HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</div><div class="line">   RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">   return realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>newStream创建留最后会调用到findConnection方法，这里面是连接复用的关键，如果再连接池中找到能复用的连接，则直接返回。<br>否则将RealConnection加入到链接池ConnectionPool中,具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</div><div class="line">     int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123;</div><div class="line">   boolean foundPooledConnection = false;</div><div class="line">   RealConnection result = null;</div><div class="line">   Route selectedRoute = null;</div><div class="line">   Connection releasedConnection;</div><div class="line">   Socket toClose;</div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     if (released) throw new IllegalStateException(&quot;released&quot;);</div><div class="line">     if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</div><div class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">     // Attempt to use an already-allocated connection. We need to be careful here because our</div><div class="line">     // already-allocated connection may have been restricted from creating new streams.</div><div class="line">     releasedConnection = this.connection;</div><div class="line">     toClose = releaseIfNoNewStreams();</div><div class="line">     if (this.connection != null) &#123;</div><div class="line">       // We had an already-allocated connection and it&apos;s good.</div><div class="line">       result = this.connection;</div><div class="line">       releasedConnection = null;</div><div class="line">     &#125;</div><div class="line">     if (!reportedAcquired) &#123;</div><div class="line">       // If the connection was never reported acquired, don&apos;t report it as released!</div><div class="line">       releasedConnection = null;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (result == null) &#123;</div><div class="line">       // Attempt to get a connection from the pool.</div><div class="line">       Internal.instance.get(connectionPool, address, this, null);</div><div class="line">       if (connection != null) &#123;</div><div class="line">         foundPooledConnection = true;</div><div class="line">         result = connection;</div><div class="line">       &#125; else &#123;</div><div class="line">         selectedRoute = route;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   closeQuietly(toClose);</div><div class="line"></div><div class="line">   if (releasedConnection != null) &#123;</div><div class="line">     eventListener.connectionReleased(call, releasedConnection);</div><div class="line">   &#125;</div><div class="line">   if (foundPooledConnection) &#123;</div><div class="line">     eventListener.connectionAcquired(call, result);</div><div class="line">   &#125;</div><div class="line">   if (result != null) &#123;</div><div class="line">     // If we found an already-allocated or pooled connection, we&apos;re done.</div><div class="line">     return result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we need a route selection, make one. This is a blocking operation.</div><div class="line">   boolean newRouteSelection = false;</div><div class="line">   if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123;</div><div class="line">     newRouteSelection = true;</div><div class="line">     routeSelection = routeSelector.next();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">     if (newRouteSelection) &#123;</div><div class="line">       // Now that we have a set of IP addresses, make another attempt at getting a connection from</div><div class="line">       // the pool. This could match due to connection coalescing.</div><div class="line">       List&lt;Route&gt; routes = routeSelection.getAll();</div><div class="line">       for (int i = 0, size = routes.size(); i &lt; size; i++) &#123;</div><div class="line">         Route route = routes.get(i);</div><div class="line">         Internal.instance.get(connectionPool, address, this, route);</div><div class="line">         if (connection != null) &#123;</div><div class="line">           foundPooledConnection = true;</div><div class="line">           result = connection;</div><div class="line">           this.route = route;</div><div class="line">           break;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (!foundPooledConnection) &#123;</div><div class="line">       if (selectedRoute == null) &#123;</div><div class="line">         selectedRoute = routeSelection.next();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Create a connection and assign it to this allocation immediately. This makes it possible</div><div class="line">       // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.</div><div class="line">       route = selectedRoute;</div><div class="line">       refusedStreamCount = 0;</div><div class="line">       result = new RealConnection(connectionPool, selectedRoute);</div><div class="line">       acquire(result, false);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we found a pooled connection on the 2nd time around, we&apos;re done.</div><div class="line">   if (foundPooledConnection) &#123;</div><div class="line">     eventListener.connectionAcquired(call, result);</div><div class="line">     return result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Do TCP + TLS handshakes. This is a blocking operation.</div><div class="line">   result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</div><div class="line">       connectionRetryEnabled, call, eventListener);</div><div class="line">   routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">   Socket socket = null;</div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     reportedAcquired = true;</div><div class="line"></div><div class="line">     // Pool the connection.</div><div class="line">     Internal.instance.put(connectionPool, result);</div><div class="line"></div><div class="line">     // If another multiplexed connection to the same address was created concurrently, then</div><div class="line">     // release this connection and acquire that one.</div><div class="line">     if (result.isMultiplexed()) &#123;</div><div class="line">       socket = Internal.instance.deduplicate(connectionPool, address, this);</div><div class="line">       result = connection;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   closeQuietly(socket);</div><div class="line"></div><div class="line">   eventListener.connectionAcquired(call, result);</div><div class="line">   return result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>OkHttp中使用ConnectionPool管理http和http/2的链接，以便减少网络请求延迟。同一个address将共享同一个connection。该类实现了复用连接的目标。一个OkHttpClient只包含一个ConnectionPool，其实例化也是在OkHttpClient的过程。这里说一下ConnectionPool各个方法的调用并没有直接对外暴露，而是通过OkHttpClient的Internal接口统一对外暴露。</p>
<p>1、获取连接使用get方法,或获取是否有合适的链接，否则返回null，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123;</div><div class="line">   assert (Thread.holdsLock(this));</div><div class="line">   for (RealConnection connection : connections) &#123;</div><div class="line">     if (connection.isEligible(address, route)) &#123;</div><div class="line">       streamAllocation.acquire(connection, true);</div><div class="line">       return connection;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>2、加入连接使用put方法，并且会是会触发cleanupRunnable，清理连接。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void put(RealConnection connection) &#123;</div><div class="line">    assert (Thread.holdsLock(this));</div><div class="line">    if (!cleanupRunning) &#123;</div><div class="line">      cleanupRunning = true;</div><div class="line">      executor.execute(cleanupRunnable);</div><div class="line">    &#125;</div><div class="line">    connections.add(connection);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>3、具体的连接回收机制，首先统计空闲连接数量，然后通过for循环查找最长空闲时间的连接以及对应空闲时长，然后判断是否超出最大空闲连接数(maxIdleConnections)或者或者超过最大空闲时间(keepAliveDurationNs)，满足其一则清除最长空闲时长的连接。如果不满足清理条件，则返回一个对应等待时间。具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">long cleanup(long now) &#123;</div><div class="line">    int inUseConnectionCount = 0;</div><div class="line">    int idleConnectionCount = 0;</div><div class="line">    RealConnection longestIdleConnection = null;</div><div class="line">    long longestIdleDurationNs = Long.MIN_VALUE;</div><div class="line"></div><div class="line">    // Find either a connection to evict, or the time that the next eviction is due.</div><div class="line">    synchronized (this) &#123;</div><div class="line">      for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</div><div class="line">        RealConnection connection = i.next();</div><div class="line"></div><div class="line">        // If the connection is in use, keep searching.</div><div class="line">        if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123;</div><div class="line">          inUseConnectionCount++;</div><div class="line">          continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        idleConnectionCount++;</div><div class="line"></div><div class="line">        // If the connection is ready to be evicted, we&apos;re done.</div><div class="line">        long idleDurationNs = now - connection.idleAtNanos;</div><div class="line">        if (idleDurationNs &gt; longestIdleDurationNs) &#123;</div><div class="line">          longestIdleDurationNs = idleDurationNs;</div><div class="line">          longestIdleConnection = connection;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (longestIdleDurationNs &gt;= this.keepAliveDurationNs</div><div class="line">          || idleConnectionCount &gt; this.maxIdleConnections) &#123;</div><div class="line">        // We&apos;ve found a connection to evict. Remove it from the list, then close it below (outside</div><div class="line">        // of the synchronized block).</div><div class="line">        connections.remove(longestIdleConnection);</div><div class="line">      &#125; else if (idleConnectionCount &gt; 0) &#123;</div><div class="line">        // A connection will be ready to evict soon.</div><div class="line">        return keepAliveDurationNs - longestIdleDurationNs;</div><div class="line">      &#125; else if (inUseConnectionCount &gt; 0) &#123;</div><div class="line">        // All connections are in use. It&apos;ll be at least the keep alive duration &apos;til we run again.</div><div class="line">        return keepAliveDurationNs;</div><div class="line">      &#125; else &#123;</div><div class="line">        // No connections, idle or in use.</div><div class="line">        cleanupRunning = false;</div><div class="line">        return -1;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    closeQuietly(longestIdleConnection.socket());</div><div class="line"></div><div class="line">    // Cleanup again immediately.</div><div class="line">    return 0;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="OkHttp的底层网络实现是什么？"><a href="#OkHttp的底层网络实现是什么？" class="headerlink" title="OkHttp的底层网络实现是什么？"></a>OkHttp的底层网络实现是什么？</h1><p>1、OkHttp使用okio进行io的操作。okio是由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。OKHttp底层也是用该库作为支持。而且okio使用起来很简单，减少了很多io操作的基本代码，并且对内存和CPU使用做了优化。</p>
<p>2、没有依赖其他的关于Http实现的库，底层使用了Socket，自己实现了Http1.X及2.X的协议。</p>
<h1 id="OkHttp中代码运用了那些设计模式，有什么巧妙的设计？"><a href="#OkHttp中代码运用了那些设计模式，有什么巧妙的设计？" class="headerlink" title="OkHttp中代码运用了那些设计模式，有什么巧妙的设计？"></a>OkHttp中代码运用了那些设计模式，有什么巧妙的设计？</h1><p>1、建造者模式</p>
<p>不管是OkHttpClient对象的创建还是Request对象、Respone对象，都使用了建造者模式，将复杂的对象创建统一在不同方法中，使得创建的过程更加简单。</p>
<p>2、外观模式<br>OkHttpClient对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、责任链模式<br>OkHttp中的拦截器使用了责任链模式，将不同的拦截器独立实现，动态组成链的调用形式。责任清晰，可动态扩展。</p>
<h1 id="为什么要用OkHttp？"><a href="#为什么要用OkHttp？" class="headerlink" title="为什么要用OkHttp？"></a>为什么要用OkHttp？</h1><p>目前Android开发中，主要的网络框架有HttpClient、Volley、HttpURLConnection、OkHttp。</p>
<p>其中Android早就不推荐httpclient，5.0之后干脆废弃，6.0删除了HttpClient。所以HttpClient不考虑。Volley框架现在也已经不再升级了，故目前考虑使用的有、HttpURLConnection及OkHttp。</p>
<p>相对HttpURLConnection，OkHttp使用更加便捷及灵活，且第三方社区活跃，相关资料齐全，成熟稳定性高。OkHttp也得到了官方的认可，并在不断优化更新，所以建议应用优先选择OkHttp作为网络框架。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在项目的开发过程中，我们经常使用到大量的第三方框架，但可能知其然不知其所以然，通过不断的思考反问为什么，从而去研究源码中的实现。能让我们对框架更加运用自如及解决一些底层疑难的问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/fightingXia/article/details/70947701" target="_blank" rel="external">OKHttp使用详解</a></p>
<p><a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="external">OKHTTP结合官网示例分析两种自定义拦截器的区别</a></p>
<p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="external">OKHttp源码解析(一)系列</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/07/06/项目模块重构分享与思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/06/项目模块重构分享与思考/" itemprop="url">
                  项目模块重构分享与思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T15:16:58+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/06/项目模块重构分享与思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/06/项目模块重构分享与思考/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>云盘产品，文件模块的业务功能相对复杂，包含文件的显示、排序、筛选、加密隐藏、批量移动复制等功能。项目代码可以追溯到14年以前，中间也有N多人的接手，目前还是存在非常多问题，维护及扩展也是相对比较吃力。</p>
<p>最近由于产品功能正在策划，大约有一周时间可以对项目进行优化。故决定对文件模块进行梳理重构。在开始之前，这里先抛出几个问题，相信大部分的同学也可能有类型的疑问，在文末的终结也会谈一下自己的看法。</p>
<ol>
<li>业务需求频繁，开发功能都来不及，哪里有时间进行代码重构</li>
<li>公司并不看重代码质量，首先要满足功能开发。重构这个事情，做了也不一定被认同。等一下重构后，产生新的问题，后果更严重</li>
<li>这代码改起来真是蛋疼，好几个类功能都一样，新增或者修改都需要改几个地方。但是没办法，为了赶时间，暂时先这么干吧</li>
<li>想重构，但是却不知道如何下手。有时候有点空闲的时间，又感觉不够。所以一直没有动</li>
</ol>
<h2 id="文件模块情况"><a href="#文件模块情况" class="headerlink" title="文件模块情况"></a>文件模块情况</h2><h3 id="简单类关系图"><a href="#简单类关系图" class="headerlink" title="简单类关系图"></a>简单类关系图</h3><p>这里简单介绍一些文件模块目前的一些问题。先看一些类的关系图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6cb1c532f1fb3390?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h3><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyFileFragment</td>
<td>显示文件及文件操作的Fragment</td>
</tr>
<tr>
<td>FileMainActivity</td>
<td>文件主页面，依赖MyFileFragment</td>
</tr>
<tr>
<td>BaseList2Activity</td>
<td>文件列表基类，显示文件</td>
</tr>
<tr>
<td>MyFileActivity</td>
<td>作用和MyFileFragment相同，全局很多跳转到文件页面都是使用该类,继承了BaseList2Activity</td>
</tr>
<tr>
<td>DiskMusicActivity</td>
<td>音乐模块，从网盘导入音乐文件，是一个提供音乐文件选择页面，继承了MyFileActivity</td>
</tr>
<tr>
<td>AddAttachmentActivity</td>
<td>聊天模块，从网盘选择图片，是一个提供图片文件选择页面，继承了MyFileActivity</td>
</tr>
<tr>
<td>DiskSearchActivity</td>
<td>文件搜索页面，继承了MyFileActivity</td>
</tr>
<tr>
<td>FileListBaseFragment</td>
<td>文件展示页面，与BaseList2Activity类似</td>
</tr>
<tr>
<td>FileChooseActivity</td>
<td>网盘文件选择页面，是一个提供选择文件页面，依赖FileListBaseFragment</td>
</tr>
</tbody>
</table>
<h3 id="主要存在问题"><a href="#主要存在问题" class="headerlink" title="主要存在问题"></a>主要存在问题</h3><p>在项目的开发维护工程中，主要存在的地方如下：</p>
<p>1、存在多个功能相似的页面，例如MyFileFragment及MyFileActivity，功能高度相同。全局跳转到文件页面使用了MyFileActivity，文件主入口使用了FileMainActivity。由于历史原因，一直维护着2个类，新增功能和修改功能都要维护2个地方</p>
<p>2、文件列表显示存在多个类，BaseList2Activity、FileListBaseFragment、MyFileFragment</p>
<p>3、文件选择也有多个页面，音乐选择一个DiskMusicActivity、图片选择一个AddAttachmentActivity、还有附件选择一个FileChooseActivity</p>
<p>经常出现产品加一个功能，要几个类修改，并且有时候修Bug容易遗漏地方。</p>
<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在准备开始动手重构之前，先梳理了一下思路。</p>
<p>1、先搞清楚目前存在问题，哪里不爽。分析解决问题的方案</p>
<p>2、尽量不要动到原有的业务逻辑，着重于结构的升级</p>
<p>3、分解重构执行步骤，尽量细化成小任务，每个任务不相互影响。由于时间有限，争取每完成一个小步骤的重构，都能达到上线的状态</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>根据目前存在的问题及重构思路。本次重构主要解决3个大问题。</p>
<p>1、在项目中要干掉MyFileActivity，统一使用MyFileFragment。不要再同时维护2个相同的功能的类</p>
<p>2、统一文件列表的显示，避免出现多个显示文件的类</p>
<p>3、全局应该统一一个文件选择的页面。避免出现选择音乐一个界面、选择图片一个界面、选择附件又一个界面</p>
<h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>阶段一主要有优化处理1、2点。这里先上一下简单类结构关系图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-398303170798530c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、将MyFileActivity移除，新增BridgeFileActivity（继承了FileMainActivity），替代MyFileActivity。将全局文件跳转统一替换到BridgeFileActivity，BridgeFileActivity最终依赖了MyFileFragment。这样将文件主要操作的代码统一在了MyFileFragment，避免维护多个相同功能的类。</p>
<p>2、将文件的基础显示都FileListBaseFragment中，MyFileFragment继承于它。MyFileFragment扩展文件的操作功能。如删除、复制、移动、加密等功能</p>
<p>3、由于MyFileActivity的移除，原继承于它的DiskMusicActivity、DiskSearchActivity等都需要进行改造。重新定义DiskMusicFragment、DiskSearchFragment继承于MyFileFragment。将原来的Activity依赖于新定义的Fragment。</p>
<p>至此完成第一阶段，对原业务都未进行修改。只是将跳转入口进行替换。成功移除了MyFileActivity。解决上述问题1、2。</p>
<h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>阶段二主要优化第三点。同样先上下简单类结构关系图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-b2da226c7cfa08af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、对FileChooseActivity进行扩展，使用Builder模式进行配置，支持文件类型的筛选显示。废除DiskMusicActivity、AddAttachmentActivity。</p>
<p>音乐筛选页面代码跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FileChooseActivity.IntentBuilder builder = new FileChooseActivity.IntentBuilder(this);</div><div class="line">       builder.setChoiceMode(ChoiceMode.MULTI)</div><div class="line">               .setEventBusFlag(Signature.signature(this))</div><div class="line">               .setShowLocalFileList(false)</div><div class="line">               .setYywSelectType(FileChoiceParams.MUSIC)</div><div class="line">               .setSupportCheckAll(true)</div><div class="line">               .launch();</div></pre></td></tr></table></figure></p>
<p>图片筛选页面代码跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FileChooseActivity.IntentBuilder builder = new FileChooseActivity.IntentBuilder(this);</div><div class="line">       builder.setChoiceMode(ChoiceMode.MULTI)</div><div class="line">               .setEventBusFlag(Signature.signature(this))</div><div class="line">               .setShowLocalFileList(false)</div><div class="line">               .setMaxLimit(15)</div><div class="line">               .setYywSelectType(FileChoiceParams.PIC)</div><div class="line">               .setSupportCheckAll(false)</div><div class="line">               .launch();</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回到一开始抛出的问题，这里做一下自己的总结思考。</p>
<p>1、业务需求多，时间赶这是常态，时间要靠自己规划及提高效率挤出来。在开发的时候也要充分考虑，不能盲目追求功能实现。 一般项目上线后，新功能策划都有一段空白期，善于利用</p>
<p>2、不管公司重不重视代码重构。首先多思考、优化重构，对自己也是一种提升。相信在重构的过程，自己也可以有所收获</p>
<p>3、项目存在种种的历史遗留问题，有时候重构与不重构就是一个长痛和短痛的取舍。自己负责的模块代码不优化，加需求，改Bug，最终坑的还是自己</p>
<p>4、项目重构是不断演化的过程，没有一蹴而就。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/06/25/Android-P-兼容与适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/25/Android-P-兼容与适配/" itemprop="url">
                  Android P 兼容与适配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T10:15:17+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/25/Android-P-兼容与适配/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/25/Android-P-兼容与适配/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="P-新特性"><a href="#P-新特性" class="headerlink" title="P 新特性"></a>P 新特性</h1><p>Android P 在Google IO2018正式发版，全新的手势操作选项。底部虚拟键将由小白点和一颗返回键取代。通过轻触回到主页、长按呼出语音助手。新的特性主要有：</p>
<ul>
<li>利用 Wi-Fi RTT 进行室内定位</li>
<li>刘海平API支持</li>
<li>通知栏功能增强</li>
<li>多摄像头支持和摄像头更新</li>
<li>HDR VP9 视频、HEIF 图像压缩和 Media API</li>
</ul>
<p>详细可参考<a href="https://developer.android.google.cn/preview/features" target="_blank" rel="external">Google官方文档</a>介绍。</p>
<h1 id="P-兼容优化"><a href="#P-兼容优化" class="headerlink" title="P 兼容优化"></a>P 兼容优化</h1><p>根据官方的API迁移指南，对应用比较影响的有如下几点：</p>
<h2 id="non-SDK接口的使用"><a href="#non-SDK接口的使用" class="headerlink" title="non-SDK接口的使用"></a>non-SDK接口的使用</h2><p>一般来说，SDK 接口是指在 Android 框架<a href="https://developer.android.google.cn/reference/packages" target="_blank" rel="external">软件包索引</a>中记录的接口。 对非 SDK 接口的处理是 API 抽象化的实现细节；其会随时更改，恕不另行通。</p>
<p>Android P 引入了针对非 SDK 接口的新使用限制，无论是直接使用还是通过反射或 JNI 间接使用。 无论应用是引用非 SDK 接口还是尝试使用反射或 JNI 获取其句柄，均适用这些限制。</p>
<h3 id="名单分类"><a href="#名单分类" class="headerlink" title="名单分类"></a>名单分类</h3><ul>
<li>Light grey list: targetSDK&gt;=P时，警告；</li>
<li>Dark grey list: targetSDK<p时，警告；>=p时，不允许调用；</p时，警告；></li>
<li>Black list:三方应用不允许调用； </li>
</ul>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/config/" target="_blank" rel="external">名单查看</a></p>
<h3 id="具体影响"><a href="#具体影响" class="headerlink" title="具体影响"></a>具体影响</h3><table>
<thead>
<tr>
<th>访问方式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dalvik 指令引用字段</td>
<td>引发 NoSuchFieldError</td>
</tr>
<tr>
<td>Dalvik 指令引用函数</td>
<td>引发 NoSuchMethodError</td>
</tr>
<tr>
<td>通过 Class.getDeclaredField() 或 Class.getField() 反射</td>
<td>引发 NoSuchFieldException</td>
</tr>
<tr>
<td>通过 Class.getDeclaredMethod() 或 Class.getMethod() 反射</td>
<td>引发 NoSuchMethodException</td>
</tr>
<tr>
<td>通过 Class.getDeclaredFields() 或 Class.getFields() 反射</td>
<td>结果中未出现非 SDK 成员</td>
</tr>
<tr>
<td>通过 Class.getDeclaredMethods() 或 Class.getMethods() 反射</td>
<td>结果中未出现非 SDK 成员</td>
</tr>
<tr>
<td>通过 env-&gt;GetFieldID() 调用 JNI</td>
<td>返回 NULL，引发 NoSuchFieldError</td>
</tr>
<tr>
<td>通过 env-&gt;GetMethodID() 调用 JNI</td>
<td>返回 NULL，引发 NoSuchMethodError</td>
</tr>
</tbody>
</table>
<h2 id="挖孔屏适配"><a href="#挖孔屏适配" class="headerlink" title="挖孔屏适配"></a>挖孔屏适配</h2><p>谷歌P版本提供了统一的挖孔屏方案和三方适配挖孔屏方案：</p>
<ul>
<li>对于有状态栏的页面，不会受到挖孔屏特性的影响；</li>
<li>全屏显示的页面，系统挖孔屏方案会对应用界面做下移避开挖孔区显示；</li>
<li>已经适配的P的应用的全屏页面可以通过谷歌提供的适配方案使用挖孔区，真正做到全屏显示</li>
</ul>
<p>总的来说，就是P版本已经坐了兼容，全屏显示和状态栏显示，都会避开挖空区域显示。<br>但注意对于沉浸式的显示要注意，避免挖空挡住UI布局，需要做好适配。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-34d87cf21befeb0f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例一"><br><img src="http://upload-images.jianshu.io/upload_images/5125122-e3d33530cafa41c1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例二"></p>
<h2 id="P版本三方适配挖孔屏方案"><a href="#P版本三方适配挖孔屏方案" class="headerlink" title="P版本三方适配挖孔屏方案"></a>P版本三方适配挖孔屏方案</h2><p>1、 新增挖孔屏挖孔尺寸和位置接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class WindowInsets &#123;</div><div class="line">DisplayCutout getDisplayCutout();</div><div class="line">&#125;</div><div class="line">class DisplayCutout &#123;</div><div class="line">int getSafeInsetLeft();</div><div class="line">int getSafeInsetTop();</div><div class="line">int getSafeInsetRight();</div><div class="line">int getSafeInsetBottom();</div><div class="line">Region getBounds();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、新窗口布局模式，允许应用程序请求是否在挖孔区域布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class WindowManager.LayoutParams &#123;</div><div class="line">int layoutInDisplayCutoutMode;</div><div class="line">final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT;</div><div class="line">final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;</div><div class="line">final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER;</div><div class="line">	&#125;</div><div class="line">layoutInDisplayCutoutMode值说明：</div><div class="line"></div><div class="line">a）LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：默认情况下，全屏窗口不会使用到挖孔区域，非全屏窗口可正常使用挖孔区域。</div><div class="line">b）LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS：窗口声明使用挖孔区域</div><div class="line">c）LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：窗口声明不使用挖孔区域</div></pre></td></tr></table></figure>
<h2 id="Battery-Improvements"><a href="#Battery-Improvements" class="headerlink" title="Battery Improvements"></a>Battery Improvements</h2><p>谷歌在P版本之前没有一个完整的功耗解决方案，OEM厂商分别开发各自的功耗方案，管控手段都包括了清理应用，功耗得到优化，但是同时也影响了三方应用的一些功能正常使用，谷歌为了解决这个问题在P版本提出了自己的功耗解决方案。</p>
<h3 id="主要方案："><a href="#主要方案：" class="headerlink" title="主要方案："></a>主要方案：</h3><ul>
<li>AAB（Auto Awesome Battery)：</li>
</ul>
<p>1、通过ML算法将应用进行分类，不同类型的应用功耗管控策略不一样</p>
<p>2、 Firebase Cloud Messaging (FCM):管控三方消息接收的频率</p>
<p>3、谷歌提供了统一的应用的管控方法：Forced App Standby (FAS)，谷歌不会通过清理应用来优化功耗</p>
<ul>
<li><p>Extreme Battery Saver（EBS）谷歌超级省电模式；</p>
</li>
<li><p>Smart screen brightness：屏幕亮度调节优化算法。</p>
</li>
</ul>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>谷歌功耗方案对三方应用各种管控，存在导致应用后台功能无法正常使用的可能，特别是：IM、邮箱、闹钟、音乐（直播）、地图导航、运动健康、下载、日历等应用影响比较大。目前通过谷歌提供的调试命令验证：所有的应用都有可能会被分到管控的类型，对三方的后台功能是有影响的。</p>
<h2 id="不允许共享WebView数据目录"><a href="#不允许共享WebView数据目录" class="headerlink" title="不允许共享WebView数据目录"></a>不允许共享WebView数据目录</h2><p>应用程序不能再跨进程共享单个WebView数据目录。如果您的应用有多个使用WebView，CookieManager或android.webkit包中的其他API的进程，则当第二个进程调用WebView方法时，您的应用将崩溃。</p>
<p>该特性只影响已经适配P的应用，也就是targetSDK Version&gt;=P。</p>
<h2 id="移除对-Build-serial-的直接访问"><a href="#移除对-Build-serial-的直接访问" class="headerlink" title="移除对 Build.serial 的直接访问"></a>移除对 Build.serial 的直接访问</h2><p>现在，需要 Build.serial 标识符的应用必须请求 READ_PHONE_STATE 权限，然后使用 Android P 中新增的新 Build.getSerial() 函数</p>
<h2 id="SELinux-禁止访问应用的数据目录"><a href="#SELinux-禁止访问应用的数据目录" class="headerlink" title="SELinux 禁止访问应用的数据目录"></a>SELinux 禁止访问应用的数据目录</h2><p>系统强制每个应用的 SELinux 沙盒对每个应用的私有数据目录强制执行逐个应用的 SELinux 限制。现在，不允许直接通过路径访问其他应用的数据目录。应用可以继续使用进程间通信 (IPC) 机制（包括通过传递 FD）共享数据</p>
<h1 id="项目升级P实操"><a href="#项目升级P实操" class="headerlink" title="项目升级P实操"></a>项目升级P实操</h1><h2 id="使用模拟器"><a href="#使用模拟器" class="headerlink" title="使用模拟器"></a>使用模拟器</h2><p>1、使用Android studio 3.1或者更高的版本<br>2、升级Android  API 28版本，SDK Tools升级至Android SDK Build-Tools 28<br>3、下载API 28的模拟机镜像<br>4、设置启动模拟机</p>
<p>这里遇到一个坑，模拟机一直起不来。注意Graphics设置为Software-GLES 2.0</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-3eebb34f19680621?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="更新项目Gradle配置"><a href="#更新项目Gradle配置" class="headerlink" title="更新项目Gradle配置"></a>更新项目Gradle配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">androidTargetSdkVersion = 28</div><div class="line">androidCompileSdkVersion = 28</div></pre></td></tr></table></figure>
<h2 id="模拟机开发者选项设置"><a href="#模拟机开发者选项设置" class="headerlink" title="模拟机开发者选项设置"></a>模拟机开发者选项设置</h2><p>开发者选项支持设置模拟刘海屏缺口，项目可通过设置，进行应用的测试。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-550b01b1ed53df69?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="项目升级遇到问题"><a href="#项目升级遇到问题" class="headerlink" title="项目升级遇到问题"></a>项目升级遇到问题</h2><p>这里注意我们应用是直接在24升级到28.</p>
<p>1、java.lang.SecurityException: Failed to find provider null for user 0; expected to find a valid ContentProvider for this authority</p>
<p>问题原因：项目使用了ActiveAndroid，在 8.0 或 8.1 系统上使用 26 或以上的版本的 SDK 时，调用 ContentResolver 的 notifyChange 方法通知数据更新，或者调用 ContentResolver 的 registerContentObserver 方法监听数据变化时，会出现上述异常。</p>
<p>解决方案：<br>在清单文件配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;provider</div><div class="line">        android:name=&quot;com.activeandroid.content.ContentProvider&quot;</div><div class="line">        android:authorities=&quot;com.ylmf.androidclient&quot;</div><div class="line">        android:enabled=&quot;true&quot;</div><div class="line">        android:exported=&quot;false&quot;&gt;</div><div class="line">&lt;/provider&gt;</div></pre></td></tr></table></figure></p>
<p>2、CLEARTEXT communication to life.115.com not permitted by network security policy</p>
<p>问题原因： Android P 限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉</p>
<p>解决方案：</p>
<p>在资源文件新建xml目录，新建文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;network-security-config&gt;</div><div class="line">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;</div><div class="line">&lt;/network-security-config&gt;</div></pre></td></tr></table></figure></p>
<p>清单文件配置：android:networkSecurityConfig=”@xml/network_security_config”</p>
<p>但还是建议都使用https进行传输</p>
<p>3、8.0，静态广播无法正常接收</p>
<p>问题原因： Android 8.0 引入了新的广播接收器限制，因此您应该移除所有为隐式广播 Intent 注册的广播接收器</p>
<p>解决方案：<br>使用动态广播代替静态广播</p>
<p>4、Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation</p>
<p>问题原因： Android 8.0 非全屏透明页面不允许设置方向</p>
<p>解决方案：android:windowIsTranslucent设置为false</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、随着Google新的版本发布，项目应尽快跟进兼容。否则后面有多个版本的迭代，遗留的坑会比较多</p>
<p>2、项目可在独立分支升级兼容，然后进行业务功能测试，发现问题进行针对性处理。可先解决一些闪退，功能不正常的问题。</p>
<p>3、多参考Google官方的版本适配介绍，有详细的技术指导</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.google.cn/preview/" target="_blank" rel="external">Google官方文档</a></p>
<p><a href="https://devcenter.huawei.com/consumer/cn/devservice/doc/50115" target="_blank" rel="external">Android P版本应用兼容性适配技术指导</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/05/29/记一次Android内存泄漏的优化经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/29/记一次Android内存泄漏的优化经历/" itemprop="url">
                  记一次Android内存泄漏的优化经历
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T11:12:50+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/29/记一次Android内存泄漏的优化经历/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/29/记一次Android内存泄漏的优化经历/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通过线上收集的日志分析，存在部分OOM的日志，故通过leakcanary进行内存泄漏追踪。</p>
<h2 id="引用链日志"><a href="#引用链日志" class="headerlink" title="引用链日志"></a>引用链日志</h2><p>在开发的过程中，leakcanary报出了内存泄漏，详细的日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/5125122-bb502cdd6ebdcf05?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>并且全局有其他Activity也存在相同引用链的内存泄漏，日志如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5fdfff03a83d0179?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>使用MAT进行分析，引用链也相同，日志如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4e08f3d369209a5c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>通过AS自带的Profiler进行分析，发现此内存泄漏非常严重，进入多次Activity，页面Finish掉后，GC均无法进行回收,实例会一直存在。这样如果用户多次操作页面，那么很容易触发OOM的异常。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-01966d641b635fec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>FileMainActivity大致的结构如下，一个Activity里面，包含了一个Fragment，Fragment是一个列表。</p>
<p>通过引用链可以发现为ViewRootImpl$ViewRootHandler导致Activity没有回收。初步怀疑是否由于handler导致。但通过排查FileMainActivity代码，内部的handler是使用static内部类，同时也使用了软引用持有，并没有导致触发的原因。</p>
<p>通过搜索引擎，也无相关的博文介绍。问题一度陷入停滞。</p>
<p>但鉴于问题的严重性，决定采用排除法进行验证，当然过程耗时长，主要的思路如下：</p>
<p>1、Activity里面不集成Fragment，然后运行，重复进入退出，分析GC，发现不会存在内存泄漏；<br>（问题初步定为为Fragment里的代码存在内存泄漏）</p>
<p>2、恢复Fragment代码，onActivityCreate中的代码大致为，初始化控件、请求网络数据、显示列表。通过依次屏蔽3个方法，再进入验证<br>（问题发现在屏蔽了显示列表的方法后，不会存在内存泄漏。问题定位在显示列表的方法中）</p>
<p>3、通过依次屏蔽显示列表的方法中，定位问题出在一句代码，引起了内存泄漏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mPullToRefreshLayout.refreshComplete();</div></pre></td></tr></table></figure></p>
<p>4、mPullToRefreshLayout是一个第三方的下拉刷新控件，<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh/blob/master/README-cn.md" target="_blank" rel="external">PtrFrameLayout</a>。refreshComplete的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Call this when data is loaded.</div><div class="line">     * The UI will perform complete at once or after a delay, depends on the time elapsed is greater then &#123;@link #mLoadingMinTime&#125; or not.</div><div class="line">     */</div><div class="line">    final public void refreshComplete() &#123;</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            PtrCLog.i(LOG_TAG, &quot;refreshComplete&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mRefreshCompleteHook != null) &#123;</div><div class="line">            mRefreshCompleteHook.reset();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int delay = (int) (mLoadingMinTime - (System.currentTimeMillis() - mLoadingStartTime));</div><div class="line">        if (delay &lt;= 0) &#123;</div><div class="line">            if (DEBUG) &#123;</div><div class="line">                PtrCLog.d(LOG_TAG, &quot;performRefreshComplete at once&quot;);</div><div class="line">            &#125;</div><div class="line">            performRefreshComplete();</div><div class="line">        &#125; else &#123;</div><div class="line">            postDelayed(new MyRunnable(this, 1), delay);</div><div class="line">            if (DEBUG) &#123;</div><div class="line">                PtrCLog.d(LOG_TAG, &quot;performRefreshComplete after delay: %s&quot;, delay);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>5、里面存在关键代码postDelayed，故怀疑可能此处代码产生内存泄漏。通过断点打印发现如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-2190c7733503d493?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>最终定位问题如下：<br>由于PtrFrameLayout的refreshComplete方法中的postDelayed导致了内存泄漏，由于delay很长，导致Activity不会被回收。</strong></p>
<h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>几经波折，终于定位到问题。那么现在就好处理了。通过分析我们发现这里主要的问题就是delay值很大导致。我们分析发现如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int delay = (int) (mLoadingMinTime - (System.currentTimeMillis() - mLoadingStartTime));</div></pre></td></tr></table></figure></p>
<p>发现了long强制转成了int，这里面导致了数据溢出，从而影响了delay最后的运算。这里通过如下处理则可修复内存泄漏的问题:<br><img src="http://upload-images.jianshu.io/upload_images/5125122-002cd0b33b6bf529?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>修复后，通过proflier分析，Activity已正常被GC回收，至此解决问题。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>1、分析内存泄漏需要多用工具，leakcanary、AS自带的Profile及Mat工具</p>
<p>2、需要耐心及细心，优化内存泄漏是一个挺麻烦，但也很重要的事情</p>
<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p><a href="https://www.jianshu.com/p/402225fce4b2" target="_blank" rel="external">Android性能优化-内存泄漏（上）</a></p>
<p><a href="https://www.jianshu.com/p/2c9fc4e871a4" target="_blank" rel="external">Android性能优化-内存泄漏（下）</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/01/09/Android应用架构前世今生/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/09/Android应用架构前世今生/" itemprop="url">
                  Android应用架构前世今生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T11:56:37+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/09/Android应用架构前世今生/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/09/Android应用架构前世今生/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android的开发生态系统发展迅速，在开发Android的几年的时间里，用来构建Android应用的架构与技术一直在不断进化。随着项目的不断更新迭代，应用的架构也有不一样的变化。由于开发人员的数量、项目的业务复杂度、需求的开发时间、应用的使用量级，使用的技术架构也不相同。没有最好的架构，只有最合适的。通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，便于项目的后期维护。下面总结及汇总一下目前Android使用的主要应用架构及其优缺点和使用的学习心得，如有不对之处，欢迎交流纠正。</p>
<h1 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h1><p>还记得以前学生时代学习.NET的时候，第一次接触到项目架构叫三层架构。应用层、业务逻辑层及数据访问层。mvc的思想其实也一样，都是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。Android的项目设计本身也是采用了mvc的设计思想。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-e1031a40693a766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115截图20180108120929.png"></p>
<ul>
<li><p>视图层(View)<br>一般采用XML文件进行界面的描述，使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。</p>
</li>
<li><p>控制层(Controller)<br>Android的控制层主要就是Activity层。相关View层交互触发及数据展示逻辑都在Activity中进行编码。</p>
</li>
<li><p>模型层(Model)</p>
</li>
</ul>
<p>我们通常针对业务数据，都会定义好对应的Model层。数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的</p>
<p>所以一直以来我们使用Android默认的项目结构开发，主要都是在采用mvc的架构思想。</p>
<p><strong>优点：</strong> 适用了简单的页面展示，业务逻辑不复杂。开发效果高，代码层级也简单易懂</p>
<p><strong>缺点：</strong> 当业务复杂时，Activity非常臃肿，不便于维护及测试</p>
<h1 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h1><p>mvp这是目前我们项目中主要采用的应用架构方式，MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。mvp架构的演变，解决了Activity代码臃肿的问题，当我们将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。项目开发中，UI是容易变化的，且是多样的，一样的数据会有N种显示方式；业务逻辑也是比较容易变化的。为了使得应用具有较大的弹性，我们期望将UI、逻辑（UI的逻辑和业务逻辑）和数据隔离开来，而MVP是一个很好的选择。在MVP模式里通常包含3个要素（加上View interface是4个）：</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-67a60f1a8c136cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115截图20180108122650.png"></p>
<ul>
<li><p>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity)</p>
</li>
<li><p>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)</p>
</li>
<li><p>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p>
</li>
<li><p>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试</p>
</li>
</ul>
<p><strong>优点：</strong> </p>
<ol>
<li>Model与View完全分离，修改互不影响</li>
<li>更高效地使用，因为所有的逻辑交互都发生在一个地方—Presenter内部</li>
<li>一个Preseter可用于多个View，而不需要改变Presenter的逻辑（因为View的变化总是比Model的变化频繁）。</li>
<li>更便于测试。把逻辑放在Presenter中，就可以脱离用户接口来测试逻辑（单元测试）</li>
</ol>
<p><strong>缺点：</strong> 需要拿捏好Presenter、View interface的颗粒度设计，容易出现Presenter过于简单或则复杂化。</p>
<h1 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h1><p>MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-bc6c2e82fa3bd458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115截图20180108140536.png"></p>
<ul>
<li>View（视图层）采用XML文件进行界面的描述；</li>
<li>Model（模型层）通过网络和本地数据库获取视图层所需数据；</li>
<li>ViewModel（视图-模型层）负责View和Model之间的通信，以此分离视图和数据。</li>
</ul>
<p>View和Model之间通过Android Data Binding技术，实现视图和数据的双向绑定；ViewModel持有Model的引用，通过Model的方法请求数据；获取数据后，通过Callback（回调）的方式回到ViewModel中，由于ViewModel与View的双向绑定，使得界面得以实时更新。同时，界面输入的数据变化时，由于双向绑定技术，ViewModel中的数据得以实时更新，提高了数据采集的效率。</p>
<p>采用ViewModel解决MVP中View(Activity)和Presenter相互持有对方应用的问题，界面由数据进行驱动，响应界面操作无需由View(Activity)传递，数据的变化也无需Presenter调用View(Activity)实现，使得数据传递的过程更加简洁，高效。</p>
<p>推荐教程：<br><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">精通 Android Data Binding</a></p>
<p><strong>优点：</strong> </p>
<ol>
<li>双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好做到数据的一致性</li>
<li>Google官方支持databing，易于集成</li>
</ol>
<p><strong>缺点：</strong>  </p>
<ol>
<li>数据绑定使得 Bug 很难被调试</li>
<li>数据双向绑定不利于代码重用及扩展</li>
<li>代码的阅读性降低</li>
</ol>
<h1 id="android-architecture"><a href="#android-architecture" class="headerlink" title="android-architecture"></a>android-architecture</h1><p>google在官方示例中给出了一系列不同架构的app实现，项目目的是通过展示各种架构app的不同方式来帮助开发者解决架构问题。项目中通过不同的架构概念及方式实现了功能相同的app。</p>
<p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Google官方MVP架构示例项目</a></p>
<h2 id="TODO-MVP-RXJAVA"><a href="#TODO-MVP-RXJAVA" class="headerlink" title="TODO-MVP-RXJAVA"></a>TODO-MVP-RXJAVA</h2><p> <img src="http://upload-images.jianshu.io/upload_images/5125122-7536435fdf155a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115图片20180108151621.png"></p>
<p>使用RXJAVA对数据流进行处理，并且通过Repository进行数据的集中管理，通过协议类XXXContract来对View和Presenter的接口进行内部继承，在presenter的实现类中，可以对Model数据进行操作。实例中，数据的获取、存储、数据状态变化都是model层的任务，presenter会根据需要调用该层的数据处理逻辑并在需要时将回调传入。这样model、presenter、view都只处理各自的任务，实现单一责任原则。</p>
<p>推荐教程：<br><a href="https://www.jianshu.com/p/e469467a903b" target="_blank" rel="external">Google官方MVP+Rxjava项目详解</a></p>
<h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>随着项目的推进，及企业业务的发展。有一天可以发现团队内部需要开发多个APP，且多个APP中存在相同的业务模块，一开始的做法为了赶项目进度可能就是黏贴复制，到后面就慢慢发现越来越吃力，重复劳动。<br>慢慢随着时间的推移，恶性循环。慢慢发现项目代码结构混乱、层次不清，各业务技术方案不统一；甚至连基本的包结构也是胡乱不堪，都是不停地往上堆砌代码添加新功能，前人挖坑后人填。可见组件化对于不断迭代的项目有着深远的意义</p>
<ol>
<li>避免重复造轮子，提高开发效率</li>
<li>减低耦合度，提高复用性</li>
<li>保持团队的技术方案统一性</li>
<li>便于维护升级</li>
</ol>
<h2 id="基础组件化"><a href="#基础组件化" class="headerlink" title="基础组件化"></a>基础组件化</h2><p>通常项目中常用的结构如下：</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-e1501d774a22829a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115截图20180108161144.png"></p>
<p>看似没什么问题，但通常我们的一些库都是以代码的形式集成在代码中，随着项目推进，慢慢发现一些比较严重的问题。</p>
<ol>
<li>业务代码侵入组件代码中 （例如一些全局的网络返回响应，直接在库中编码等）</li>
<li>团队内部没约束，各自集成不同的基础库（例如图片加载有的用Glide，有的用ImageLoader）</li>
<li>部分第三方组件停止更新，项目代码耦合高，替换新方案难</li>
</ol>
<p>所以在实际设施组件化的过程中，建议参考：</p>
<ol>
<li>独立library库（Common基础组件），避免在主工程中直接以代码集成，使用aar方式引用</li>
<li>第三方的库调用最好再装一层接口，以便后续维护升级</li>
<li>有成员专门负责维护，可以以SDK的方式提供业务层的调用</li>
</ol>
<h2 id="业务模块化"><a href="#业务模块化" class="headerlink" title="业务模块化"></a>业务模块化</h2><p>随着项目逻辑不断的增加，慢慢是不是发现代码编译速度是不是越来越慢？（PS：我们目前项目编译一次2分钟，且已是经过一些优化处理）<br>另外当团队内部有多个项目时，是不是经历过产品经理让你把项目A的某个功能移到项目B去，这个时候… …</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-54d6db099ece32f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="115截图20180108163926.png"></p>
<p>业务模块化的作用性就很明显了</p>
<ol>
<li>业务模块间避免耦合，提高复用性</li>
<li>业务模块独立编译运行</li>
</ol>
<p>推荐教程：<br><a href="https://github.com/luojilab/DDComponentForAndroid" target="_blank" rel="external">DDComponentForAndroid</a><br><a href="https://www.jianshu.com/p/1b1d77f58e84" target="_blank" rel="external">Android彻底组件化方案实践</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>项目架构都是不断演进，不是一蹴而就</li>
<li>没有最好的架构，只有在适当的时机，最合适的架构</li>
<li>项目重构过程是艰难的，但长痛不如短痛</li>
</ol>
<h2 id="推荐业内架构演变"><a href="#推荐业内架构演变" class="headerlink" title="推荐业内架构演变"></a>推荐业内架构演变</h2><p><a href="https://zhuanlan.zhihu.com/p/25420181" target="_blank" rel="external">安居客Android项目架构演进</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDUwMzU3Mw==&amp;mid=401044540&amp;idx=1&amp;sn=24b7d8fb655ae6dd5d989d0cb3c08e90&amp;scene=2&amp;srcid=0106EtxRjD2jHxzomxVPTwY3&amp;from=timeline&amp;isappinstalled=0&amp;uin=NzgwODIwNDgw&amp;key=&amp;devicetype=webwx&amp;version=70000001&amp;lang=zh_CN&amp;pass_ticket=46hW44w3Hxd7VY9rutz7mgLu1JGe2T1AAKNQpxNoYOSGi8NpmNYr%2BAZj%2BiXtRX2F" target="_blank" rel="external">饿了么移动APP的架构演进</a></p>
<p><a href="http://www.infoq.com/cn/articles/wechat-android-app-architecture" target="_blank" rel="external">微信Android客户端架构演进之路</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/wytiger/p/5305087.html" target="_blank" rel="external">Android App的设计架构：MVC,MVP,MVVM与架构经验谈</a></p>
<p><a href="http://blog.csdn.net/dd864140130/article/details/53645290" target="_blank" rel="external">Android 开发:由模块化到组件化(一)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/12/29/回顾2017，展望2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/29/回顾2017，展望2018/" itemprop="url">
                  回顾2017，展望2018
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T18:14:48+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/29/回顾2017，展望2018/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/29/回顾2017，展望2018/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="回顾2017"><a href="#回顾2017" class="headerlink" title="回顾2017"></a>回顾2017</h1><p>又到了年末了，希望通过总结来回顾2017。回首这一年，感觉还是有在进步。除了当爸爸了，工作上思维逻辑也有了进一步的提升。也坚持一直在学习及不断的思考。下面通过学习、工作、生活、还有感悟来回顾即将过去的2017。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-bfc360763d227104?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>学生时代，英语就是个渣渣。不过今年还是坚持下来学习了。每天刷单词，还有新闻，练练听力。一个感觉就是以前读书为了考试学英语真是累，现在当是一种技能来学习，反到是乐此不疲。参加了扇贝的2017新年计划，即将完成。这里推荐一下扇贝英语，一直在用很不错。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-c1bdc9aa8ea47a5d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>2017年开始在简书上更新博客及github同步更新。初衷希望能把自己学到的东西总结起来。慢慢发现养成写博客的习惯也可以锻炼自己的写作能力、语言组织能力，还是不错。<br>在简书上一共更新了23篇博客，收获439粉丝、477赞。其中也有不少被收录，通过写博客也认识了不少同行，收获颇丰。</p>
<ul>
<li><a href="https://www.jianshu.com/u/466f8b75f81c" target="_blank" rel="external">简书博客，https://www.jianshu.com/u/466f8b75f81c</a></li>
<li><a href="http://junbin.tech/" target="_blank" rel="external">github，http://junbin.tech/</a></li>
</ul>
<p>希望新的一年能够继续坚持学习，输出更高质量的博客。</p>
<h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><p>出来工作后，很少看书了。但今年还是坚持看了一部分的书。养成阅读的习惯还是很重要，书中都是前人总结的经验，多看书可以少走好多弯路。下面列出部分今年看的，觉得不错的书籍。</p>
<p>《Java并发编程的艺术》、《设计模式之禅（第2版）》、《软技能：代码之外的生存指南》、《深入理解Java虚拟机JVM高级特性与最佳实践》、《浪潮之巅》、《从技术走向管理:李元芳履职记》、动脑学院 Android高级视频教程</p>
<p>今年看的书还是比较少，阅读的习惯也还没有很好的养成。希望接下来能更充分利用时间，多读一些书。</p>
<p>推荐一个不错的电子书网站，技术类的也非常多，支持可以推送到kindle</p>
<p><a href="http://readfree.me/" target="_blank" rel="external">http://readfree.me/</a></p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h3 id="思维逻辑的转变"><a href="#思维逻辑的转变" class="headerlink" title="思维逻辑的转变"></a>思维逻辑的转变</h3><p>今年一个比较大的变化就是除了项目的研发工作，还承担了部分项目的管理工作。一个主要的思维变化就是被动转化为主动。需要主动思考如何更好推动项目开展、如何提高应用的性能、如何提升整体的效率。提高了自己的工作规划能力及沟通能力。</p>
<h3 id="自我要求"><a href="#自我要求" class="headerlink" title="自我要求"></a>自我要求</h3><p>其实相信相当一部分程序员，都是有自我的要求。更高的效率、更稳定的质量、更好的技术方案。不仅为一份薪水而工作，而更是为实现更大的价值而工作。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="重回校园"><a href="#重回校园" class="headerlink" title="重回校园"></a>重回校园</h3><p>一个偶然的机会，经朋友介绍到一个职业学校当Android的讲师。由于公司项目也非常紧，周六经常要加班。所以定了每周日去讲课。哈哈。过了一段时间无休息日。虽然比较累，但是还是蛮有收获的。</p>
<ol>
<li>时间规划能力</li>
</ol>
<p>大概有4个月时间，无休息日。除了工作还需要抽出时间备课、讲课。时间只能挤出来，充分利用边角时间。现在我都不太喜欢开车上班，要花1个小时。更喜欢坐公交车，在车上的时间还可以利用起来思考、做一些事情。另外当然就是要压缩掉自己休息娱乐的时间，并且需要尽量提高大部分事情的处理效率，进行取舍。</p>
<ol>
<li>沟通演讲能力</li>
</ol>
<p>程序员，经常给人一种呆板、沉闷的感觉。但实际的项目开发中，沟通是不可避免的能力。其实你可能懂得很多，但是要和一群没有任何经验的学生，讲清楚Activity是什么却不简单。另外每天上8节课，需要在台上进行演讲，这也需要有对舞台的把控能力。其实我骨子里还是蛮喜欢舞台，以前读书的时候都去做主持人。借这次机会也找回了些许以前的回忆。</p>
<h3 id="身份变化"><a href="#身份变化" class="headerlink" title="身份变化"></a>身份变化</h3><p>今年最高兴的事情就是当爸爸了，非常感谢老婆的努力，生了一个男宝宝。宝宝刚满月，现在每天下班回去带小孩。虽然有时候工作一天回去很累，小孩晚上还闹，但心底还是一直觉得很幸福。等他长大了，我要培养他成为一个产品经理，拒做程序猿，哈。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><h2 id="决定做一件事情很容易，但坚持做一件事情不易"><a href="#决定做一件事情很容易，但坚持做一件事情不易" class="headerlink" title="决定做一件事情很容易，但坚持做一件事情不易"></a>决定做一件事情很容易，但坚持做一件事情不易</h2><p>大部分牛逼的人，都不是IQ多多少，反而是比常人付出更多的努力。在技术上，长年累月的坚持与积累，一个又一个的项目中成长起来的。其实IT这一行日新月异，30岁了，你可能面临娶妻生子、面临房贷车贷；30岁了，你需要面临竞争、面临选择，面临日新月异的技术。之前去学校上课的学生现在都是96后了，你是否也感觉老了呢？其实我自己经常都过得很有危机感，也一直在思考以后的职业规划。也许当你感到迷茫的时候，是一件好事。证明自己也是有危机感，而不是浑浑噩噩。意识到危机，才能有更好的动力去规划及调整。每天保持好的学习状态，可以让自己更加充实。相信坚持一定会有所收获。</p>
<p><a href="https://www.jianshu.com/p/4ef38bc54d17" target="_blank" rel="external">程序员，30而立。你是否觉得迷茫？</a></p>
<h2 id="幸福也许可以很简单"><a href="#幸福也许可以很简单" class="headerlink" title="幸福也许可以很简单"></a>幸福也许可以很简单</h2><p>其实好多人都说工作目标就是买房、买车、娶妻生子，但却很少思考怎么样的生活方式能让你有幸福感。其实工作前几年，我也是一直为了这些目标在奋斗，但是当你拥有了以后却发现很多东西其实都不是那么重要。对于我来说，现在每天回去带带宝宝，和家人一起吃个饭，我就觉得是一件蛮幸福的事情了。又可以从事自己喜欢的工作，又可以陪伴到家人，这就是简单的幸福。</p>
<h1 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h1><ol>
<li>坚持学习及写博客，拓展技能树，学以致用</li>
<li>多看书，培养阅读习惯</li>
<li>提高效率、时间规划、逻辑思维能力</li>
<li>陪伴家人</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/12/14/玩转Android状态栏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/玩转Android状态栏/" itemprop="url">
                  玩转Android状态栏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T08:45:35+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/14/玩转Android状态栏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/14/玩转Android状态栏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，突然收到一个状态栏颜色优化设计的任务，将原本应用整体的黑色状态栏修改为根据标题栏颜色进行沉浸式设计，显示效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-3c19e25bec23ae1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>经过分析及踩过N多坑，终于完成了APP全局的修改。现将一些需要注意的问题及踩过的坑进行梳理总结，主要从系统版本区别、各大厂商的ROM区别及具体的设置进行分析，期间也参考了很多资料，会在文末附上对应的链接</p>
<h2 id="Android各版本状态栏区别"><a href="#Android各版本状态栏区别" class="headerlink" title="Android各版本状态栏区别"></a>Android各版本状态栏区别</h2><p>首先我们需要注意，Android不是各个版本都支持设置状态栏的颜色，只有在5.0以上才支持。另外6.0以上才支持设置状态栏黑色图标（避免白色状态栏及白色图标导致看不清电量 时间等问题）</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-682a47055173face?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th>是否支持设置状态栏颜色</th>
<th>是否允许设置状态栏黑色图标</th>
</tr>
</thead>
<tbody>
<tr>
<td>4.4</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>5.0</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>6.0+</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="各个ROM状态栏区别"><a href="#各个ROM状态栏区别" class="headerlink" title="各个ROM状态栏区别"></a>各个ROM状态栏区别</h2><h3 id="是不是设置了状态栏透明就真透明了？"><a href="#是不是设置了状态栏透明就真透明了？" class="headerlink" title="是不是设置了状态栏透明就真透明了？"></a>是不是设置了状态栏透明就真透明了？</h3><p>这个问题一开始也困扰了我，后面分析，在原生的系统虽然设置了状态栏透明，但是状态栏区域也会有一层半透明的遮罩（估计就是考虑到白色状态栏引起的问题），但是测试发现部分国产ROM设置穿透栏透明则会完全透明（例如MIUI）</p>
<p>原生系统效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-296dc3db09ecc9c0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>MIUI系统效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-4f4ac539c4d45a49?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="是不是6-0都支持系统状态栏黑条图标？"><a href="#是不是6-0都支持系统状态栏黑条图标？" class="headerlink" title="是不是6.0都支持系统状态栏黑条图标？"></a>是不是6.0都支持系统状态栏黑条图标？</h3><p>原生6.0以上有API支持，但是国产各ROM经过定制，有的需要特定的设置才能实现</p>
<p>原生系统设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void setLightStatusBar(Window window, boolean lightStatusBar) &#123;</div><div class="line">          // 设置浅色状态栏时的界面显示</div><div class="line">          View decor = window.getDecorView();</div><div class="line">          int ui = decor.getSystemUiVisibility();</div><div class="line">          if (lightStatusBar) &#123;</div><div class="line">              ui |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;</div><div class="line">          &#125; else &#123;</div><div class="line">              ui &amp;= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;</div><div class="line">          &#125;</div><div class="line">          decor.setSystemUiVisibility(ui);</div><div class="line"></div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>小米：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static boolean MIUISetStatusBarLightMode(Window window, boolean dark) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        if (window != null) &#123;</div><div class="line">            Class clazz = window.getClass();</div><div class="line">            try &#123;</div><div class="line">                int darkModeFlag = 0;</div><div class="line">                Class layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);</div><div class="line">                Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);</div><div class="line">                darkModeFlag = field.getInt(layoutParams);</div><div class="line">                Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);</div><div class="line">                if (dark) &#123;</div><div class="line">                    extraFlagField.invoke(window, darkModeFlag, darkModeFlag);//状态栏透明且黑色字体</div><div class="line">                &#125; else &#123;</div><div class="line">                    extraFlagField.invoke(window, 0, darkModeFlag);//清除黑色字体</div><div class="line">                &#125;</div><div class="line">                result = true;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>魅族：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static boolean FlymeSetStatusBarLightMode(Window window, boolean dark) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        if (window != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                WindowManager.LayoutParams lp = window.getAttributes();</div><div class="line">                Field darkFlag = WindowManager.LayoutParams.class</div><div class="line">                        .getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;);</div><div class="line">                Field meizuFlags = WindowManager.LayoutParams.class</div><div class="line">                        .getDeclaredField(&quot;meizuFlags&quot;);</div><div class="line">                darkFlag.setAccessible(true);</div><div class="line">                meizuFlags.setAccessible(true);</div><div class="line">                int bit = darkFlag.getInt(null);</div><div class="line">                int value = meizuFlags.getInt(lp);</div><div class="line">                if (dark) &#123;</div><div class="line">                    value |= bit;</div><div class="line">                &#125; else &#123;</div><div class="line">                    value &amp;= ~bit;</div><div class="line">                &#125;</div><div class="line">                meizuFlags.setInt(lp, value);</div><div class="line">                window.setAttributes(lp);</div><div class="line">                result = true;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>华为手机：<br>部分测试发现华为的EMUI手机状态栏会跟系统桌面的状态栏一样，设置了没用，这里如果要特殊设置状态栏颜色，只能参考4.4的处理方式（后续介绍）</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-c559fc450208c6d0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="如何进行定制状态栏"><a href="#如何进行定制状态栏" class="headerlink" title="如何进行定制状态栏"></a>如何进行定制状态栏</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ul>
<li>4.4</li>
</ul>
<p>通过上述的版本及分析，可见完善的的状态栏兼容是一个大工程，需要综合考虑系统版本及各个厂商ROM等因素。5.0以上有系统API进行支持，这里我们主要来分析一些4.4的实现原理。<br>简单来说，4.4的实现方式就是使用透明的状态栏，然后做一个和状态栏一样高度的View，加入到Windows的DecorView，然后给这个View设置背景色，达到实现状态栏颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div><div class="line"></div><div class="line">       ViewGroup decorViewGroup = (ViewGroup) window.getDecorView();</div><div class="line">       View statusBarView = decorViewGroup.findViewWithTag(STATUS_BAR_VIEW_TAG);</div><div class="line">       if (statusBarView == null) &#123;</div><div class="line">           statusBarView = new StatusBarView(window.getContext());</div><div class="line">           statusBarView.setTag(STATUS_BAR_VIEW_TAG);</div><div class="line">           FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(</div><div class="line">                   FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);</div><div class="line">           params.gravity = Gravity.TOP;</div><div class="line">           statusBarView.setLayoutParams(params);</div><div class="line">           decorViewGroup.addView(statusBarView);</div><div class="line">       &#125;</div><div class="line">       statusBarView.setBackgroundColor(color);</div><div class="line">       StatusBarCompat.internalSetFitsSystemWindows(window, true);</div></pre></td></tr></table></figure></p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-7dadf90e78c14b97?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>5.0</li>
</ul>
<p>注意5.0一般不用使用白色的状态栏（因为不能设置状态栏灰色图标），可在资源文件定义一个rgb，区分版本，5.0使用白灰色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</div><div class="line">@Override</div><div class="line">public void setStatusBarColor(Window window, int color) &#123;</div><div class="line">    //取消设置透明状态栏,使 ContentView 内容不再覆盖状态栏</div><div class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div><div class="line">    //需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色</div><div class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</div><div class="line">    //设置状态栏颜色</div><div class="line">    window.setStatusBarColor(color);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-1f899b0ae03f1576?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li><p>6.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.M)</div><div class="line">  @Override</div><div class="line">  public void setStatusBarColor(Window window, int color) &#123;</div><div class="line">      //取消设置透明状态栏,使 ContentView 内容不再覆盖状态栏</div><div class="line">      window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div><div class="line">      //需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色</div><div class="line">      window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</div><div class="line">      //设置状态栏颜色</div><div class="line">      window.setStatusBarColor(color);</div><div class="line"></div><div class="line">      // 去掉系统状态栏下的windowContentOverlay</div><div class="line">      View v = window.findViewById(android.R.id.content);</div><div class="line">      if (v != null) &#123;</div><div class="line">          v.setForeground(null);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-cc8e3645cceebf35?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
</ul>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>这里不重复造轮子，先提供一下github上比较完善的处理方案</p>
<p><a href="https://github.com/msdx/status-bar-compat" target="_blank" rel="external">status-bar-compat</a></p>
<p>StatusBarCompat是一个用于设置系统状态栏颜色的兼容库，兼容Android 4.4.2(API 19)以上，使用简单，仅需要一行代码的调用。</p>
<p><a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="external">SystemBarTint</a></p>
<p>支持4.4以上的，主要使用透明状态栏的方式实现</p>
<p>推荐使用status-bar-compat，已考虑到整体的版本兼容机及各厂ROM，调用简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在Activity的setContentView()方法调用之后，调用以下方法即可。</div><div class="line"></div><div class="line">    StatusBarCompat.setStatusBarColor(this, color, lightStatusBar);</div><div class="line">或者是</div><div class="line"></div><div class="line">    StatusBarCompat.setStatusBarColor(this, color);</div></pre></td></tr></table></figure>
<p>本文主要源码使用status-bar-compat中的代码进行说明</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="关于全屏及非全屏界面切换导致页面移动问题"><a href="#关于全屏及非全屏界面切换导致页面移动问题" class="headerlink" title="关于全屏及非全屏界面切换导致页面移动问题"></a>关于全屏及非全屏界面切换导致页面移动问题</h3><p>例如在应用中有全屏的看图页面，点击返回为非全屏（带状态栏）页面，非全屏页面由于现实状态，会出现页面抖动。目前暂无完善的处理方案，项目中暂时使用的方式是延迟全屏页面的finish，先显示状态栏后再关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">复写onBackPressed</div><div class="line"></div><div class="line"> getActivity().getWindow().clearFlags(</div><div class="line">                WindowManager.LayoutParams.FLAG_FULLSCREEN);</div><div class="line">        if(getView()!=null)&#123;</div><div class="line">            getView().postDelayed(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    getActivity().finish();</div><div class="line">                &#125;</div><div class="line">            &#125;,10);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="状态栏一片白色"><a href="#状态栏一片白色" class="headerlink" title="状态栏一片白色"></a>状态栏一片白色</h3><p>上面已有分析，要注意如果状态栏为白色，需要设置状态栏的图标颜色。status-bar-compat中会把颜色转换成灰度值，然后自己控制状态栏图标颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void setStatusBarColor(Activity activity, @ColorInt int color) &#123;</div><div class="line">      boolean isLightColor = toGrey(color) &gt; 225;</div><div class="line">      setStatusBarColor(activity, color, isLightColor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 把颜色转换成灰度值。</div><div class="line">   * 代码来自 Flyme 示例代码</div><div class="line">   */</div><div class="line">  public static int toGrey(@ColorInt int color) &#123;</div><div class="line">      int blue = Color.blue(color);</div><div class="line">      int green = Color.green(color);</div><div class="line">      int red = Color.red(color);</div><div class="line">      return (red * 38 + green * 75 + blue * 15) &gt;&gt; 7;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="部分第三方组件的弹层和白色状态栏显得比较突兀"><a href="#部分第三方组件的弹层和白色状态栏显得比较突兀" class="headerlink" title="部分第三方组件的弹层和白色状态栏显得比较突兀"></a>部分第三方组件的弹层和白色状态栏显得比较突兀</h3><p> <img src="http://upload-images.jianshu.io/upload_images/5125122-fdf0bb4eeef724b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这个目前也尚无方法，考虑可以在弹层出现时，动态修改状态的颜色，但是工作量比较大，可先适当调整弹层的rgb，减低透明度</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/p/a9f2174b7714" target="_blank" rel="external">Android 6.0 以上实现状态栏白底黑字</a></p>
<p><a href="https://github.com/msdx/status-bar-compat" target="_blank" rel="external">status-bar-compat</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/Java并发编程-锁及并发容器/" itemprop="url">
                  Java并发编程-锁及并发容器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T18:52:01+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/Java并发编程-锁及并发容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/10/Java并发编程-锁及并发容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<h2 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-77d650be264e60e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。ReentrantLock是java.unti.concurrent包下的一个类，它的一般使用结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void lockMethod() &#123;  </div><div class="line">    ReentrantLock myLock = new ReentrantLock();  </div><div class="line">    myLock.lock();  </div><div class="line">    try&#123;  </div><div class="line">        // 受保护的代码段  </div><div class="line">        //critical section  </div><div class="line">    &#125; finally &#123;  </div><div class="line">        // 可以保证发生异常 锁可以得到释放 避免死锁的发生  </div><div class="line">        myLock.unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock与synchronized的比较"><a href="#ReentrantLock与synchronized的比较" class="headerlink" title="ReentrantLock与synchronized的比较"></a>ReentrantLock与synchronized的比较</h3><ul>
<li>相同：ReentrantLock提供了synchronized类似的功能和内存语义。</li>
<li>不同：</li>
</ul>
<ol>
<li>ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</li>
<li>ReentrantLock 的性能比synchronized会好点。</li>
<li>ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。</li>
</ol>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>  在Java的ReentrantLock构造函数中提供了两种锁：创建公平锁和非公平锁（默认）。代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  public ReentrantLock() &#123;</div><div class="line"></div><div class="line">       sync = new NonfairSync();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> public ReentrantLock(boolean fair) &#123;</div><div class="line">          sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。</p>
<p>非公平锁性能高于公平锁性能的原因：<br>在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。</p>
<h2 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h2><p>之前提到锁基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写<br>的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-d28778b6ec512021?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Cache &#123;</div><div class="line">static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">static Lock r = rwl.readLock();</div><div class="line">static Lock w = rwl.writeLock();</div><div class="line">// 获取一个key对应的value</div><div class="line">public static final Object get(String key) &#123;</div><div class="line">r.lock();</div><div class="line">try &#123;</div><div class="line">return map.get(key);</div><div class="line">&#125; finally &#123;</div><div class="line">r.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 设置key对应的value，并返回旧的value</div><div class="line">public static final Object put(String key, Object value) &#123;</div><div class="line">w.lock();</div><div class="line">try &#123;</div><div class="line">return map.put(key, value);</div><div class="line">&#125; finally &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 清空所有的内容</div><div class="line">public static final void clear() &#123;</div><div class="line">w.lock();</div><div class="line">try &#123;</div><div class="line">map.clear();</div><div class="line">&#125; finally &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的<br>读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使<br>得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新<br>HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而<br>只有写锁被释放之后，其他读写操作才能继续。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。</p>
<p>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p>
<ul>
<li>Conditon中的await()对应Object的wait()</li>
<li>Condition中的signal()对应Object的notify()</li>
<li>Condition中的signalAll()对应Object的notifyAll()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class ConTest &#123;  </div><div class="line">      </div><div class="line">     final Lock lock = new ReentrantLock();  </div><div class="line">     final Condition condition = lock.newCondition();  </div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        // TODO Auto-generated method stub  </div><div class="line">        ConTest test = new ConTest();  </div><div class="line">        Producer producer = test.new Producer();  </div><div class="line">        Consumer consumer = test.new Consumer();  </div><div class="line">                </div><div class="line">          </div><div class="line">        consumer.start();   </div><div class="line">        producer.start();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">     class Consumer extends Thread&#123;  </div><div class="line">           </div><div class="line">            @Override  </div><div class="line">            public void run() &#123;  </div><div class="line">                consume();  </div><div class="line">            &#125;  </div><div class="line">                </div><div class="line">            private void consume() &#123;  </div><div class="line">                               </div><div class="line">                    try &#123;  </div><div class="line">                           lock.lock();  </div><div class="line">                        System.out.println(&quot;我在等一个新信号&quot;+this.currentThread().getName());  </div><div class="line">                        condition.await();  </div><div class="line">                          </div><div class="line">                    &#125; catch (InterruptedException e) &#123;  </div><div class="line">                        // TODO Auto-generated catch block  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125; finally&#123;  </div><div class="line">                        System.out.println(&quot;拿到一个信号&quot;+this.currentThread().getName());  </div><div class="line">                        lock.unlock();  </div><div class="line">                    &#125;  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">       </div><div class="line">     class Producer extends Thread&#123;  </div><div class="line">           </div><div class="line">            @Override  </div><div class="line">            public void run() &#123;  </div><div class="line">                produce();  </div><div class="line">            &#125;  </div><div class="line">                </div><div class="line">            private void produce() &#123;                   </div><div class="line">                    try &#123;  </div><div class="line">                           lock.lock();  </div><div class="line">                           System.out.println(&quot;我拿到锁&quot;+this.currentThread().getName());  </div><div class="line">                            condition.signalAll();                             </div><div class="line">                        System.out.println(&quot;我发出了一个信号：&quot;+this.currentThread().getName());  </div><div class="line">                    &#125; finally&#123;  </div><div class="line">                        lock.unlock();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">     &#125;  </div><div class="line">          </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">我在等一个新信号Thread-1</div><div class="line">我拿到锁Thread-0</div><div class="line">我发出了一个信号：Thread-0</div><div class="line">拿到一个信号Thread-1</div></pre></td></tr></table></figure></p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public boolean add(T e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();</div><div class="line">    try &#123;</div><div class="line"></div><div class="line">        Object[] elements = getArray();</div><div class="line"></div><div class="line">        int len = elements.length;</div><div class="line">        // 复制出新数组</div><div class="line"></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class="line">        // 把新元素添加到新数组里</div><div class="line"></div><div class="line">        newElements[len] = e;</div><div class="line">        // 把原数组引用指向新数组</div><div class="line"></div><div class="line">        setArray(newElements);</div><div class="line"></div><div class="line">        return true;</div><div class="line"></div><div class="line">    &#125; finally &#123;</div><div class="line"></div><div class="line">        lock.unlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">final void setArray(Object[] a) &#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">    return get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>ConcurrentHashMap是线程安全且高效的HashMap。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ac27c7bad8a42712?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><ul>
<li>线程不安全的HashMap</li>
</ul>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap</p>
<ul>
<li>效率低下的HashTable</li>
</ul>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低</p>
<ul>
<li>ConcurrentHashMap的锁分段技术可有效提升并发访问率</li>
</ul>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</p>
<h3 id="hash定位"><a href="#hash定位" class="headerlink" title="hash定位"></a>hash定位</h3><p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的hash算法</div><div class="line">int index = hash &amp; (tab.length - 1);　　// 定位HashEntry所使用的hash算法</div></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散<br>列运算定位到Segment，再通过散列算法定位到元素，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int hash = hash(key.hashCode());</div><div class="line">return segmentFor(hash).get(key, hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。我们<br>知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">       Segment&lt;K,V&gt; s;</div><div class="line">       if (value == null)</div><div class="line">           throw new NullPointerException();</div><div class="line">       int hash = hash(key);</div><div class="line">       int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">       if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</div><div class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</div><div class="line">           s = ensureSegment(j);</div><div class="line">       return s.put(key, hash, value, false);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Segment的put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">         HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">             scanAndLockForPut(key, hash, value);</div><div class="line">         V oldValue;</div><div class="line">         try &#123;</div><div class="line">             HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">             int index = (tab.length - 1) &amp; hash;</div><div class="line">             HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">             for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                 if (e != null) &#123;</div><div class="line">                     K k;</div><div class="line">                     if ((k = e.key) == key ||</div><div class="line">                         (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                         oldValue = e.value;</div><div class="line">                         if (!onlyIfAbsent) &#123;</div><div class="line">                             e.value = value;</div><div class="line">                             ++modCount;</div><div class="line">                         &#125;</div><div class="line">                         break;</div><div class="line">                     &#125;</div><div class="line">                     e = e.next;</div><div class="line">                 &#125;</div><div class="line">                 else &#123;</div><div class="line">                     if (node != null)</div><div class="line">                         node.setNext(first);</div><div class="line">                     else</div><div class="line">                         node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                     int c = count + 1;</div><div class="line">                     if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                         rehash(node);</div><div class="line">                     else</div><div class="line">                         setEntryAt(tab, index, node);</div><div class="line">                     ++modCount;</div><div class="line">                     count = c;</div><div class="line">                     oldValue = null;</div><div class="line">                     break;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125; finally &#123;</div><div class="line">             unlock();</div><div class="line">         &#125;</div><div class="line">         return oldValue;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不<br>满。</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器</li>
</ol>
<p>插入和移除操作的4中处理方式</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td> 移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(e,time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移<br>除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者<br>线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队<br>列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程<br>一段时间，如果超过了指定的时间，生产者线程就会退出</li>
</ul>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下。</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
</ul>
<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列 </p>
<ul>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
</ul>
<p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>
<ul>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
</ul>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序 </p>
<ul>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
</ul>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素</p>
<ul>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
<p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素</p>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
</ul>
<p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<ul>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/zmx729618/article/details/51593666" target="_blank" rel="external">ReentrantLock之公平锁与非公平锁浅析</a></p>
<p><a href="http://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="external"> java condition使用及分析</a></p>
<p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">聊聊并发-Java中的Copy-On-Write容器</a></p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="external">Java集合—ConcurrentHashMap原理分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/10/09/Java并发编程-原子类及并发工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/09/Java并发编程-原子类及并发工具类/" itemprop="url">
                  Java并发编程-原子类及并发工具类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T14:22:41+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/09/Java并发编程-原子类及并发工具类/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/09/Java并发编程-原子类及并发工具类/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中<br>的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<br>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更<br>新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。<br>Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p>java.util.concurrent.atomic中的类可以分成4组：</p>
<ul>
<li>标量类（Scalar）：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>
<li>数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>
<li>更新器类：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li>
<li>复合变量类：AtomicMarkableReference，AtomicStampedReference</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS（Compare-And-Swap）算法保证数据操作的原子性。</p>
<p>CAS 算法是硬件对于并发操作共享数据的支持。</p>
<p>CAS 包含了三个操作数：<br>　　内存值 V<br>　　预估值 A<br>　　更新值 B</p>
<p>当且仅当 V == A 时，V 将被赋值为 B，否则循环着不断进行判断 V 与 A 是否相等。</p>
<p>CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。<br>atomic包的原子包下使用这种方案。例如AtomicInteger的getAndIncrement自增+1的方法，经查看源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final int getAndIncrement() &#123;</div><div class="line">for (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line">if (compareAndSet(current, next))</div><div class="line">return current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作</p>
<p>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare-AndSwapInt和compareAndSwapLong，具体实现都是使用了native方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 如果当前数值是expected，则原子的将Java变量更新成x</div><div class="line">* @return 如果更新成功则返回true</div><div class="line">*/</div><div class="line">public final native boolean compareAndSwapObject(Object o,</div><div class="line">long offset,</div><div class="line">Object expected,</div><div class="line">Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">int expected,</div><div class="line">int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,</div><div class="line">long expected,</div><div class="line">long x);</div></pre></td></tr></table></figure>
<h2 id="标量类"><a href="#标量类" class="headerlink" title="标量类"></a>标量类</h2><ul>
<li>AtomicBoolean：原子更新布尔变量</li>
<li>AtomicInteger：原子更新整型变量</li>
<li>AtomicLong：原子更新长整型变量</li>
<li>AtomicReference：原子更新引用类型</li>
</ul>
<p>具体到每个类的源代码中，提供的方法基本相同，这里以AtomicInteger为例进行说明<br>AtomicInteger源码主要的方法如下，原理主要都要都是采用了CAS，这里不再累述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</div><div class="line">   </div><div class="line">    public AtomicInteger(int initialValue) &#123;</div><div class="line">        value = initialValue;</div><div class="line">    &#125;</div><div class="line"> //返回当前的值</div><div class="line">    public final int get() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    //最终会设置成新值</div><div class="line">    public final void set(int newValue) &#123;</div><div class="line">        value = newValue;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public final void lazySet(int newValue) &#123;</div><div class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</div><div class="line">    &#125;</div><div class="line">      //原子更新为新值并返回旧值</div><div class="line">    public final int getAndSet(int newValue) &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            int current = get();</div><div class="line">            if (compareAndSet(current, newValue))</div><div class="line">                return current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     //如果输入的值等于预期值，则以原子方式更新为新值</div><div class="line">    public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> //原子自增</div><div class="line">    public final int getAndIncrement() &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            int current = get();</div><div class="line">            int next = current + 1;</div><div class="line">            if (compareAndSet(current, next))</div><div class="line">                return current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//原子方式将当前值与输入值相加并返回结果</div><div class="line">    public final int getAndAdd(int delta) &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            int current = get();</div><div class="line">            int next = current + delta;</div><div class="line">            if (compareAndSet(current, next))</div><div class="line">                return current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><ul>
<li>AtomicIntegerArray：原子更新整型数组的某个元素</li>
<li>AtomicLongArray：原子更新长整型数组的某个元素</li>
<li>AtomicReferenceArray：原子更新引用类型数组的某个元素</li>
</ul>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。</p>
<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</li>
</ul>
<p>以上几个类提供的方法几乎一样，所以这里以AtomicIntegerArray为例进行讲解 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 2862133569453604235L;</div><div class="line"></div><div class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">    private static final int base = unsafe.arrayBaseOffset(int[].class);</div><div class="line">    private static final int shift;</div><div class="line">    private final int[] array;</div><div class="line"> </div><div class="line"></div><div class="line">    private long checkedByteOffset(int i) &#123;</div><div class="line">        if (i &lt; 0 || i &gt;= array.length)</div><div class="line">            throw new IndexOutOfBoundsException(&quot;index &quot; + i);</div><div class="line"></div><div class="line">        return byteOffset(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static long byteOffset(int i) &#123;</div><div class="line">        return ((long) i &lt;&lt; shift) + base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     </div><div class="line">    public AtomicIntegerArray(int length) &#123;</div><div class="line">        array = new int[length];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   </div><div class="line">    public final int get(int i) &#123;</div><div class="line">        return getRaw(checkedByteOffset(i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getRaw(long offset) &#123;</div><div class="line">        return unsafe.getIntVolatile(array, offset);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    public final void set(int i, int newValue) &#123;</div><div class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   </div><div class="line">    public final void lazySet(int i, int newValue) &#123;</div><div class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    public final int getAndSet(int i, int newValue) &#123;</div><div class="line">        long offset = checkedByteOffset(i);</div><div class="line">        while (true) &#123;</div><div class="line">            int current = getRaw(offset);</div><div class="line">            if (compareAndSetRaw(offset, current, newValue))</div><div class="line">                return current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public final boolean compareAndSet(int i, int expect, int update) &#123;</div><div class="line">        return compareAndSetRaw(checkedByteOffset(i), expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean compareAndSetRaw(long offset, int expect, int update) &#123;</div><div class="line">        return unsafe.compareAndSwapInt(array, offset, expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里关键的实现也还是使用了CAS的策略，具体通过unsafe的native方法进行实现</p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p> 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供<br>了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起<br>来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的<br>ABA问题。<br>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的<br>时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第<br>二步，更新类的字段（属性）必须使用public volatile修饰符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class AtomicIntegerFieldUpdaterTest &#123;</div><div class="line">// 创建原子更新器，并设置需要更新的对象类和对象的属性</div><div class="line">private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</div><div class="line">newUpdater(User.class， &quot;old&quot;);</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">// 设置柯南的年龄是10岁</div><div class="line">User conan = new User(&quot;conan&quot;， 10);</div><div class="line">// 柯南长了一岁，但是仍然会输出旧的年龄</div><div class="line">System.out.println(a.getAndIncrement(conan));</div><div class="line">// 输出柯南现在的年龄</div><div class="line">System.out.println(a.get(conan));</div><div class="line">&#125;</div><div class="line">public static class User &#123;</div><div class="line">private String name;</div><div class="line">public volatile int old;</div><div class="line">public User(String name， int old) &#123;</div><div class="line">this.name = name;</div><div class="line">this.old = old;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">return name;</div><div class="line">&#125;</div><div class="line">public int getOld() &#123;</div><div class="line">return old;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码执行后输出如下。</p>
<p>10</p>
<p>11</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch类是一个同步计数器,构造时默认接收一个初始值，每调用一次countDown()方法，计数器减1。计数器&gt;0时，await()方法会阻塞;当计数器=0时会得到await()会立即得到响应<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">     public static void main(String[] args) &#123;   </div><div class="line">         final CountDownLatch latch = new CountDownLatch(2);</div><div class="line">          </div><div class="line">         new Thread()&#123;</div><div class="line">             public void run() &#123;</div><div class="line">                 try &#123;</div><div class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</div><div class="line">                    Thread.sleep(3000);</div><div class="line">                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</div><div class="line">                    latch.countDown();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">             &#125;;</div><div class="line">         &#125;.start();</div><div class="line">          </div><div class="line">         new Thread()&#123;</div><div class="line">             public void run() &#123;</div><div class="line">                 try &#123;</div><div class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</div><div class="line">                     Thread.sleep(3000);</div><div class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</div><div class="line">                     latch.countDown();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">             &#125;;</div><div class="line">         &#125;.start();</div><div class="line">          </div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;等待2个子线程执行完毕...&quot;);</div><div class="line">            latch.await();</div><div class="line">            System.out.println(&quot;2个子线程已经执行完毕&quot;);</div><div class="line">            System.out.println(&quot;继续执行主线程&quot;);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">线程Thread-0正在执行</div><div class="line">线程Thread-1正在执行</div><div class="line">等待2个子线程执行完毕...</div><div class="line">线程Thread-0执行完毕</div><div class="line">线程Thread-1执行完毕</div><div class="line">2个子线程已经执行完毕</div><div class="line">继续执行主线程</div></pre></td></tr></table></figure></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会<br>开门，所有被屏障拦截的线程才会继续运行。当所有等待线程都被释放以后，CyclicBarrier可以被重用。CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public CyclicBarrier(int parties) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int N = 4;</div><div class="line">        CyclicBarrier barrier  = new CyclicBarrier(N);</div><div class="line">        for(int i=0;i&lt;N;i++)</div><div class="line">            new Writer(barrier).start();</div><div class="line">    &#125;</div><div class="line">    static class Writer extends Thread&#123;</div><div class="line">        private CyclicBarrier cyclicBarrier;</div><div class="line">        public Writer(CyclicBarrier cyclicBarrier) &#123;</div><div class="line">            this.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(5000);      //以睡眠来模拟写入数据操作</div><div class="line">                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</div><div class="line">                cyclicBarrier.await();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;catch(BrokenBarrierException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　执行结果：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　线程Thread-0正在写入数据...</div><div class="line">线程Thread-3正在写入数据...</div><div class="line">线程Thread-2正在写入数据...</div><div class="line">线程Thread-1正在写入数据...</div><div class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</div><div class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</div><div class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</div><div class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</div><div class="line">所有线程写入完毕，继续处理其他任务...</div><div class="line">所有线程写入完毕，继续处理其他任务...</div><div class="line">所有线程写入完毕，继续处理其他任务...</div><div class="line">所有线程写入完毕，继续处理其他任务...</div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。Semaphore可以控同时访问的线程个数，通过acquire()获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int N = 8;            //工人数</div><div class="line">        Semaphore semaphore = new Semaphore(5); //机器数目</div><div class="line">        for(int i=0;i&lt;N;i++)</div><div class="line">            new Worker(i,semaphore).start();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    static class Worker extends Thread&#123;</div><div class="line">        private int num;</div><div class="line">        private Semaphore semaphore;</div><div class="line">        public Worker(int num,Semaphore semaphore)&#123;</div><div class="line">            this.num = num;</div><div class="line">            this.semaphore = semaphore;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                semaphore.acquire();</div><div class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);</div><div class="line">                Thread.sleep(2000);</div><div class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);</div><div class="line">                semaphore.release();           </div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">工人0占用一个机器在生产...</div><div class="line">工人1占用一个机器在生产...</div><div class="line">工人2占用一个机器在生产...</div><div class="line">工人4占用一个机器在生产...</div><div class="line">工人5占用一个机器在生产...</div><div class="line">工人0释放出机器</div><div class="line">工人2释放出机器</div><div class="line">工人3占用一个机器在生产...</div><div class="line">工人7占用一个机器在生产...</div><div class="line">工人4释放出机器</div><div class="line">工人5释放出机器</div><div class="line">工人1释放出机器</div><div class="line">工人6占用一个机器在生产...</div><div class="line">工人3释放出机器</div><div class="line">工人7释放出机器</div><div class="line">工人6释放出机器</div></pre></td></tr></table></figure></p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。当在运行不对称的活动时很有用。比如说，一个线程向buffer中填充数据，另一个线程从buffer中消费数据；这些线程可以用Exchange来交换数据。这个交换对于两个线程来说都是全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.clzhang.sample.thread;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line">import java.util.concurrent.Exchanger;</div><div class="line"></div><div class="line">public class SyncExchanger &#123;</div><div class="line">    private static final Exchanger exchanger = new Exchanger();</div><div class="line"></div><div class="line">    class DataProducer implements Runnable &#123;</div><div class="line">        private List list = new ArrayList();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">                System.out.println(&quot;生产了一个数据，耗时1秒&quot;);</div><div class="line">                list.add(new Date());</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                list = (List) exchanger.exchange(list);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</div><div class="line">                System.out.println(&quot;Producer &quot; + iterator.next());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class DataConsumer implements Runnable &#123;</div><div class="line">        private List list = new ArrayList();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">                list.add(&quot;这是一个收条。&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                list = (List) exchanger.exchange(list);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</div><div class="line">                Date d = (Date) iterator.next();</div><div class="line">                System.out.println(&quot;Consumer: &quot; + d);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SyncExchanger ins = new SyncExchanger();</div><div class="line">        new Thread(ins.new DataProducer()).start();</div><div class="line">        new Thread(ins.new DataConsumer()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">生产了一个数据，耗时1秒</div><div class="line">生产了一个数据，耗时1秒</div><div class="line">生产了一个数据，耗时1秒</div><div class="line">生产了一个数据，耗时1秒</div><div class="line">生产了一个数据，耗时1秒</div><div class="line">Producer 这是一个收条。</div><div class="line">Producer 这是一个收条。</div><div class="line">Producer 这是一个收条。</div><div class="line">Producer 这是一个收条。</div><div class="line">Producer 这是一个收条。</div><div class="line">Consumer: Thu Sep 12 17:21:39 CST 2013</div><div class="line">Consumer: Thu Sep 12 17:21:40 CST 2013</div><div class="line">Consumer: Thu Sep 12 17:21:41 CST 2013</div><div class="line">Consumer: Thu Sep 12 17:21:42 CST 2013</div><div class="line">Consumer: Thu Sep 12 17:21:43 CST 2013</div></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">《Java并发编程的艺术》</a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="external">Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</a></p>
<p><a href="http://blog.csdn.net/u011116672/article/details/51068828" target="_blank" rel="external"> Java并发编程系列之十九：原子操作类</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">77</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
