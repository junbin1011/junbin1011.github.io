<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/5/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/5/">





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/06/设计模式-解释器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/设计模式-解释器模式/" itemprop="url">
                  设计模式-解释器模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T10:22:49+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/06/设计模式-解释器模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/06/设计模式-解释器模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-解释器模式的定义及使用场景"><a href="#1-解释器模式的定义及使用场景" class="headerlink" title="1.解释器模式的定义及使用场景"></a>1.解释器模式的定义及使用场景</h1><p>解释器模式是一种用得比较少的行为模式，其提供了一种解释语言的语法或表达式的方式，该模式定义了一个表达式接口，通过该接口解释一个特定的上下文</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素相同。按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。在这种情况下，可以通过程序来一劳永逸地解决该问题</li>
<li>一个简单语法需要解释的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170306102013110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-解释器模式的优缺点"><a href="#2-解释器模式的优缺点" class="headerlink" title="2. 解释器模式的优缺点"></a>2. 解释器模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p>
<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2><ul>
<li>解释器模式会引起类膨胀<br>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦</li>
<li>解释器模式采用递归调用方式<br>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地解析，无论是面向对象的语言还是面向过程的语言，递归都是 在必要条件下使用的，它导致调试非常复杂。想想看，如果要排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。</li>
<li>效率问题<br>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。<h1 id="4-解释器模式的实现方式"><a href="#4-解释器模式的实现方式" class="headerlink" title="4. 解释器模式的实现方式"></a>4. 解释器模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Expression &#123;</span><br><span class="line">    //每个表达式必须有一个解析任务</span><br><span class="line">    public abstract Object interpreter(Context ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class NoterminalExpression extends Expression &#123;</span><br><span class="line">    //每个非终结符表达式都会对其他表达式产生依赖</span><br><span class="line">    public NoterminalExpression(Expression... expressions) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        //进行文法处理</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TerminaExpression extends Expression &#123;</span><br><span class="line">    //通常终结符表达式只有一个，但是有多个对象</span><br><span class="line">    @Override</span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       Context ctx=new Context();</span><br><span class="line">        Stack&lt;Expression&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        //通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            //进行语法判断，并产生递归调用</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //产生一个完整的语法树，由各个具体的语法分析进行解析</span><br><span class="line">        Expression expression=stack.pop();</span><br><span class="line">        //具体元素进入场景</span><br><span class="line">        expression.interpreter(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/04/设计模式-状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/04/设计模式-状态模式/" itemprop="url">
                  设计模式-状态模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-04T15:20:39+08:00">
                2017-03-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/04/设计模式-状态模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/04/设计模式-状态模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-状态模式的定义及使用场景"><a href="#1-状态模式的定义及使用场景" class="headerlink" title="1.状态模式的定义及使用场景"></a>1.状态模式的定义及使用场景</h1><p>状态模式中的行为是由状态来决定的，不同的状态下又不同的行为。状态模式和策略模式的结构几乎完全一样，但他们的目的，本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、互相替换的。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>当一个对象内在状态改变时允许其 改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发送了改变一样。</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为</li>
<li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的多分支语句，且这些分支依赖于该对象的状态</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170304151833643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-状态模式的优缺点"><a href="#2-状态模式的优缺点" class="headerlink" title="2. 状态模式的优缺点"></a>2. 状态模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>结构清晰<br>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性，提高系统的可维护性</li>
<li>遵循设计原则<br>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类。你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了</li>
<li>良好的封装性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>状态模式既有优点，也有缺点。子类会比较多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>状态模式适用于当某个对象在它的状态发送改变时，它的行为也随着发送比较大的变化，也就是说在行为状态受约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个<h1 id="4-状态模式的实现方式"><a href="#4-状态模式的实现方式" class="headerlink" title="4. 状态模式的实现方式"></a>4. 状态模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class State &#123;</span><br><span class="line">    //定义一个环境角色，提供子类访问</span><br><span class="line">    protected Context context;</span><br><span class="line"></span><br><span class="line">    //设置环境角色</span><br><span class="line">    public void setContext(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handle1();</span><br><span class="line"></span><br><span class="line">    public abstract void handle2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteState1 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //设置当前状态为stat2</span><br><span class="line">        super.context.setCurrentState(Context.state2);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handler2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteState2 extends  State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //设置当前状态为stat2</span><br><span class="line">        super.context.setCurrentState(Context.state1);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    //定义状态</span><br><span class="line">    public final static State state1 = new ConcreteState1();</span><br><span class="line">    public final static State state2 = new ConcreteState2();</span><br><span class="line">    //当前状态</span><br><span class="line">    private State currentState;</span><br><span class="line"></span><br><span class="line">    public State getCurrentState() &#123;</span><br><span class="line">        return currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentState(State currentState) &#123;</span><br><span class="line">        this.currentState = currentState;</span><br><span class="line">        this.currentState.setContext(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //行为委托</span><br><span class="line">    public void handle1()&#123;</span><br><span class="line">        this.currentState.handle1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handler2()&#123;</span><br><span class="line">        this.currentState.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Context context=new Context();</span><br><span class="line">        context.setCurrentState(new ConcreteState1());</span><br><span class="line">        context.handle1();</span><br><span class="line">        context.handler2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/03/设计模式-访问者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/03/设计模式-访问者模式/" itemprop="url">
                  设计模式-访问者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T08:23:29+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/03/设计模式-访问者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/03/设计模式-访问者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-访问者模式的定义及使用场景"><a href="#1-访问者模式的定义及使用场景" class="headerlink" title="1.访问者模式的定义及使用场景"></a>1.访问者模式的定义及使用场景</h1><p>访问者模式是一种数据操作与数据结构分离的设计模式，访问者模式的基本想法是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中会调用访问者的visit方法，从而使访问者得以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象设施一些依赖于具体类的操作，也就说是用迭代器模式已经不能胜任的情景</li>
<li><p>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类</p>
<p><img src="http://img.blog.csdn.net/20170303082103186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h1 id="2-访问者模式的优缺点"><a href="#2-访问者模式的优缺点" class="headerlink" title="2. 访问者模式的优缺点"></a>2. 访问者模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>各角色职责分离，符合单一责任原则</li>
<li>具有优秀的扩展性</li>
<li>使得数据结构和作用于数据结构上的操作解耦，使得操作集合可以独立变化</li>
<li>高灵活性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2></li>
<li>具体元素对访问者公布细节<br>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是访问者关注了其他类的内部细节，这是迪米特法则所不建议</li>
<li>具体元素变更比较困难<br>具体元素角色的增加、删除、修改都是比较困难</li>
<li>违背了依赖倒置原则<br>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。<h1 id="4-访问者模式的实现方式"><a href="#4-访问者模式的实现方式" class="headerlink" title="4. 访问者模式的实现方式"></a>4. 访问者模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Element &#123;</span><br><span class="line">    //定义业务逻辑</span><br><span class="line">    public abstract void doSomeThing();</span><br><span class="line"></span><br><span class="line">    //允许谁来访问</span><br><span class="line">    public abstract void accept(IVisitor visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CocreteElement1 extends Element &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;CocreteElement1 doSomeThing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CocreteElement2 extends Element &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;CocreteElement2 doSomeThing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IVisitor &#123;</span><br><span class="line">    //可以访问那些对象</span><br><span class="line">    public void visit(CocreteElement1 element1);</span><br><span class="line"></span><br><span class="line">    public void visit(CocreteElement2 element2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Visitor implements IVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(CocreteElement1 element1) &#123;</span><br><span class="line">        element1.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(CocreteElement2 element2) &#123;</span><br><span class="line">        element2.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectStruture &#123;</span><br><span class="line">    public static Element createElement() &#123;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        if (random.nextInt(100) &gt; 50) &#123;</span><br><span class="line">            return new CocreteElement1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new CocreteElement2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            Element element = ObjectStruture.createElement();</span><br><span class="line">            element.accept(new Visitor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/01/设计模式-备忘录模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/设计模式-备忘录模式/" itemprop="url">
                  设计模式-备忘录模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T10:02:18+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/设计模式-备忘录模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/设计模式-备忘录模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-备忘录模式的定义及使用场景"><a href="#1-备忘录模式的定义及使用场景" class="headerlink" title="1.备忘录模式的定义及使用场景"></a>1.备忘录模式的定义及使用场景</h1><p>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象回复到原先保存的状态</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>需要用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170301095411447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-备忘录模式的优缺点"><a href="#2-备忘录模式的优缺点" class="headerlink" title="2. 备忘录模式的优缺点"></a>2. 备忘录模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保持细节<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1></li>
<li>备忘录的生命期<br>备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li>
<li>备忘录的性能<br>不要在频繁建立备份的场景中使用备忘录模式（比如一个for循环中），主要原因是一是控制不了备忘录建立的对象数量；而是大对象的建立是要消耗资源的，系统的性能需要考虑。<h1 id="4-备忘录模式的实现方式"><a href="#4-备忘录模式的实现方式" class="headerlink" title="4. 备忘录模式的实现方式"></a>4. 备忘录模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Memento &#123;</span><br><span class="line">    //发起人的内部状态</span><br><span class="line">    private String state=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public Memento(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Caretaker &#123;</span><br><span class="line">    //备忘录对象</span><br><span class="line">    private  Memento memento;</span><br><span class="line"></span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建一个备忘录</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //恢复一个备忘录</span><br><span class="line">    public void restoreMemento(Memento memento) &#123;</span><br><span class="line">        this.setState(memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        //定义出发起人</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        originator.setState(&quot;初始：1111111111111&quot;);</span><br><span class="line">        //定义出备忘录管理员</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">        //创建一个备忘录</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">        originator.setState(&quot;改变：22222222222222&quot;);</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">        originator.setState(&quot;恢复：restoreMemento&quot;);</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-备忘录模式在Android中的实际应用"><a href="#5-备忘录模式在Android中的实际应用" class="headerlink" title="5. 备忘录模式在Android中的实际应用"></a>5. 备忘录模式在Android中的实际应用</h1><p>在Android开发中，状态模式应用是Android中的状态保持，也就是里面的onSaveInstanceState和onRestoreInstanceState。当Activity不是正常方式退出，且Activity在随后的时间内被系统杀死之前会调用这两个方法让开发人员可以有机会存储Activity的相关信息，并且在下次放好Activity的时候恢复这些数据。<br>Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line"> outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); //保存当前窗口的视图树的状态</span><br><span class="line"> Parcelable p = mFragments.saveAllState(); //存储Fragment的状态</span><br><span class="line"> if (p != null) &#123;</span><br><span class="line"> outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line"> &#125;</span><br><span class="line"> getApplication().dispatchActivitySaveInstanceState(this, outState);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>Window的实现为PhoneWindow：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> /** &#123;@inheritDoc&#125; */</span><br><span class="line">  @Override</span><br><span class="line">  public Bundle saveHierarchyState() &#123;</span><br><span class="line">  Bundle outState = new Bundle();</span><br><span class="line">  if (mContentParent == null) &#123;</span><br><span class="line">  return outState;</span><br><span class="line">  &#125;</span><br><span class="line">//通过SparseArray类来存储，这相当于一个key为整型的map</span><br><span class="line">  SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();</span><br><span class="line">//mContentParent就是调用Activity的setContentView函数设置的内容视图，它是内容视图的根节点，在这里存储整棵树的结构</span><br><span class="line">  mContentParent.saveHierarchyState(states);</span><br><span class="line">//将视图树结构放到outState中</span><br><span class="line">  outState.putSparseParcelableArray(VIEWS_TAG, states);</span><br><span class="line"></span><br><span class="line">  // 保存当前界面中获取了焦点的View</span><br><span class="line">  View focusedView = mContentParent.findFocus();</span><br><span class="line">  if (focusedView != null) &#123;</span><br><span class="line">  if (focusedView.getId() != View.NO_ID) &#123;</span><br><span class="line">  outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">  Log.d(TAG, &quot;couldn&apos;t save which view has focus because the focused view &quot;</span><br><span class="line">  + focusedView + &quot; has no id.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 存储整个面板的状态</span><br><span class="line">  SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();</span><br><span class="line">  savePanelState(panelStates);</span><br><span class="line">  if (panelStates.size() &gt; 0) &#123;</span><br><span class="line">  outState.putSparseParcelableArray(PANELS_TAG, panelStates);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//存储actionBar的状态</span><br><span class="line">  if (mDecorContentParent != null) &#123;</span><br><span class="line">  SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();</span><br><span class="line">  mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</span><br><span class="line">  outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return outState;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在saveHierarchyState函数中，主要是存储了与当前UI、ActionBar相关的View状态。mContentParent就是我们通过Activity的setContentView函数设置的内容视图，他是这个内容视图的根节点。mContentParent是一个ViewGroup对象，但是saveHierachyState是在父类View中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</span><br><span class="line"> dispatchSaveInstanceState(container);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</span><br><span class="line">if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123;</span><br><span class="line">mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">Parcelable state = onSaveInstanceState();</span><br><span class="line">if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Derived class did not call super.onSaveInstanceState()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (state != null) &#123;</span><br><span class="line">// Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)</span><br><span class="line">// + &quot;: &quot; + state);</span><br><span class="line">container.put(mID, state); //将自身状态放到container中 key 为id value为自身状态</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//View类默认的存储的状态为空</span><br><span class="line"> protected Parcelable onSaveInstanceState() &#123;</span><br><span class="line">  mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">  if (mStartActivityRequestWho != null) &#123;</span><br><span class="line">  BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);</span><br><span class="line">  state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</span><br><span class="line">  return state;</span><br><span class="line">  &#125;</span><br><span class="line">  return BaseSavedState.EMPTY_STATE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>恢复数据的调用过程如下，基本流程与保存类似<br>Activity:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">if (mWindow != null) &#123;</span><br><span class="line">Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);</span><br><span class="line">if (windowState != null) &#123;</span><br><span class="line">mWindow.restoreHierarchyState(windowState);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PhoneWindow:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line"> @Override</span><br><span class="line"> public void restoreHierarchyState(Bundle savedInstanceState) &#123;</span><br><span class="line"> if (mContentParent == null) &#123;</span><br><span class="line"> return;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> SparseArray&lt;Parcelable&gt; savedStates</span><br><span class="line"> = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);</span><br><span class="line"> if (savedStates != null) &#123;</span><br><span class="line"> mContentParent.restoreHierarchyState(savedStates);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // restore the focused view</span><br><span class="line"> int focusedViewId = savedInstanceState.getInt(FOCUSED_ID_TAG, View.NO_ID);</span><br><span class="line"> if (focusedViewId != View.NO_ID) &#123;</span><br><span class="line"> View needsFocus = mContentParent.findViewById(focusedViewId);</span><br><span class="line"> if (needsFocus != null) &#123;</span><br><span class="line"> needsFocus.requestFocus();</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> Log.w(TAG,</span><br><span class="line"> &quot;Previously focused view reported id &quot; + focusedViewId</span><br><span class="line"> + &quot; during save, but can&apos;t be found during restore.&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // restore the panels</span><br><span class="line"> SparseArray&lt;Parcelable&gt; panelStates = savedInstanceState.getSparseParcelableArray(PANELS_TAG);</span><br><span class="line"> if (panelStates != null) &#123;</span><br><span class="line"> restorePanelState(panelStates);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if (mDecorContentParent != null) &#123;</span><br><span class="line"> SparseArray&lt;Parcelable&gt; actionBarStates =</span><br><span class="line"> savedInstanceState.getSparseParcelableArray(ACTION_BAR_TAG);</span><br><span class="line"> if (actionBarStates != null) &#123;</span><br><span class="line"> doPendingInvalidatePanelMenu();</span><br><span class="line"> mDecorContentParent.restoreToolbarHierarchyState(actionBarStates);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> Log.w(TAG, &quot;Missing saved instance states for action bar views! &quot; +</span><br><span class="line"> &quot;State will not be restored.&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>View:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</span><br><span class="line">  dispatchRestoreInstanceState(container);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Called by &#123;@link #restoreHierarchyState(android.util.SparseArray)&#125; to retrieve the</span><br><span class="line">* state for this view and its children. May be overridden to modify how restoring</span><br><span class="line">* happens to a view&apos;s children; for example, some views may want to not store state</span><br><span class="line">* for their children.</span><br><span class="line">*</span><br><span class="line">* @param container The SparseArray which holds previously saved state.</span><br><span class="line">*</span><br><span class="line">* @see #dispatchSaveInstanceState(android.util.SparseArray)</span><br><span class="line">* @see #restoreHierarchyState(android.util.SparseArray)</span><br><span class="line">* @see #onRestoreInstanceState(android.os.Parcelable)</span><br><span class="line">*/</span><br><span class="line">protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</span><br><span class="line">if (mID != NO_ID) &#123;</span><br><span class="line">Parcelable state = container.get(mID);</span><br><span class="line">if (state != null) &#123;</span><br><span class="line">// Log.i(&quot;View&quot;, &quot;Restoreing #&quot; + Integer.toHexString(mID)</span><br><span class="line">// + &quot;: &quot; + state);</span><br><span class="line">mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">onRestoreInstanceState(state);</span><br><span class="line">if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Derived class did not call super.onRestoreInstanceState()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void onRestoreInstanceState(Parcelable state) &#123;</span><br><span class="line">mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">if (state != null &amp;&amp; !(state instanceof AbsSavedState)) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Wrong state class, expecting View State but &quot;</span><br><span class="line">+ &quot;received &quot; + state.getClass().toString() + &quot; instead. This usually happens &quot;</span><br><span class="line">+ &quot;when two views of different type have the same id in the same hierarchy. &quot;</span><br><span class="line">+ &quot;This view&apos;s id is &quot; + ViewDebug.resolveId(mContext, getId()) + &quot;. Make sure &quot;</span><br><span class="line">+ &quot;other views do not use the same id.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (state != null &amp;&amp; state instanceof BaseSavedState) &#123;</span><br><span class="line">mStartActivityRequestWho = ((BaseSavedState) state).mStartActivityRequestWhoSaved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个过程中，Activity扮演了Caretaker角色，负责存储、恢复UI的状态信息；Activity、Fragement、View、ViewGroup等对象为Originator角色，也就是需要存储状态的对象；Memento则是由Bundle类扮演。</p>
<p>Activity在停止之前会根据Activity的退出情景来选择是否需要存储状态，在重新启动该Activity时会判断ActivityClientRecord对象中是否存储了Activity的状态，如果含有状态则调用Activity的onRestoreInstanceState函数，从而使得Activity的UI效果与上次保持一致，这样一来，就保证了在非正常退出Activity时不会丢失数据的情况，很好地提升了用户体验。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/28/设计模式-外观模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/设计模式-外观模式/" itemprop="url">
                  设计模式-外观模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T09:29:08+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/28/设计模式-外观模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/28/设计模式-外观模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-外观模式的定义及使用场景"><a href="#1-外观模式的定义及使用场景" class="headerlink" title="1.外观模式的定义及使用场景"></a>1.外观模式的定义及使用场景</h1><p>外观模式（Facade）在开发过程中的运用频率非常高，尤其是在现阶段各个第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式，通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。</p>
<p><img src="http://img.blog.csdn.net/20170228092218459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>要求一个子系统的外部与其内部的通讯必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口</li>
<li>子系统相对独立–外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散<h1 id="2-外观模式的优缺点"><a href="#2-外观模式的优缺点" class="headerlink" title="2. 外观模式的优缺点"></a>2. 外观模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2></li>
<li>减少系统的相互依赖</li>
<li>提高了灵活性</li>
<li>提高安全性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>门面模式的最大缺点就是不符合开闭原则，对修改关闭，对扩展开放，需求变化时，需要修改Facade的代码，这样相对风险比较大<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1></li>
<li>对于庞大到不能容忍的程度，一个子系统可以有多个门面</li>
<li>门面不要参与子系统内的业务逻辑<h1 id="4-外观模式的实现方式"><a href="#4-外观模式的实现方式" class="headerlink" title="4. 外观模式的实现方式"></a>4. 外观模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ClassA &#123;</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;ClassA is doSomeThing!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ClassB &#123;</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;ClassB is doSomeThing!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ClassC &#123;</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;ClassC is doSomeThing!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    ClassA classA = new ClassA();</span><br><span class="line">    ClassB classB = new ClassB();</span><br><span class="line">    ClassC classC = new ClassC();</span><br><span class="line"></span><br><span class="line">    public void doMethodA() &#123;</span><br><span class="line">        classA.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doMethodB() &#123;</span><br><span class="line">        classB.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doMethodC() &#123;</span><br><span class="line">        classC.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public  static void main(String args[]) &#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line">        facade.doMethodA();</span><br><span class="line">        facade.doMethodB();</span><br><span class="line">        facade.doMethodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-外观模式在Android中的实际应用"><a href="#5-外观模式在Android中的实际应用" class="headerlink" title="5. 外观模式在Android中的实际应用"></a>5. 外观模式在Android中的实际应用</h1><p>在Android开发过程中，Context是最重要的一个类型，Context意为上下文，也就是程序的运行环境。它封装了很多重要的操作。如startActivity（）、sendBoradcast（）、bindService等，因此，Context对开发者来说就是重要的高层接口。</p>
<p>我们都知道Context的实现类是ContextImpl。ContextImpl内部封装了很多不同子系统的操作，例如Activity的跳转、广播、启动服务、设置壁纸等，这些工作并不是在ContextImpl中实现，而是转交给了具体的子系统进行处理。</p>
<p>用户可以通过Context这个接口统一进行与Android系统的交互，这样用户通过情况下就不需要对每个子系统进行了解，例如启动Activity时用户不需要手动调用mMainThread.getInstrumentation().execStartActivity函数进行执行，发送广播时也不需要直接操作ActivityManagerNative类。用户于系统服务的交互都通过Context的高层接口，这样对用户屏蔽了具体的实现细节，降低了使用成本</p>
<p>关于Context的具体介绍可以参考博文：<br><a href="http://blog.csdn.net/junbin1011/article/details/54612858（" target="_blank" rel="noopener">http://blog.csdn.net/junbin1011/article/details/54612858（</a>  Android之Context底层原理）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/27/设计模式-观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/设计模式-观察者模式/" itemprop="url">
                  设计模式-观察者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T11:00:57+08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/27/设计模式-观察者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/27/设计模式-观察者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-观察者模式的定义及使用场景"><a href="#1-观察者模式的定义及使用场景" class="headerlink" title="1.观察者模式的定义及使用场景"></a>1.观察者模式的定义及使用场景</h1><p>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统，订阅-发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所以依赖于它的对象都会得到通知并被自动更新</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>关联行为场景，需要注意的是，关联行为时可拆分的，而不是“组合”关系；</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170227104314607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-观察者模式的优缺点"><a href="#2-观察者模式的优缺点" class="headerlink" title="2. 观察者模式的优缺点"></a>2. 观察者模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>观察者和被观察者之间是抽象解耦，应对业务变化</li>
<li>增强系统灵活性、可扩展性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>在应用观察者模式时需要考虑一下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式<h1 id="3-观察者模式的实现方式"><a href="#3-观察者模式的实现方式" class="headerlink" title="3. 观察者模式的实现方式"></a>3. 观察者模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    //更新方法</span><br><span class="line">    public void  update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteObsever implements Observer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;接收到信息，并进行处理！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line">    //定义一个观察者数组</span><br><span class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //增加一个观察者</span><br><span class="line">    public void addObserver(Observer o) &#123;</span><br><span class="line">        this.observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除一个观察者</span><br><span class="line">    public void removeObserver(Observer o) &#123;</span><br><span class="line">        this.observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通知所有观察者</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer o : this.observers) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">    //具体的业务</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        super.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">      //创建一个被观察者</span><br><span class="line">        ConcreteSubject subject=new ConcreteSubject();</span><br><span class="line">        Observer obs=new ConcreteObsever();</span><br><span class="line">        subject.addObserver(obs);</span><br><span class="line">        subject.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-观察者模式在Android中的实际应用"><a href="#4-观察者模式在Android中的实际应用" class="headerlink" title="4. 观察者模式在Android中的实际应用"></a>4. 观察者模式在Android中的实际应用</h1><p>RecycleView是Android中最重要的控件之一，而RecycleView最重要的一个功能就是Adapter。通过我们往RecycleView添加数据后，都会调用Adapter的notifyDataSetChanged（）方法，这是为什么？<br>首先我们看下Adapter的实现，他是RecycleView的一个内部类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public static abstract class Adapter&lt;VH extends ViewHolder&gt; &#123;</span><br><span class="line">private final AdapterDataObservable mObservable = new AdapterDataObservable();</span><br><span class="line">private boolean mHasStableIds = false;</span><br><span class="line"></span><br><span class="line">public abstract VH onCreateViewHolder(ViewGroup parent, int viewType);</span><br><span class="line"></span><br><span class="line">public abstract void onBindViewHolder(VH holder, int position);</span><br><span class="line"></span><br><span class="line">public void onBindViewHolder(VH holder, int position, List&lt;Object&gt; payloads) &#123;</span><br><span class="line">onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final VH createViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);</span><br><span class="line">final VH holder = onCreateViewHolder(parent, viewType);</span><br><span class="line">holder.mItemViewType = viewType;</span><br><span class="line">TraceCompat.endSection();</span><br><span class="line">return holder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void bindViewHolder(VH holder, int position) &#123;</span><br><span class="line">holder.mPosition = position;</span><br><span class="line">if (hasStableIds()) &#123;</span><br><span class="line">holder.mItemId = getItemId(position);</span><br><span class="line">&#125;</span><br><span class="line">holder.setFlags(ViewHolder.FLAG_BOUND,</span><br><span class="line">ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID</span><br><span class="line">| ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);</span><br><span class="line">TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);</span><br><span class="line">onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());</span><br><span class="line">holder.clearPayload();</span><br><span class="line">TraceCompat.endSection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getItemViewType(int position) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHasStableIds(boolean hasStableIds) &#123;</span><br><span class="line">if (hasObservers()) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Cannot change whether this adapter has &quot; +</span><br><span class="line">&quot;stable IDs while the adapter has registered observers.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mHasStableIds = hasStableIds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long getItemId(int position) &#123;</span><br><span class="line">return NO_ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract int getItemCount();</span><br><span class="line"></span><br><span class="line">public final boolean hasStableIds() &#123;</span><br><span class="line">return mHasStableIds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onViewRecycled(VH holder) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean onFailedToRecycleView(VH holder) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onViewAttachedToWindow(VH holder) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onViewDetachedFromWindow(VH holder) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean hasObservers() &#123;</span><br><span class="line">return mObservable.hasObservers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerAdapterDataObserver(AdapterDataObserver observer) &#123;</span><br><span class="line">mObservable.registerObserver(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unregisterAdapterDataObserver(AdapterDataObserver observer) &#123;</span><br><span class="line">mObservable.unregisterObserver(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyDataSetChanged() &#123;</span><br><span class="line">mObservable.notifyChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemChanged(int position) &#123;</span><br><span class="line">mObservable.notifyItemRangeChanged(position, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemChanged(int position, Object payload) &#123;</span><br><span class="line">mObservable.notifyItemRangeChanged(position, 1, payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemRangeChanged(int positionStart, int itemCount) &#123;</span><br><span class="line">mObservable.notifyItemRangeChanged(positionStart, itemCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">mObservable.notifyItemRangeChanged(positionStart, itemCount, payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemInserted(int position) &#123;</span><br><span class="line">mObservable.notifyItemRangeInserted(position, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemMoved(int fromPosition, int toPosition) &#123;</span><br><span class="line">mObservable.notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line">mObservable.notifyItemRangeInserted(positionStart, itemCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemRemoved(int position) &#123;</span><br><span class="line">mObservable.notifyItemRangeRemoved(position, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void notifyItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line">mObservable.notifyItemRangeRemoved(positionStart, itemCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到notifyDataSetChange（）中调用了mObservable.notifyChange()。继续看AdapterDataObservable类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static class AdapterDataObservable extends Observable&lt;AdapterDataObserver&gt; &#123;</span><br><span class="line">public boolean hasObservers() &#123;</span><br><span class="line">return !mObservers.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyChanged() &#123;</span><br><span class="line">for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">mObservers.get(i).onChanged();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyItemRangeChanged(int positionStart, int itemCount) &#123;</span><br><span class="line">notifyItemRangeChanged(positionStart, itemCount, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">mObservers.get(i).onItemRangeChanged(positionStart, itemCount, payload);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">mObservers.get(i).onItemRangeInserted(positionStart, itemCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">mObservers.get(i).onItemRangeRemoved(positionStart, itemCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyItemMoved(int fromPosition, int toPosition) &#123;</span><br><span class="line">for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">mObservers.get(i).onItemRangeMoved(fromPosition, toPosition, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Observable是一个被观察者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observable&lt;T&gt; &#123;</span><br><span class="line">  /**</span><br><span class="line">  * The list of observers. An observer can be in the list at most</span><br><span class="line">  * once and will never be null.</span><br><span class="line">  */</span><br><span class="line">  protected final ArrayList&lt;T&gt; mObservers = new ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * Adds an observer to the list. The observer cannot be null and it must not already</span><br><span class="line">  * be registered.</span><br><span class="line">  * @param observer the observer to register</span><br><span class="line">  * @throws IllegalArgumentException the observer is null</span><br><span class="line">  * @throws IllegalStateException the observer is already registered</span><br><span class="line">  */</span><br><span class="line">  public void registerObserver(T observer) &#123;</span><br><span class="line">  if (observer == null) &#123;</span><br><span class="line">  throw new IllegalArgumentException(&quot;The observer is null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  synchronized(mObservers) &#123;</span><br><span class="line">  if (mObservers.contains(observer)) &#123;</span><br><span class="line">  throw new IllegalStateException(&quot;Observer &quot; + observer + &quot; is already registered.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  mObservers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * Removes a previously registered observer. The observer must not be null and it</span><br><span class="line">  * must already have been registered.</span><br><span class="line">  * @param observer the observer to unregister</span><br><span class="line">  * @throws IllegalArgumentException the observer is null</span><br><span class="line">  * @throws IllegalStateException the observer is not yet registered</span><br><span class="line">  */</span><br><span class="line">  public void unregisterObserver(T observer) &#123;</span><br><span class="line">  if (observer == null) &#123;</span><br><span class="line">  throw new IllegalArgumentException(&quot;The observer is null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  synchronized(mObservers) &#123;</span><br><span class="line">  int index = mObservers.indexOf(observer);</span><br><span class="line">  if (index == -1) &#123;</span><br><span class="line">  throw new IllegalStateException(&quot;Observer &quot; + observer + &quot; was not registered.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  mObservers.remove(index);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * Remove all registered observers.</span><br><span class="line">  */</span><br><span class="line">  public void unregisterAll() &#123;</span><br><span class="line">  synchronized(mObservers) &#123;</span><br><span class="line">  mObservers.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdapterDataObserver 的派生类RecyclerViewDataObserver： mObserver是RecycleView的一个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private class RecyclerViewDataObserver extends AdapterDataObserver &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onChanged() &#123;</span><br><span class="line">assertNotInLayoutOrScroll(null);</span><br><span class="line">if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">// TODO Determine what actually changed.</span><br><span class="line">// This is more important to implement now since this callback will disable all</span><br><span class="line">// animations because we cannot rely on positions.</span><br><span class="line">mState.mStructureChanged = true;</span><br><span class="line">setDataSetChangedAfterLayout();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mState.mStructureChanged = true;</span><br><span class="line">setDataSetChangedAfterLayout();</span><br><span class="line">&#125;</span><br><span class="line">if (!mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">requestLayout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">assertNotInLayoutOrScroll(null);</span><br><span class="line">if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) &#123;</span><br><span class="line">triggerUpdateProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line">assertNotInLayoutOrScroll(null);</span><br><span class="line">if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">triggerUpdateProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line">assertNotInLayoutOrScroll(null);</span><br><span class="line">if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) &#123;</span><br><span class="line">triggerUpdateProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) &#123;</span><br><span class="line">assertNotInLayoutOrScroll(null);</span><br><span class="line">if (mAdapterHelper.onItemRangeMoved(fromPosition, toPosition, itemCount)) &#123;</span><br><span class="line">triggerUpdateProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void triggerUpdateProcessor() &#123;</span><br><span class="line">if (mPostUpdatesOnAnimation &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mAdapterUpdateDuringMeasure = true;</span><br><span class="line">requestLayout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecycleView的setAdapter方法，可以看到里面调用了unregisterAdapterDataObserver及registerAdapterDataObserver方法进行取消注册及注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void setAdapter(Adapter adapter) &#123;</span><br><span class="line"> // bail out if layout is frozen</span><br><span class="line"> setLayoutFrozen(false);</span><br><span class="line"> setAdapterInternal(adapter, false, true);</span><br><span class="line"> requestLayout();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</span><br><span class="line"> boolean removeAndRecycleViews) &#123;</span><br><span class="line"> if (mAdapter != null) &#123;</span><br><span class="line"> mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line"> mAdapter.onDetachedFromRecyclerView(this);</span><br><span class="line"> &#125;</span><br><span class="line"> if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line"> // end all running animations</span><br><span class="line"> if (mItemAnimator != null) &#123;</span><br><span class="line"> mItemAnimator.endAnimations();</span><br><span class="line"> &#125;</span><br><span class="line"> // Since animations are ended, mLayout.children should be equal to</span><br><span class="line"> // recyclerView.children. This may not be true if item animator&apos;s end does not work as</span><br><span class="line"> // expected. (e.g. not release children instantly). It is safer to use mLayout&apos;s child</span><br><span class="line"> // count.</span><br><span class="line"> if (mLayout != null) &#123;</span><br><span class="line"> mLayout.removeAndRecycleAllViews(mRecycler);</span><br><span class="line"> mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line"> &#125;</span><br><span class="line"> // we should clear it here before adapters are swapped to ensure correct callbacks.</span><br><span class="line"> mRecycler.clear();</span><br><span class="line"> &#125;</span><br><span class="line"> mAdapterHelper.reset();</span><br><span class="line"> final Adapter oldAdapter = mAdapter;</span><br><span class="line"> mAdapter = adapter;</span><br><span class="line"> if (adapter != null) &#123;</span><br><span class="line"> adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line"> adapter.onAttachedToRecyclerView(this);</span><br><span class="line"> &#125;</span><br><span class="line"> if (mLayout != null) &#123;</span><br><span class="line"> mLayout.onAdapterChanged(oldAdapter, mAdapter);</span><br><span class="line"> &#125;</span><br><span class="line"> mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</span><br><span class="line"> mState.mStructureChanged = true;</span><br><span class="line"> markKnownViewsInvalid();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里我们知道，setAdapter()方法会进行观察者的注册，当RecycleView的数据发送变化的时，调用了Adapter的notifyDataSetChange()，这个函数又会调用 AdapterDataObservable的notifyChanged（）；该函数会遍历所有的观察者的onChange函数，在 RecyclerViewDataObserver的onChange()函数中会获取Adapter中数据集的新数量，然后调用RecycleView的requestLayout（）方法重新进行布局，更新用户的界面。这就是一个观察者模式！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/24/设计模式-组合模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/设计模式-组合模式/" itemprop="url">
                  设计模式-组合模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-24T09:32:45+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/设计模式-组合模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/设计模式-组合模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-组合模式的定义及使用场景"><a href="#1-组合模式的定义及使用场景" class="headerlink" title="1.组合模式的定义及使用场景"></a>1.组合模式的定义及使用场景</h1><p>组合模式也称为部分整体模式，结构型设计模式之一，组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象集合之间的差别。生活中一个比较经典的例子就是组织结构的树状图。<br><img src="http://img.blog.csdn.net/20170224092806967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理</li>
<li>从一个整体中能够独立出部分模块或功能的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170224092825249?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-组合模式的优缺点"><a href="#2-组合模式的优缺点" class="headerlink" title="2. 组合模式的优缺点"></a>2. 组合模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让高层模块忽略了层次的差异，方便对整个层级结构进行控制</li>
<li>高层模块可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了高层模块的代码</li>
<li>在组合模式中增加新的枝干构件和叶子构件都很方便，无需对现有类库进行任何修改</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和枝干对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单<br>##2.2缺点<br>在新增构件时不好对枝干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为在大多数情况下，他们都来自于相同的抽象层，此时，必须进行类型检查来实现，过程比较复杂<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>组合模式有两种不同的实现：透明模式和安全模式（4点中为安全模式），透明模式是把用来组合使用的方法放到抽象类中，不管叶子对象还是树枝对象都有相同的结构。这种模式的缺点是通过判断getChildren的返回值确认是叶子节点还是树枝节点，如果处理不当，会在运行期出现问题，安全模式它是把树枝节点和叶子节点彻底分开，树枝节点单独拥有用来组合的方法。<h1 id="4-组合模式的实现方式"><a href="#4-组合模式的实现方式" class="headerlink" title="4. 组合模式的实现方式"></a>4. 组合模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Composite extends Component &#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(Component component) &#123;</span><br><span class="line">        componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;Component&gt; getChildren() &#123;</span><br><span class="line">        return this.componentArrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;Composite do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Leaf extends  Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;Leaf do someThing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        //创建一个根节点</span><br><span class="line">        Composite root = new Composite();</span><br><span class="line">        root.doSomething();</span><br><span class="line">        //创建一个树枝构件</span><br><span class="line">        Composite barnch = new Composite();</span><br><span class="line">        //创建一个叶子节点</span><br><span class="line">        Leaf leaf = new Leaf();</span><br><span class="line">        //建立整体</span><br><span class="line">        root.add(barnch);</span><br><span class="line">        barnch.add(leaf);</span><br><span class="line">        //遍历</span><br><span class="line">        display(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void display(Composite composite) &#123;</span><br><span class="line">        for (Component c : composite.getChildren()) &#123;</span><br><span class="line">            if (c instanceof Leaf) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                display((Composite) c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-组合模式在Android中的实际应用"><a href="#5-组合模式在Android中的实际应用" class="headerlink" title="5. 组合模式在Android中的实际应用"></a>5. 组合模式在Android中的实际应用</h1><p>Android源码中关于组合模式有一个非常经典的实现，我们几乎每天都会使用到，那就是View和ViewGroup的嵌套组合。</p>
<p><img src="http://img.blog.csdn.net/20170224092900053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里省略了View和ViewGroup的一些方法，在Android的这个视图层级中，容器一定是ViewGroup，而且只有ViewGroup才能包含其他的View，例如Realyout能包含TextView、Button等，但反过来TextView不能包含Relayout，因为TextView直接继承了View，并不是一个容器，这里View的视图层级中使用的其实是一种安全的设计模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/23/设计模式-迭代器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/23/设计模式-迭代器模式/" itemprop="url">
                  设计模式-迭代器模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-23T09:33:00+08:00">
                2017-02-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/23/设计模式-迭代器模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/23/设计模式-迭代器模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-迭代器模式的定义及使用场景"><a href="#1-迭代器模式的定义及使用场景" class="headerlink" title="1.迭代器模式的定义及使用场景"></a>1.迭代器模式的定义及使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>迭代器模式又称游标模式，是行为型设计模式之一。其源于对容器的访问，比较java的List、Map、数组等。如果将容器遍历的方法封装在容器中，容器类不仅要维护自身内部的数据元素而且还要对外提供遍历的接口方法，如果不提供遍历的方法而让使用者自己去实现，又会让容器的内部细节暴露。正因于此，迭代模式应运而生。<br>迭代器模式提供一种方法顺序访问一个容器对象的各个元素，而又不需要暴露该对象的内部表示</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>遍历一个容器对象<br><strong>重点内容</strong><br><img src="http://img.blog.csdn.net/20170223093052345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-迭代器模式的优缺点"><a href="#2-迭代器模式的优缺点" class="headerlink" title="2. 迭代器模式的优缺点"></a>2. 迭代器模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><p>可以遍历容器而又不暴露该对象的内部表示，弱化了容器类和遍历算法之间的关系</p>
<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2><p>增加类文件</p>
<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1><h2 id="3-1使用for循环与使用迭代器iterator的对比"><a href="#3-1使用for循环与使用迭代器iterator的对比" class="headerlink" title="3.1使用for循环与使用迭代器iterator的对比"></a>3.1使用for循环与使用迭代器iterator的对比</h2><p>效率上的各有有事<br>采用ArrayList对随机访问比较快，而for循环中的get()方法，采用的即是随机访问的方法，因此在ArrayList里，for循环较快<br>采用LinkedList则是顺序访问比较快，iterator中的next()方法，采用的即是顺序访问的方法，因此在LinkedList里，使用iterator较快<br>从数据结构角度分析,for循环适合访问顺序结构,可以根据下标快速获取指定元素.而Iterator 适合访问链式结构,因为迭代器是通过next()和Pre()来定位的.可以访问没有顺序的集合.</p>
<p>而使用 Iterator 的好处在于可以使用相同方式去遍历集合中元素，而不用考虑集合类的内部实现（只要它实现了 java.lang.Iterable 接口），如果使用 Iterator 来遍历集合中元素，一旦不再使用 List 转而使用 Set 来组织数据，那遍历元素的代码不用做任何修改，如果使用 for 来遍历，那所有遍历此集合的算法都得做相应调整,因为List有序,Set无序,结构不同,他们的访问算法也不一样.</p>
<h2 id="3-2foreach和Iterator的关系"><a href="#3-2foreach和Iterator的关系" class="headerlink" title="3.2foreach和Iterator的关系"></a>3.2foreach和Iterator的关系</h2><p>for each是jdk5.0新增加的一个循环结构，可以用来处理集合中的每个元素而不用考虑集合定下标。<br>格式如下<br>for(variable:collection){ statement; }<br>定义一个变量用于暂存集合中的每一个元素，并执行相应的语句(块)。collection必须是一个数组或者是一个实现了lterable接口的类对象。 使用for each循环语句的优势在于更加简洁，更不容易出错，不必关心下标的起始值和终止值</p>
<h1 id="4-迭代器模式的实现方式"><a href="#4-迭代器模式的实现方式" class="headerlink" title="4. 迭代器模式的实现方式"></a>4. 迭代器模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    public  Object next();</span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public  boolean remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteIteractor implements  Iterator &#123;</span><br><span class="line">    private  Vector vevcor=new Vector&lt;&gt;();</span><br><span class="line">    private int curosr=0;</span><br><span class="line"></span><br><span class="line">    public ConcreteIteractor(Vector vevcor) &#123;</span><br><span class="line">        this.vevcor = vevcor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        Object result=null;</span><br><span class="line">        if(this.hasNext())&#123;</span><br><span class="line">            result=this.vevcor.get(this.curosr++);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result=null;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        if(this.curosr==this.vevcor.size())&#123;</span><br><span class="line">            curosr=0;</span><br><span class="line">            return  false;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove() &#123;</span><br><span class="line">        this.vevcor.remove(this.curosr);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Aggregate &#123;</span><br><span class="line">    public void add(Object object);</span><br><span class="line"></span><br><span class="line">    public void remove(Object remove);</span><br><span class="line"></span><br><span class="line">    public Iterator iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteAggragate implements Aggregate &#123;</span><br><span class="line">    private Vector vevcor = new Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Object object) &#123;</span><br><span class="line">        this.vevcor.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Object remove) &#123;</span><br><span class="line">        this.vevcor.remove(remove);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ConcreteIteractor(vevcor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-迭代器模式在Android中的实际应用"><a href="#5-迭代器模式在Android中的实际应用" class="headerlink" title="5. 迭代器模式在Android中的实际应用"></a>5. 迭代器模式在Android中的实际应用</h1><p>迭代器这个模式对开发者来说几乎不会自己去实现一个迭代器，Android中，其除了各种数据结构体，如List、Map等所包含的迭代器外，Android自身源码中也为我们提供了迭代器遍历数据。最为典型的例子就是Cursor游标对象，该游标对象实质就是一个具体的迭代器，我们可以使用它来遍历数据库查询所得的结果集。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/22/设计模式-适配器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/22/设计模式-适配器模式/" itemprop="url">
                  设计模式-适配器模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T10:10:25+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/22/设计模式-适配器模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/22/设计模式-适配器模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-适配器模式的定义及使用场景"><a href="#1-适配器模式的定义及使用场景" class="headerlink" title="1.适配器模式的定义及使用场景"></a>1.适配器模式的定义及使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>适配器模式在我们的开发中使用率非常高，从代码中随处可见的Adapter就可以看出来，从最早的ListView、GridView，到现在最新的RecycleView都需要用到Adapter。说到底，适配器就是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得他们能够协作起来。<br>适配器模式把一个类在接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</li>
<li>需要一个统一的输出接口，而输入端的类型不可预知</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170222100849043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-适配器模式的优缺点"><a href="#2-适配器模式的优缺点" class="headerlink" title="2. 适配器模式的优缺点"></a>2. 适配器模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>适配器模式可以让两个没有任何关系的类在一起运行</li>
<li>增加了类的透明度，提高类的复用度</li>
<li>增强灵活性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>过多地使用适配器，会让系统增加复杂度，不易整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现。因此，如果不是很有必要，可以不使用适配器，而是直接对系统进行必要的重构<h1 id="3-注意实现"><a href="#3-注意实现" class="headerlink" title="3.注意实现"></a>3.注意实现</h1>适配器模式最好在详细设计阶段不要考虑，它不是为了解决还出在开发阶段的问题，而是解决正在服役的项目问题，系统扩展了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的风险。<h1 id="4-适配器模式的实现方式"><a href="#4-适配器模式的实现方式" class="headerlink" title="4. 适配器模式的实现方式"></a>4. 适配器模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTarget implements Target &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteTarget is doing request!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Adaptee &#123;</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;Adaptee is doSomeThing now!！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Adapter extends Adaptee implements Target &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Target target = new ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line">        Target adapterTarget = new Adapter();</span><br><span class="line">        adapterTarget.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-适配器模式在Android中的实际应用"><a href="#5-适配器模式在Android中的实际应用" class="headerlink" title="5. 适配器模式在Android中的实际应用"></a>5. 适配器模式在Android中的实际应用</h1><p>ListView作为重要的控件，它需要能够显示各种各样的视图（ItemView），每个人需要的显示效果各不同。显示的数据类型、数量等也千变万化，那么如何应对这种变化成为架构师需要考虑的重要特性之一。</p>
<p>Android的做法是增加一个Adapter层来隔离变化，将ListView需要的关于Item View接口抽象到Adapter对象中，并且在ListView内部调用Adapter这些接口完成布局操作。这样只用用户实现了Adapter的接口，并且将该Adapter设置给ListView，ListView就可以按照用户设定的UI效果、数量、数据来显示每一项数据。</p>
<p>ListView最重要的问题是要解决每一项Item视图的输出，ItemView千变万化，但终究它是View类型，Adapter将统一ItemView 输出为View，这样就很好的应对了ItemView的可变性。这虽然有些脱离Adapter模式将不兼容的接口转换为可用接口的使用场景，但也是Adapter模式的一种变种实现。这里的Target角色就是View，Adapter角色就是将ItemView输出为View抽象的角色，Adaptee就是需要被处理的ItemView。</p>
<p>通过增加Adapter一层来将ItemView的操作抽象起来，ListView等集合视图通过Adapter对象获取Item的个数、数据、ItemView等，从而达到适配各种数据、各种Item视图的效果。因为ItemView和数据类型千变万化，Android的架构师将这种变化的部分交给用户来处理，通过getCount，getItem，getView等几个抽象出来，也就是将ItemView的构造过程交给用户来处理，灵活地运用了设配器的模式，达到了无限适配，拥抱变化的目的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/21/设计模式-策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/21/设计模式-策略模式/" itemprop="url">
                  设计模式-策略模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-21T10:11:13+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/21/设计模式-策略模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/21/设计模式-策略模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-策略模式的定义及使用场景"><a href="#1-策略模式的定义及使用场景" class="headerlink" title="1.策略模式的定义及使用场景"></a>1.策略模式的定义及使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在软件的开发中常常遇到一个情况，实现某一个功能可以有多种算法或则策略，我们根据实际情况选择不同的算法或则策略来完成该功能。针对这种情况，一种常规的方法是将多种算法写在一个类中，通过if-else等条件判断语句来选择具体的算法，但明显违背了开闭原则和单一责任原则。如果将这些算法或则策略抽象出来，提供一个统一的接口，不同的算法或则策略有不同的实现，这样在程序客户端就可以通过注入不同的实现对象来实现算法或则策略的动态替换，这种模式的扩展性、可维护性更高。<br>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时</li>
<li>需要安全地封装多种同一类型的操作时</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170221100602329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-策略模式的优缺点"><a href="#2-策略模式的优缺点" class="headerlink" title="2. 策略模式的优缺点"></a>2. 策略模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断</li>
<li>扩展性良好<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2></li>
<li>策略类数量增多</li>
<li>所有的策略类都需要多外暴露<h1 id="3-注意实现"><a href="#3-注意实现" class="headerlink" title="3.注意实现"></a>3.注意实现</h1>如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露问题，否则将增大日后的维护成本<h1 id="4-策略模式的实现方式"><a href="#4-策略模式的实现方式" class="headerlink" title="4. 策略模式的实现方式"></a>4. 策略模式的实现方式</h1></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public void doSomeThing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategy1 implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;具体算法1的运算法则...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategy2 implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;具体算法2的运算法则...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public Context(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        strategy.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>public class Test {
    public static void main(String args[]) {
        Strategy concreteStrategy1 = new ConcreteStrategy1();
        Strategy concretStrategy2 = new ConcreteStrategy2();
        Context context = new Context(concreteStrategy1);
        context.doSomeThing();
        context.setStrategy(concretStrategy2);
        context.doSomeThing();
    }
}
</code></pre><h1 id="5-策略模式在Android中的实际应用"><a href="#5-策略模式在Android中的实际应用" class="headerlink" title="5. 策略模式在Android中的实际应用"></a>5. 策略模式在Android中的实际应用</h1><p>在 RecyclerView 还没火起来前，ListView 是一个很重要的组件，我们通常在布局里写个 ListView 组件，然后在代码中 setAdapter，把 View 与 Model 结合的任务交给了 Adapter。</p>
<p>比如 ListView 要显示的子布局是个简单的文字时，我们可以使用 ArrayAdapter :<br><img src="http://img.blog.csdn.net/20170221100750302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>要显示复杂些的布局时，就需要用 BaseAdapter ：<br><img src="http://img.blog.csdn.net/20170221100806552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>我们可以看到，当更换 Adapter 的具体实现时，仍然调用的是 ListView.setAdapter(…) 方法，查看 ListView 源码，发现 setAdapter 方法的参数是一个 ListAdapter:<br><img src="http://img.blog.csdn.net/20170221100817896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>继续看 ListAdapter 源码和类结构：<br><img src="http://img.blog.csdn.net/20170221100829302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到 ListAdapter 是一个接口，ArrayAdapter 和 BaseAdapter 是它的一个实现类。对比文章开始给出的 策略模式 UML 图，可以发现 ListAdapter 就是 strategy 接口，ArrayAdpater 等就是具体的实现类，而在 ListView 中引用的是 接口 ListAdapter，可以证实这就是一个 策略模式 的使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
