<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/3/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/3/"/>





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/23/Java并发编程-基础原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/23/Java并发编程-基础原理/" itemprop="url">
                  Java并发编程-基础原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-23T10:13:59+08:00">
                2017-09-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/23/Java并发编程-基础原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/23/Java并发编程-基础原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发编的挑战"><a href="#并发编的挑战" class="headerlink" title="并发编的挑战"></a>并发编的挑战</h1><h2 id="上下文切换（并行不一定比串行快）"><a href="#上下文切换（并行不一定比串行快）" class="headerlink" title="上下文切换（并行不一定比串行快）"></a>上下文切换（并行不一定比串行快）</h2><p>时间片是CPU分配给各个线程的时间，一般是几十毫秒。因为时间片非常短，所以CPU通过不停地切换线程执行，达到多个线程同时执行的效果</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换</p>
<p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程</p>
<p>无锁并发编程：如将数据的ID按照Hash算法取模分段，不同的线程处理不同的段的数据</p>
<p>CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁</p>
<p>使用最少线程：避免创建不需要的线程</p>
<p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>锁是个非常有用的工具，运用场景非常多。但同时它也会带来一些困扰，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。</p>
<p>避免死锁的常用方法</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定向锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必现在一个数据库连接池里，否则会出现解锁失败的现象</li>
</ul>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件或软件资源。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU处理速度。软件资源限制有数据库的连接数和socket连接数等。<br>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源复用。需要根据不同的资源限制调整程序的并发度</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java的并发采用的是共享内存模型，Java线程之间的通讯总是隐式进行，整个通信过程对程序员完全透明。Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入核实对另一个线程可见<br><img src="http://upload-images.jianshu.io/upload_images/5125122-2fb19f7bf25ce364?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>
<li><p>线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：</p>
<p> 把工作内存1中更新过的共享变量刷新到主内存中</p>
<p> 将主内存中最新的共享变量的值更新到工作内存2中</p>
</li>
</ol>
<h1 id="可见性、原子性、重排序"><a href="#可见性、原子性、重排序" class="headerlink" title="可见性、原子性、重排序"></a>可见性、原子性、重排序</h1><p>   可见性：一个线程对共享变量的修改，更够及时的被其他线程看到</p>
<p>   原子性：即不可再分了，不能分为多步操作。比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：</p>
<ol>
<li>　取出a和b</li>
<li>　计算a+b</li>
<li>　将计算结果写入内存</li>
</ol>
<p>重排序：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”</p>
<p> Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> class MyThread extends Thread &#123;             </div><div class="line">    private volatile boolean isStop = false;          </div><div class="line">    public void run() &#123;      </div><div class="line">        while (!isStop) &#123;      </div><div class="line">            System.out.println(&quot;do something&quot;);      </div><div class="line">        &#125;      </div><div class="line">    &#125;      </div><div class="line">    public void setStop() &#123;      </div><div class="line">        isStop = true;      </div><div class="line">    &#125;            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 线程执行run()的时候我们需要在线程中不停的做一些事情，比如while循环，那么这时候该如何停止线程呢？如果线程做的事情不是耗时的，那么只需要使用一个标志即可。如果需要退出时，调用setStop()即可。这里就使用了关键字volatile，这个关键字的目的是如果修改了isStop的值，那么在while循环中可以立即读取到修改后的值</p>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Synchronized在JVM的实现原理，主要是使用了monitorenter和monitorexit指令实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证整个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且有一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁</p>
<p>synchronized用的锁是存在Java对象头里面的。Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化<br>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-cdeffbbfe86e5c74?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<table>
<thead>
<tr>
<th>锁</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex互斥的功能，它还负责实现了Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody>
</table>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p> synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 </li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 </li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
<li>synchronized关键字不能继承</li>
</ul>
<p>## </p>
<h2 id="Synchronized和Volatile的比较"><a href="#Synchronized和Volatile的比较" class="headerlink" title="Synchronized和Volatile的比较"></a>Synchronized和Volatile的比较</h2><ol>
<li>Synchronized保证内存可见性和操作的原子性</li>
<li>Volatile只能保证内存可见性</li>
<li>Volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）</li>
<li>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）.</li>
<li>volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/guyuealian/article/details/52525724" target="_blank" rel="external">内存可见性和原子性：Synchronized和Volatile的比较</a></p>
<p><a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="external">Java中Synchronized的用法</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/14/Android程序员，你应该知道的设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/14/Android程序员，你应该知道的设计模式/" itemprop="url">
                  Android程序员，你应该知道的设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T09:32:54+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/14/Android程序员，你应该知道的设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/14/Android程序员，你应该知道的设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://upload-images.jianshu.io/upload_images/5125122-d59992dd7add23e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自百度搜索"></p>
<p>设计模式这个东西，听起来很玄乎。有时候看起来似懂非懂。平时编码中可能大部分也没考虑应该用怎样的设计来编码。</p>
<p>如果你是一个外包的人员，干完就撤。有可能确实不需要用到什么设计模式，满足功能则可。如果你是一个有产品迭代的开发人员或者代码维护人员。也许你有过背后吐槽这代码真是乱得可以，干不动了的经验。</p>
<p>在应用的开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护中让应用系统能够拥抱变化。拥抱变化也就是意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了各版本的变更之后依旧保持清晰、灵活、稳定的系统架构。</p>
<p>虽然在实际的应该开发中，要饱受产品的折磨和摧残、需要在极其有限的研发时间里完成功能、上线。为了赶工，这里Copy一份代码，哪里黏贴一个类。如果有多个项目，甚至经常在这个项目挪点功能，那个项目移植个模块，到最后干不动了，苦的还是自己。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-df5cd619b5875553?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>排除一切不可抗力因素，我们还是需要保持良好的编码习惯，在动手编码前多思考，尽量让结构更加灵活、低耦合。本文主要是对一些编码的设计原则及设计模式进行整理，便于学习及复习。</p>
<h1 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h1><table>
<thead>
<tr>
<th>原则</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一责任原则</td>
<td>就一个类而言，应该只有一个引起变化的原因</td>
<td>责任界限比较难划分，尽量满足单一责任原则。接口一定要做到单一责任原则，类的设计尽量做到只有一个引起变化的原因</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>所有引用父类的地方，必要能透明的使用其子类</td>
<td>在项目中，采用里氏替换原则，应尽量避免子类的个性（拥有自己的业务实现方法）</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</td>
<td>每个类尽量都有接口或抽象类，或者抽象类和两者都具备，任何类尽量都不应该从具体的类派生</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</td>
<td>每个类尽量都有接口或抽象类，或者抽象类和两者都具备，任何类尽量都不应该从具体的类派生</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上</td>
<td>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口和原子类来组织</td>
</tr>
<tr>
<td>迪米特原则</td>
<td>一个对象应该对自己需要耦合或调用的类知道最少，尽量不要对外公布太多的public方法和非静态的public变量</td>
<td>迪米特法则的核心观念就是类间解耦，提高类的复用率，可能产生大量的中转或者跳转类，导致系统的复杂性提高</td>
</tr>
<tr>
<td>开放封闭原则</td>
<td>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的</td>
<td>通过接口或者抽象类约束扩展，封装变化，对扩展进行边界开放</td>
</tr>
</tbody>
</table>
<p>详细可参考：<a href="http://huangjunbin.com/2017/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" target="_blank" rel="external">设计模式-面向对象的六大设计原则</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="代码中常用的设计模式"><a href="#代码中常用的设计模式" class="headerlink" title="代码中常用的设计模式"></a>代码中常用的设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>例子</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>单例模式</td>
<td>确保某一个类只有一个实例，而且自行示例化并向整个系统提供这个实例。确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源</td>
<td>实际开发中，好多数据库Dao操作、或者Service都是直接采用单例的方式，应注意线程安全及内存泄漏问题</td>
<td><a href="http://huangjunbin.com/2017/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">单例模式 </a></td>
</tr>
<tr>
<td>建造者模式</td>
<td>Builder模式是一步一步创建一个复制对象的创建型模式，他允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程</td>
<td>new AlertDialog.Builder(self).setTitle(“列表框”).setItems(new String[] {“列表项1”,”列表项2”,”列表项3”}, null).setNegativeButton(“确定”, null) .show();有时候Activity的启动构造参数复杂，也可使用Builder模式进行控制</td>
<td><a href="http://huangjunbin.com/2017/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">建造者模式</a></td>
</tr>
<tr>
<td>适配器模式</td>
<td>适配器模式把一个类在接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作</td>
<td>ListView作为重要的控件，它需要能够显示各种各样的视图（ItemView），每个人需要的显示效果各不同。Android的做法是增加一个Adapter层来隔离变化，将ListView需要的关于Item View接口抽象到Adapter对象中，并且在ListView内部调用Adapter这些接口完成布局操作。这样只用用户实现了Adapter的接口，并且将该Adapter设置给ListView，ListView就可以按照用户设定的UI效果、数量、数据来显示每一项数据</td>
<td><a href="http://huangjunbin.com/2017/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">适配器模式</a></td>
</tr>
<tr>
<td>观察者模式</td>
<td>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统，订阅-发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小</td>
<td>广播、EventBus、Rxjava，一些上传下载进度回调监听</td>
<td><a href="http://huangjunbin.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">观察者模式 </a></td>
</tr>
<tr>
<td>外观模式</td>
<td>外观模式（Facade）在开发过程中的运用频率非常高，尤其是在现阶段各个第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式，通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节</td>
<td>例如Context统一了很多系统资源的范围，实际开发过程中使用的图片库、网络库等，提供统一的Facade，避免更换影响全局</td>
<td><a href="http://huangjunbin.com/2017/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">外观模式 </a></td>
</tr>
</tbody>
</table>
<h2 id="经常用但却不知道的设计模式"><a href="#经常用但却不知道的设计模式" class="headerlink" title="经常用但却不知道的设计模式"></a>经常用但却不知道的设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>例子</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>模板模式</td>
<td>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td>
<td>AsyncTask，在使用AsyncTask时，我们都知道把耗时的方法放在doInBackground（Params… params）中，在doInBackground之前，如果还想做一些类似初始化的操作，可以把实现卸载onPreExecutre方法中，当doInBackground方法执行完成后，会执行onPostExecutre方法</td>
<td><a href="http://huangjunbin.com/2017/01/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">模板模式 </a></td>
</tr>
<tr>
<td>中介者模式</td>
<td>该模式将对象之间的多对多关系变成一对多关系</td>
<td>Android的Activity实际就是一个中介者模式，形形式式的View交互都在Activity中统一执行，View之间彼此不交互（你有可能点一个Button,让一个ImageView变化图片，但这个逻辑不会写在Button中）</td>
<td><a href="http://huangjunbin.com/2017/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">中介者模式 </a></td>
</tr>
<tr>
<td>责任链模式</td>
<td>责任链模式是行为型设计模式之一。使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</td>
<td>在Android源码中比较类似的实现就是对于触摸事件的分发处理。每当用户接触屏幕时，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下地分发传递。ViewGroup事件投递的递归调用就类似于一条责任链，一旦寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现在View的onTouchEvent方法中返回值的设置，如果onTouchEvent返回false，那么意味着当前View不会是该次事件的复制人，将不会对其持有；如果为true则相反，此时View会持有该事件并不再向外传递</td>
<td><a href="http://huangjunbin.com/2017/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">责任链模式 </a></td>
</tr>
<tr>
<td>装饰模式</td>
<td>装饰模式也称为包装模式，结构型设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。动态地给一个对象添加一些额外的职责</td>
<td>Context类本身是一个纯abstract类，他有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象</td>
<td><a href="http://huangjunbin.com/2017/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">装饰模式 </a></td>
</tr>
<tr>
<td>组合模式</td>
<td>组合模式也称为部分整体模式，结构型设计模式之一，组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象</td>
<td>Android源码中关于组合模式有一个非常经典的实现，我们几乎每天都会使用到，那就是View和ViewGroup的嵌套组合</td>
<td><a href="http://huangjunbin.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">组合模式 </a></td>
</tr>
<tr>
<td>备忘录模式</td>
<td>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露</td>
<td>在Android开发中，状态模式应用是Android中的状态保持，也就是里面的onSaveInstanceState和onRestoreInstanceState。当Activity不是正常方式退出，且Activity在随后的时间内被系统杀死之前会调用这两个方法让开发人员可以有机会存储Activity的相关信息，并且在下次放好Activity的时候恢复这些数据</td>
<td><a href="http://huangjunbin.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">备忘录模式 </a></td>
</tr>
<tr>
<td>享元模式</td>
<td>享元模式是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</td>
<td>数据库链接池、长连接池</td>
<td><a href="http://huangjunbin.com/2017/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">享元模式 </a></td>
</tr>
<tr>
<td>迭代器模式</td>
<td>迭代器模式提供一种方法顺序访问一个容器对象的各个元素，而又不需要暴露该对象的内部表示</td>
<td>JDK中各种集合的遍历</td>
<td><a href="http://huangjunbin.com/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">迭代器模式</a></td>
</tr>
</tbody>
</table>
<h2 id="其他设计模式"><a href="#其他设计模式" class="headerlink" title="其他设计模式"></a>其他设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>工厂模式</td>
<td>工厂模式是创建型设计模式之一。定义一个用户创建对象的接口，让子类决定实例化那个类。工厂模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用</td>
<td><a href="http://huangjunbin.com/2017/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">工厂模式</a></td>
</tr>
<tr>
<td>抽象工厂模式</td>
<td>抽象工厂也是创建型设计模式之一。为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体类。一个对象族有相同约束时可以使用抽象工厂模式</td>
<td><a href="http://huangjunbin.com/2017/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">抽象工厂模式</a></td>
</tr>
<tr>
<td>代理模式</td>
<td>为其他对象提供一种代理以控制对这个对象的访问，有静态代码和动态代理</td>
<td><a href="http://huangjunbin.com/2017/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">代理模式</a></td>
</tr>
<tr>
<td>原型模式</td>
<td>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</td>
<td><a href="http://huangjunbin.com/2017/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">原型模式</a></td>
</tr>
<tr>
<td>策略模式</td>
<td>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化</td>
<td><a href="http://huangjunbin.com/2017/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">策略模式</a></td>
</tr>
<tr>
<td>访问者模式</td>
<td>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</td>
<td><a href="http://huangjunbin.com/2017/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">访问者模式</a></td>
</tr>
<tr>
<td>状态模式</td>
<td>状态模式中的行为是由状态来决定的，不同的状态下又不同的行为。状态模式和策略模式的结构几乎完全一样，但他们的目的，本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、互相替换的</td>
<td><a href="http://huangjunbin.com/2017/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">状态模式</a></td>
</tr>
<tr>
<td>解释器模式</td>
<td>解释器模式是一种用得比较少的行为模式，其提供了一种解释语言的语法或表达式的方式，该模式定义了一个表达式接口，通过该接口解释一个特定的上下文</td>
<td><a href="http://huangjunbin.com/2017/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">解释器模式</a></td>
</tr>
<tr>
<td>桥梁模式</td>
<td>桥梁模式也称为桥接模式，是结构型设计模式之一。将抽象和实现解耦，使得两者可以独立地变化</td>
<td><a href="http://huangjunbin.com/2017/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">桥梁模式</a></td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="装饰模式、代理模式、外观模式区别"><a href="#装饰模式、代理模式、外观模式区别" class="headerlink" title="装饰模式、代理模式、外观模式区别"></a>装饰模式、代理模式、外观模式区别</h2><p>代理模式注重的是隔离限制，关注于控制对对象的访问，让外部不能访问你实际的调用对象，比如权限控制。代理和真实对象之间的的关系通常在编译时就已经确定了。<br>装饰模式注重的是功能的拓展，关注于在一个对象上动态的添加方法，在同一个方法下实现更多的功能。装饰者能够在运行时递归地被构造。<br>适配器模式注重的是接口的兼容。<br>外观模式注重的是多个类的集成、统一适配。</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《设计模式之禅》<br>《Android源码设计模式解析与实战》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/12/你应该知道的JDK知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/12/你应该知道的JDK知识/" itemprop="url">
                  你应该知道的JDK知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T09:28:33+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/12/你应该知道的JDK知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/12/你应该知道的JDK知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无论是从事Javaee开发或者是Android开发，JDK的基础知识都尤为重要。我们在代码里经常使用ArrayList、HashMap等，但却很少思考为什么是使用它，使用的时候需要注意什么。甚至有可能去面试的时候，人家一问HashMap的实现原理，但却只知道put和get，非常尴尬。</p>
<p>所以为了开发更高质量的程序，写出更优秀的代码，还是需要好好研究一下JDK的一些关键源码。本文主要对JDK进行一些重要的的知识的梳理及整理，便于学习及复习。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位</th>
<th>默认值 </th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8(1字节)</td>
<td>0 </td>
</tr>
<tr>
<td>short</td>
<td>16(2字节)</td>
<td>0 </td>
</tr>
<tr>
<td>int</td>
<td>32(4字节)</td>
<td>0 </td>
</tr>
<tr>
<td>long</td>
<td>64(8字节)</td>
<td>0L </td>
</tr>
<tr>
<td>float</td>
<td>32(4字节)</td>
<td>0.0f </td>
</tr>
<tr>
<td>double</td>
<td>64(8字节)</td>
<td>0.0d </td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>false </td>
</tr>
<tr>
<td>char</td>
<td>16 位 Unicode 字符</td>
<td>“” </td>
</tr>
</tbody>
</table>
<h2 id="equal-hashcode-的区别"><a href="#equal-hashcode-的区别" class="headerlink" title="equal hashcode ==的区别"></a>equal hashcode ==的区别</h2><table>
<thead>
<tr>
<th>==</th>
<th>内存地址比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>equal</td>
<td>Object默认内存地址比较，一般需要复写</td>
</tr>
<tr>
<td>hashcode</td>
<td>主要用于集合的散列表，Object默认为内存地址，一般不用设置，除非作用于散列集合。</td>
</tr>
</tbody>
</table>
<p>hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。当equals方法被重写时，通常有必要重写 hashCode 方法。但hashCode相等，不一定equals（）</p>
<h2 id="String、StringBuffer与StringBuilder的区别。"><a href="#String、StringBuffer与StringBuilder的区别。" class="headerlink" title="String、StringBuffer与StringBuilder的区别。"></a>String、StringBuffer与StringBuilder的区别。</h2><p>Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。</p>
<h1 id="Java的四种引用，强弱软虚，用到的场景。"><a href="#Java的四种引用，强弱软虚，用到的场景。" class="headerlink" title="Java的四种引用，强弱软虚，用到的场景。"></a>Java的四种引用，强弱软虚，用到的场景。</h1><p>JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.</p>
<p>强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。</p>
<p>软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null</p>
<p>弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同</p>
<p>虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有</p>
<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><p><img src="http://upload-images.jianshu.io/upload_images/5125122-32995bf94f0f4f7a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java 集合类结构图"></p>
<p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>
<p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>
<p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。 我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>
<p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>
<p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>
<p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>
<h2 id="Collection-List-Set-Map-区别"><a href="#Collection-List-Set-Map-区别" class="headerlink" title="Collection List Set Map 区别"></a>Collection List Set Map 区别</h2><table>
<thead>
<tr>
<th>接口</th>
<th>是否有序</th>
<th>允许元素重复</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>List</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>AbstractSet</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>HashSet</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>TreeSet</td>
<td>是（用二叉树排序）</td>
<td>否</td>
</tr>
<tr>
<td>AbstractMap</td>
<td>否</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td>HashMap</td>
<td>否</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td>TreeMap</td>
<td>是（用二叉树排序）</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value  </td>
</tr>
</tbody>
</table>
<h2 id="常用集合分析"><a href="#常用集合分析" class="headerlink" title="常用集合分析"></a>常用集合分析</h2><table>
<thead>
<tr>
<th>集合</th>
<th>主要算法</th>
<th>源码分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>基于数组的List，封装了动态增长的Object[] 数组</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-ArrayList%E3%80%81Vector/" target="_blank" rel="external">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-ArrayList%E3%80%81Vector/</a></td>
</tr>
<tr>
<td>Stack</td>
<td>是Vector 的子类，栈 的结构（后进先出）</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-Stack/" target="_blank" rel="external">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-Stack/</a></td>
</tr>
<tr>
<td>LinkedList</td>
<td>实现List，Deque；实现List，可以进行队列操作，可以通过索引来随机访问集合元素；实现Deque，也可当作双端队列，也可当作栈来使用</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-LinkedList/" target="_blank" rel="external">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-LinkedList/</a></td>
</tr>
<tr>
<td>HashMap</td>
<td>基于哈希表的 Map 接口的实现, 使用顺序存储及链式存储的结构</td>
<td><a href="http://huangjunbin.com/2016/11/24/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9B%86%E5%90%88-HashMap%E3%80%81HashTable/" target="_blank" rel="external">http://huangjunbin.com/2016/11/24/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9B%86%E5%90%88-HashMap%E3%80%81HashTable/</a></td>
</tr>
<tr>
<td> LinkedHashMap</td>
<td>LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同</td>
<td><a href="https://github.com/francistao/LearningNotes/blob/master/Part2/JavaSE/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md" target="_blank" rel="external">https://github.com/francistao/LearningNotes/blob/master/Part2/JavaSE/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md</a></td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMap的实现是红黑树算法的实现，支持排序</td>
<td><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/26668941</a></td>
</tr>
</tbody>
</table>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>Lists</strong>    </p>
<ul>
<li>ArrayList——基于泛型数组</li>
<li>LinkedList——不推荐使用</li>
<li>Vector——已废弃（deprecated）</li>
</ul>
<p>CopyOnWriteArrayList——几乎不更新，常用来遍历</p>
<p><strong>Queues / deques</strong></p>
<ul>
<li>ArrayDeque——基于泛型数组</li>
<li>Stack——已废弃（deprecated）</li>
<li>PriorityQueue——读取操作的内容已排序</li>
</ul>
<ul>
<li>ArrayBlockingQueue——带边界的阻塞式队列</li>
<li>ConcurrentLinkedDeque / ConcurrentLinkedQueue——无边界的链表队列（CAS）</li>
<li>DelayQueue——元素带有延迟的队列</li>
<li>LinkedBlockingDeque / LinkedBlockingQueue——链表队列（带锁），可设定是否带边界</li>
<li>LinkedTransferQueue——可将元素<code>transfer</code>进行w/o存储</li>
<li>PriorityBlockingQueue——并发PriorityQueue</li>
<li>SynchronousQueue——使用Queue接口进行Exchanger</li>
</ul>
<p><strong>Maps</strong></p>
<ul>
<li>HashMap——通用Map</li>
<li>EnumMap——键使用enum</li>
<li>Hashtable——已废弃（deprecated）</li>
<li>IdentityHashMap——键使用==进行比较</li>
<li>LinkedHashMap——保持插入顺序</li>
<li>TreeMap——键已排序</li>
<li>WeakHashMap——适用于缓存（cache）</li>
</ul>
<ul>
<li>ConcurrentHashMap——通用并发Map</li>
<li>ConcurrentSkipListMap——已排序的并发Map</li>
</ul>
<p><strong>Sets</strong>    </p>
<ul>
<li>HashSet——通用set</li>
<li>EnumSet——enum Set</li>
<li>BitSet——比特或密集的整数Set</li>
<li>LinkedHashSet——保持插入顺序</li>
<li>TreeSet——排序Set</li>
</ul>
<ul>
<li>ConcurrentSkipListSet——排序并发Set</li>
<li>CopyOnWriteArraySet——几乎不更新，通常只做遍历</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Set的选择</strong></p>
<ol>
<li>HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</li>
<li>对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</li>
<li>EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</li>
<li>HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。<br>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…));</li>
</ol>
<p><strong>List 选择</strong></p>
<ol>
<li>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</li>
<li>Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)</li>
<li>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</li>
<li>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</li>
<li>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</li>
<li>当要大量的插入，删除，应当选用LinkedList；当需要快速随机访问则选用ArrayList;</li>
</ol>
<p><strong>Map 的选择</strong></p>
<ol>
<li>HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</li>
<li>TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</li>
<li>使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</li>
<li>HahMap 是利用hashCode 进行查找，而TreeMap 是保持者某种有序状态</li>
<li>所以，插入，删除，定位操作时，HashMap 是最好的选择；如果要按照自然排序或者自定义排序，那么就选择TreeMap</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.imooc.com/article/1080" target="_blank" rel="external">Java 学习之集合类（Collections）</a></p>
<p><a href="http://www.importnew.com/13801.html" target="_blank" rel="external">Java集合总览</a></p>
<p><a href="https://github.com/francistao/LearningNotes/tree/master/Part2/JavaSE" target="_blank" rel="external">JavaSE(Java基础)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/08/23/程序员，30而立。你是否觉得迷茫？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/23/程序员，30而立。你是否觉得迷茫？/" itemprop="url">
                  程序员，30而立。你是否觉得迷茫？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T18:03:02+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/23/程序员，30而立。你是否觉得迷茫？/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/23/程序员，30而立。你是否觉得迷茫？/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在程序员这个圈子，一直都有一种说法，程序员都是吃青春饭的。这个团体中，很多到了30岁，或者还没有到30岁的幵发者对以后的发展便感到了迷茫，当然也有可能有人没有思考过这个问题。<br>30岁了，你可能面临娶妻生子、面临房贷车贷；30岁了，你需要面临竞争、面临选择，面临日新月异的技术。当你觉得迷茫的时候，又当何去何从？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-9bf456e56c68e5b6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="转变你的想法"><a href="#转变你的想法" class="headerlink" title="转变你的想法"></a>转变你的想法</h2><h3 id="危机感"><a href="#危机感" class="headerlink" title="危机感"></a>危机感</h3><p>也许当你感到迷茫的时候，是一件好事。证明自己也是有危机感，而不是浑浑噩噩。意识到危机，才能有更好的动力去规划及调整。作为一个程序员，安安逸逸，朝九晚五，肯定是有问题的。而我们常常在一家公司久了，也容易变得温水煮青蛙，每天上班干好自己的本职工作，然后就这样日复一日。渐渐的，迷茫也就随之而来了</p>
<h3 id="为自己而工作"><a href="#为自己而工作" class="headerlink" title="为自己而工作"></a>为自己而工作</h3><p>可能有大部分人会犯一个很严重的问题。那就是认为一直都是在为公司而工作。其实每个人应该都是为自己而工作。基本没有一个人在一家公司一直长久的待着，也没有公司愿意为一个没有贡献的员工一直支付酬劳，尽管你可能是老员工了。对于自己，应该时刻让自己保持竞争力，这样才是最重要的。我们应该思考如何去提升自己的技能、如何在工作中更好的成长、如何做出更优秀的产品。</p>
<h2 id="从现在开始"><a href="#从现在开始" class="headerlink" title="从现在开始"></a>从现在开始</h2><h3 id="分析自己的不足"><a href="#分析自己的不足" class="headerlink" title="分析自己的不足"></a>分析自己的不足</h3><p>科学合理的安排自己的学习计划，根据自身的技术栈及不足进行补充，才能有效的提升自己。</p>
<p>如自身基础知识较为薄弱，可能需要计划补充基础的算法、数据结构、计算机原理、网络通信、英语等知识。</p>
<p>如技术深度不够，每天都只是重复的堆砌API，那么可能需要深入学习系统源码、框架源码、性能优化等知识</p>
<p>如沟通及人际关系的处理，作为程序员，整天与机器打交道，往往忽视了自己的沟通及人际关系，一个项目有时不止是技术才能解决问题</p>
<p>如技术广度不够，需要及时了解及掌握业内新的技术点</p>
<p>总结下来，就是需要先找出自己的不足，这是开始最重要的一步</p>
<h3 id="制度计划"><a href="#制度计划" class="headerlink" title="制度计划"></a>制度计划</h3><p>技术零零散散，永远都学不完。需要根据自己的发展规划，有意识来补充自己的短板。</p>
<p>所以有一个清晰的目标非常重要。基础的知识，作为必备要素，是需要每天进行点滴积累才能有明显的效果。然而相关的技术栈则需要有所取舍。</p>
<p>所以我们需要制定一个长期的计划及阶段的计划。分清楚那些技能是需要每天持之以恒，点滴积累，例如一些基础知识的积累。那些是阶段性攻坚可以有成果的。制定年度计划、月度计划、每周计划，来补足自己的短板。</p>
<h3 id="总结与输出"><a href="#总结与输出" class="headerlink" title="总结与输出"></a>总结与输出</h3><p>其实可能大部分人都有一种经历，就是看一本书或者学一项技能，可能过段时间就遗忘了。所以有了学习计划，为了更好的巩固，我们需要阶段性进行总结。</p>
<ol>
<li>笔记：无论是看书或者自己学习一些博客，都可以将一些重点及精华的部分做为自己的笔记，可以更好的理解及便于复习</li>
<li>博客：长期坚持写博客，可以更好的升华自己的笔记，同时也做为对自己学习的一项监督，给自己定一个目标，例如每周一篇。</li>
<li>应用：将学习的新技能及知识，找到契合点，应用到自己的项目中。也可以尝试自己开源一些示例、库等</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>也许有段时间你会松懈了，但及时的调整很重要。</p>
<p>坚持可能是一辈子的事情，放弃却是一瞬间。</p>
<p>30岁了，可能也不知道自己是否会迷茫，但最起码每天保持好的学习状态，可以让自己更加充实，不会有遗憾。</p>
<p>也许当每天都在进步，每天都在成长，迷茫也就随着而去吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/12/Android性能优化-电量优化/" itemprop="url">
                  Android性能优化-电量优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T16:40:55+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/12/Android性能优化-电量优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/12/Android性能优化-电量优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：</p>
<ol>
<li>移动设备，不能一直使用电源供电，且电池容量有限</li>
<li>对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高</li>
</ol>
<blockquote>
<p>曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡了个觉。起床发现电量只充满了70-80%，然后… …<br>最后发现是一个重要原因由于内测版本的长连接开启了日志记录，频繁的进行IO操作引起.<br>这个时候你还不能狡辩了，因为用户最简单能通过系统设置来查看应用的耗电量排名。</p>
</blockquote>
<p>在电子编程世界，这种硬件消耗电量 来执行任务的过程，叫做超时电流消耗，<br>任何电子编程专业的人都会告诉你，你的设备的各项活动在相同时间内，消耗的电量是不同的。比如，很多手机号称待机好几天，这个确实是真的，不过就是使用飞行模式放在家里什么都不干，确实可以甚至可以坚持10多天。但是我们一旦使用它，比如使用蜂窝式无线数据交换(3G4G)、屏幕保持唤醒状态等。作为开发者，我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情（所以很多设备都把这个监测电量的功能阉割掉了。）。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-f3d81d33d585aa7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google电量优化-示例图"></p>
<h1 id="手机那些地方最耗电？"><a href="#手机那些地方最耗电？" class="headerlink" title="手机那些地方最耗电？"></a>手机那些地方最耗电？</h1><h2 id="唤醒屏幕"><a href="#唤醒屏幕" class="headerlink" title="唤醒屏幕"></a>唤醒屏幕</h2><p>当用户电量屏幕的时候，意味着系统的各组件要开始进行工作，界面也需要开始执行渲染。</p>
<p>待机状态的电量消耗：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-c9a590b400a4a292?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用和唤醒屏幕后：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5be155e7a92274b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当设备从休眠状态中，被应用程序假面唤醒时，你会看到在第一次唤醒时，这里有一条电量使用高峰线</p>
<h2 id="CPU唤醒使用"><a href="#CPU唤醒使用" class="headerlink" title="CPU唤醒使用"></a>CPU唤醒使用</h2><p>CUP唤醒时的高峰线：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-e7c2717bc74a7d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来就是后续的一些执行的消耗了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-1be98683a95ee9a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量</p>
<h2 id="蜂窝式无线"><a href="#蜂窝式无线" class="headerlink" title="蜂窝式无线"></a>蜂窝式无线</h2><p>当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。接下来还有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6ddb4cbc82b1a33a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>
<ul>
<li>Full power: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li>Low power: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li>Standby: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>
<h1 id="如何进行电量使用分析？"><a href="#如何进行电量使用分析？" class="headerlink" title="如何进行电量使用分析？"></a>如何进行电量使用分析？</h1><p>电量使用优化, 基本上是我们最不怎么关注的一项优化。可能很多公司连QA/Tester也不会关注测试App电量的使用。一般来说开发和测试的测试设备也一直是连着USB处于充电状态的,感官上也体会不到电量的损耗。要进行电量优化，我们首先得知道电都消耗到那里去了，不然如何进行针对性的优化呢？答案是通过google开源的Battery Historian来进行分析。</p>
<h2 id="电量数据收集"><a href="#电量数据收集" class="headerlink" title="电量数据收集"></a>电量数据收集</h2><p>Android 5.0及以上的设备, 允许我们通过adb命令dump出电量使用统计信息.</p>
<ol>
<li><p>因为电量统计数据是持续的, 会非常大, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ adb shell dumpsys batterystats --reset</div><div class="line">Battery stats reset.</div></pre></td></tr></table></figure>
</li>
<li><p>断开测试设备, 操作我们的待测试App.</p>
</li>
<li>重新连接设备, 使用adb命令导出相关统计数据:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.</div><div class="line">$ adb bugreport &gt; bugreport.txt</div></pre></td></tr></table></figure>
<p>导出的统计数据存储到bugreport.txt, 此时我们可以借助如下工具来图形化展示电池的消耗情况.</p>
<blockquote>
<p>注意, 官方SDK文档导出文件方式为:<br>adb shell dumpsys batterystats &gt; batterystats.txt<br>使用python historian.py batterystats.txt &gt; batterystats.html查看数据<br>是battery-historian老版本的使用方式. 目前Battery Historian已更新2.0版本, 推荐使用bugreport方式导出数据分析, 可以看到更多信息.</p>
</blockquote>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>工具开源地址: <a href="https://github.com/google/battery-historian" target="_blank" rel="external">Battery Historian</a></p>
<p>根据gitbub上面介绍，Battery History工具的安装有两种方式：</p>
<ol>
<li>通过安装Docker环境来安装。（这种方式很简单，Docker真心好用，太彪悍了！）<br>Docker是一种容器，一般用于云计算和大数据平台。提倡的一种思想就是：软件即服务。这句话不是盖的，一句话就可以将别人发布的docker服务环境一次全部copy过来(注意是整个软件环境哦，相当于复制了一台一模一样的主机，连软件都不要安装了，全有了。彪悍吧！)<br>Docker只支持Windows10</li>
</ol>
<blockquote>
<p>由于笔者使用的window，无法通过Docker的方式，所以是采用第2点进行安装</p>
</blockquote>
<p>2.通过编译gitbub上面的源码来安装</p>
<p>这真是一个虐心的过程，因为Battery History是Go语言开发的。我们需要安装Go环境、Pytho环境、Git环境，并配置好相关的环境变量。具体的软件安装教程就不附上了，这里贴一下工具的下载地址。</p>
<p>Go下载地址：<a href="https://golang.org/doc/install?download=go1.7.3.windows-amd64.msi" target="_blank" rel="external">GO环境安装</a></p>
<p>Python下载地址：<a href="https://www.python.org/" target="_blank" rel="external">Python环境安装</a></p>
<p>Git下载地址：<a href="https://git-scm.com/" target="_blank" rel="external">Git环境安装</a></p>
<blockquote>
<p>需要注意的是, Battery Historian是Go语言的, 安装Go的时候需要配置其bin的环境变量.<br>Python环境需要是2.7的(3.x不行), 建议使用pyenv管理本地的python环境.<br>另外, 因为Battery Historian是一个网页版工具, 涉及一些JS引用, 有时需要翻墙.</p>
</blockquote>
<p>安装及成果配置环境变量后</p>
<p>1.输入命令行go get -d -u github.com/google/battery-historian/…<br>**下载到GOPATH配置目录下</p>
<p>2.进入到$GOPATH/src/github.com/google/battery-historian目录下方<br>$ cd $GOPATH/src/github.com/google/battery-historian</p>
<p>3.运行Battery Historian</p>
<p>1） go run setup.go<br>Compile Javascript files using the Closure compiler<br>$ go run setup.go<br>等待数分钟或者10分钟左右，如果仍然没有下载成功，可以手动下载，如下操作<br>**下载【closure-library】和【closure-compiler】和【flot-axislabels】，解压放到GOROOT目录下third_party文件夹下方的的closure-compiler和closure-library和flot-axislabels文件夹 ../battery-historian\third_party；如果没有均手动创建</p>
<p>2）go run cmd/battery-historian/battery-historian.go<br>Run Historian on your machine (make sure $PATH contains $GOBIN)<br>$ go run cmd/battery-historian/battery-historian.go [–port <default:9999>]</default:9999></p>
<p>4.检查/battery-historian是否运行，登录网址 <a href="http://localhost:9999查看" target="_blank" rel="external">http://localhost:9999查看</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-db908127e9e5e7ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>千呼万唤使出来，不容易。这里建议使用Chrome浏览器，并且一定要使用VPN，不然各种莫名的问题</p>
</blockquote>
<h2 id="分析指标"><a href="#分析指标" class="headerlink" title="分析指标"></a>分析指标</h2><p>工具安装完成后，我们将adb采集的数据上传至Battery Historian，就可以得到电量的分析情况。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-8320242fc1011e82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5125122-fb4297e921d3402f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>那么关键来了，这些指标具体代表什么含义呢？这里我们来做一下解释。</p>
<ol>
<li>横坐标 </li>
</ol>
<p>横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取bugreport内容时刻为终点。我们一共采集了多长时间的数据</p>
<ol>
<li>纵坐标</li>
</ol>
<p>关键的数据点我们用表格来汇总一下。</p>
<table>
<thead>
<tr>
<th>数据项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>battery_level</td>
<td>电量，可以看出电量的变化</td>
</tr>
<tr>
<td>plugged</td>
<td>充电状态，这一栏显示是否进行了充电，以及充电的时间范围</td>
</tr>
<tr>
<td>screen</td>
<td>屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息</td>
</tr>
<tr>
<td>top</td>
<td>该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app，用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助</td>
</tr>
<tr>
<td>wake_lock</td>
<td>wake_lock 该属性是记录wake_lock模块的工作时间。是否有停止的时候等</td>
</tr>
<tr>
<td>running</td>
<td>界面的状态，主要判断是否处于idle的状态。用来判断无操作状态下电量的消耗</td>
</tr>
<tr>
<td>Job</td>
<td>后台的工作，比如服务service的运行</td>
</tr>
<tr>
<td>data_conn</td>
<td>数据连接方式的改变，上面的edge是说明采用的gprs的方式连接网络的。此数据可以看出手机是使用2g，3g，4g还是wifi进行数据交换的。这一栏可以看出不同的连接方式对电量使用的影响</td>
</tr>
<tr>
<td>status</td>
<td>电池状态信息，有充电，放电，未充电，已充满，未知等不同状态</td>
</tr>
<tr>
<td>phone_signal_strength</td>
<td>手机信号状态的改变。 这一栏记录手机信号的强弱变化图，依次来判断手机信号对电量的影响</td>
</tr>
<tr>
<td>health</td>
<td>电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间</td>
</tr>
<tr>
<td>plug</td>
<td>充电方式，usb或者插座，以及显示连接的时间</td>
</tr>
<tr>
<td>Sync</td>
<td>是否跟后台同步</td>
</tr>
<tr>
<td>phone_in_call</td>
<td>是否进行通话</td>
</tr>
<tr>
<td>gps</td>
<td>gps是否开启</td>
</tr>
</tbody>
</table>
<h1 id="如何进行电量优化？"><a href="#如何进行电量优化？" class="headerlink" title="如何进行电量优化？"></a>如何进行电量优化？</h1><p>关键的地方来了。了解了手机关键耗电的地方及分析耗电的工具后。接下来就是我们的核心，如何来进行电量的优化呢？首先我们先简单总结汇总一下耗电的相关因素</p>
<ul>
<li>屏幕亮暗相关</li>
<li>设备awake,sleep的切换,尤其是唤醒.</li>
<li>CPU运行相关</li>
<li>网络</li>
<li>传感器</li>
</ul>
<p>我们接下来根据因素来逐一进行优化建议。</p>
<h2 id="点滴积累"><a href="#点滴积累" class="headerlink" title="点滴积累"></a>点滴积累</h2><p>我们都知道屏幕的渲染及CPU的运行是耗电的主要因素之一。所以其实当我们在做内存优化、渲染优化、计算优化的时候，就已然在做电量优化。所以平时的开发中，我们要注意点滴性能的优化积累，实际上当我们来做电量分析的时候，也是在找自己挖的坑。所以尽量有意识在项目的开发过程中尽量少挖坑。所以这一点是我们在分析其他优化项首先要提到的一个点。</p>
<h2 id="监听手机充电状态"><a href="#监听手机充电状态" class="headerlink" title="监听手机充电状态"></a>监听手机充电状态</h2><p>我们可以通过下面的代码来获取手机的当前充电状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// It is very easy to subscribe to changes to the battery state, but you can get the current</div><div class="line">// state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</div><div class="line">IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</div><div class="line">Intent batteryStatus = this.registerReceiver(null, filter);</div><div class="line">int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</div><div class="line">boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</div><div class="line">if (acCharge) &#123;</div><div class="line">    Log.v(LOG_TAG,“The phone is charging!”);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时 才去执行一些非常耗电的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This method checks for power by comparing the current battery state against all possible</div><div class="line"> * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or</div><div class="line"> * wireless charge. (Wireless charge was introduced in API Level 17.)</div><div class="line"> */</div><div class="line">private boolean checkForPower() &#123;</div><div class="line">    // It is very easy to subscribe to changes to the battery state, but you can get the current</div><div class="line">    // state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</div><div class="line">    IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</div><div class="line">    Intent batteryStatus = this.registerReceiver(null, filter);</div><div class="line"></div><div class="line">    // There are currently three ways a device can be plugged in. We should check them all.</div><div class="line">    int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</div><div class="line">    boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);</div><div class="line">    boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</div><div class="line">    boolean wirelessCharge = false;</div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</div><div class="line">        wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);</div><div class="line">    &#125;</div><div class="line">    return (usbCharge || acCharge || wirelessCharge);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里我们就需要思考，根据我们自己的业务，那些为了省电，可以放当手机插上电源的时候去做。<br>往往这样的情况非常多。像这些不需要及时地和用户交互的操作可以放到后面处理。<br>比如：360手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人等到云端；再比如我们自己的APP，其中有一块业务是相册备份，这个时候有一个选项控制让用户选择是否在低于15%的电量时还继续进行备份，从而避免当用户手机低电量时，任然继续进行耗电操作。</p>
</blockquote>
<h2 id="屏幕唤醒"><a href="#屏幕唤醒" class="headerlink" title="屏幕唤醒"></a>屏幕唤醒</h2><p>当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。</p>
<p>保持屏幕常亮<br>最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。<br>另一个方式是在布局文件中使用android:keepScreenOn属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:keepScreenOn=&quot;true&quot;&gt;</div><div class="line">    ...</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。使用代码的好处是你允许你在需要的地方关闭屏幕。</p>
<p>注意：一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</p>
<blockquote>
<p>所以这里我们自己的APP需要根据业务来控制好是否保持屏幕常量。比如我们的APP需要支持视频播放。那么在播放的界面需要控制好不熄屏。当退出播放时，当然就没有了这个设置。</p>
</blockquote>
<h2 id="WakeLock"><a href="#WakeLock" class="headerlink" title="WakeLock"></a>WakeLock</h2><p>wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题。<br>需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述的FLAG_KEEP_SCREEN_ON。<br>只有一种合理的使用场景，是在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。 要使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止，这不是我们想要的。</p>
<blockquote>
<p>有的人可能认为我以前写的后台服务就没掉过链子呀运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。</p>
</blockquote>
<p>唤醒锁可划分为并识别四种用户唤醒锁：</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>CPU</th>
<th>屏幕</th>
<th>键盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>开启</td>
<td>关闭</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>开启</td>
<td>变暗</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>关闭</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>变亮</td>
</tr>
</tbody>
</table>
<p>请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。<br>第一步就是添加唤醒锁权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>直接使用唤醒锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);</div><div class="line">WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;MyWakelockTag&quot;);</div><div class="line">wakeLock.acquire();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在使用该类的时候，必须保证acquire和release是成对出现的。不然当我们业务已经不需要时，当CPU处于唤醒状态，这个时候就会损耗多余的电量。</p>
</blockquote>
<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p> 自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobSchedule的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理。这样做有两个好处：</p>
<p>避免频繁的唤醒硬件模块，造成不必要的电量消耗。<br>避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量；<br>JobScheduler的简单使用，首先自定义一个Service类，继承自JobService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class JobSchedulerService extends JobService&#123;</div><div class="line">    private String TAG = JobSchedulerService.class.getSimpleName();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onStartJob(JobParameters jobParameters) &#123;</div><div class="line">        Log.d(TAG, &quot;onStartJob:&quot; + jobParameters.getJobId());</div><div class="line"></div><div class="line">        if(true) &#123;</div><div class="line">            // JobService在主线程运行，如果我们这里需要处理比较耗时的业务逻辑需单独开启一条子线程来处理并返回true，</div><div class="line">            // 当给定的任务完成时通过调用jobFinished(JobParameters params, boolean needsRescheduled)告知系统。</div><div class="line"></div><div class="line">            //假设开启一个线程去下载文件</div><div class="line">            new DownloadTask().execute(jobParameters);</div><div class="line"></div><div class="line">            return true;</div><div class="line"></div><div class="line">        &#125;else &#123;</div><div class="line">            //如果只是在本方法内执行一些简单的逻辑话返回false就可以了</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 比如我们的服务设定的约束条件为在WIFI状态下运行，结果在任务运行的过程中WIFI断开了系统</div><div class="line">     * 就会通过回掉onStopJob()来通知我们停止运行，正常的情况下不会回掉此方法</div><div class="line">     *</div><div class="line">     * @param jobParameters</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean onStopJob(JobParameters jobParameters) &#123;</div><div class="line">        Log.d(TAG, &quot;onStopJob:&quot; + jobParameters.getJobId());</div><div class="line"></div><div class="line">        //如果需要服务在设定的约定条件再次满足时再次执行服务请返回true，反之false</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class DownloadTask extends AsyncTask&lt;JobParameters, Object, Object&gt; &#123;</div><div class="line">        JobParameters mJobParameters;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected Object doInBackground(JobParameters... jobParameterses) &#123;</div><div class="line">            mJobParameters = jobParameterses[0];</div><div class="line"></div><div class="line">            //比如说我们这里处理一个下载任务</div><div class="line">            //或是处理一些比较复杂的运算逻辑</div><div class="line">            //...</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(30*1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected void onPostExecute(Object o) &#123;</div><div class="line">            super.onPostExecute(o);</div><div class="line">            //如果在onStartJob()中返回true的话,处理完成逻辑后一定要执行jobFinished()告知系统已完成，</div><div class="line">            //如果需要重新安排服务请true，反之false</div><div class="line">            jobFinished(mJobParameters, false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>记得在Manifest文件内配置Service <service android:name=".JobSchedulerService" android:permission="android.permission.BIND_JOB_SERVICE"></service></p>
<p>创建工作计划<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">    private JobScheduler mJobScheduler;</div><div class="line">    private final int JOB_ID = 1;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.mai_layout);</div><div class="line"></div><div class="line">        mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE );</div><div class="line"></div><div class="line">        //通过JobInfo.Builder来设定触发服务的约束条件，最少设定一个条件</div><div class="line">        JobInfo.Builder jobBuilder = new JobInfo.Builder(JOB_ID, new ComponentName(this, JobSchedulerService.class));</div><div class="line"></div><div class="line">        //循环触发，设置任务每三秒定期运行一次</div><div class="line">        jobBuilder.setPeriodic(3000);</div><div class="line"></div><div class="line">        //单次定时触发，设置为三秒以后去触发。这是与setPeriodic(long time)不兼容的，</div><div class="line">        // 并且如果同时使用这两个函数将会导致抛出异常。</div><div class="line">        jobBuilder.setMinimumLatency(3000);</div><div class="line"></div><div class="line">        //在约定的时间内设置的条件都没有被触发时三秒以后开始触发。类似于setMinimumLatency(long time)，</div><div class="line">        // 这个函数是与 setPeriodic(long time) 互相排斥的，并且如果同时使用这两个函数，将会导致抛出异常。</div><div class="line">        jobBuilder.setOverrideDeadline(3000);</div><div class="line"></div><div class="line">        //在设备重新启动后设置的触发条件是否还有效</div><div class="line">        jobBuilder.setPersisted(false);</div><div class="line"></div><div class="line">        // 只有在设备处于一种特定的网络状态时，它才触发。</div><div class="line">        // JobInfo.NETWORK_TYPE_NONE,无论是否有网络均可触发，这个是默认值；</div><div class="line">        // JobInfo.NETWORK_TYPE_ANY，有网络连接时就触发；</div><div class="line">        // JobInfo.NETWORK_TYPE_UNMETERED，非蜂窝网络中触发；</div><div class="line">        // JobInfo.NETWORK_TYPE_NOT_ROAMING，非漫游网络时才可触发；</div><div class="line">        jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);</div><div class="line"></div><div class="line">        //设置手机充电状态下触发</div><div class="line">        jobBuilder.setRequiresCharging(true);</div><div class="line"></div><div class="line">        //设置手机处于空闲状态时触发</div><div class="line">        jobBuilder.setRequiresDeviceIdle(true);</div><div class="line"></div><div class="line">        //得到JobInfo对象</div><div class="line">        JobInfo jobInfo = jobBuilder.build();</div><div class="line"></div><div class="line">        //设置开始安排任务，它将返回一个状态码</div><div class="line">        //JobScheduler.RESULT_SUCCESS，成功</div><div class="line">        //JobScheduler.RESULT_FAILURE，失败</div><div class="line">        if (mJobScheduler.schedule(jobInfo) == JobScheduler.RESULT_FAILURE) &#123;</div><div class="line">            //安排任务失败</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //停止指定JobId的工作服务</div><div class="line">        mJobScheduler.cancel(JOB_ID);</div><div class="line">        //停止全部的工作服务</div><div class="line">        mJobScheduler.cancelAll();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h2><h3 id="选择合适的Location-Provider"><a href="#选择合适的Location-Provider" class="headerlink" title="选择合适的Location Provider"></a>选择合适的Location Provider</h3><p>Android系统支持多个Location Provider：</p>
<ul>
<li>GPS_PROVIDER:</li>
</ul>
<p>GPS定位，利用GPS芯片通过卫星获得自己的位置信息。定位精准度高，一般在10米左右，耗电量大；但是在室内，GPS定位基本没用。</p>
<ul>
<li>NETWORK_PROVIDER：</li>
</ul>
<p>网络定位，利用手机基站和WIFI节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或WIF节点信息翻译成位置信息的服务器的能力。</p>
<ul>
<li>PASSIVE_PROVIDER:</li>
</ul>
<p>被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接收到消息后直接读取就可以了。比如如果系统中已经安装了百度地图，高德地图(室内可以实现精确定位)，你只要使用它们定位过后，再使用这种方法在你的程序肯定是可以拿到比较精确的定位信息。</p>
<p>例如你的App只是需要一个粗略的定位那么就不需要使用GPS进行定位，既耗费电量，定位的耗时也久。</p>
<h3 id="及时注销定位监听"><a href="#及时注销定位监听" class="headerlink" title="及时注销定位监听"></a>及时注销定位监听</h3><p>在获取到定位之后或者程序处于后台时，注销定位监听，此时监听GPS传感器相当于执行no-op（无操作指令），用户不会有感知但是却耗电。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void onPause() &#123;</div><div class="line">    super.onPause();</div><div class="line">    locationManager.removeListener(locationListener);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void onResume()&#123;</div><div class="line">    super.onResume();</div><div class="line">    locationManager.requestLocationUpdates(locationManager.getBestProvider(criteria, true),6000,100,locationListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多模块使用定位尽量复用"><a href="#多模块使用定位尽量复用" class="headerlink" title="多模块使用定位尽量复用"></a>多模块使用定位尽量复用</h3><p>多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗；例如：在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。</p>
<h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><p>使用传感器，选择合适的采样率，越高的采样率类型则越费电；</p>
<ul>
<li><p>SENSOR_DELAY_NOMAL (200000微秒)</p>
</li>
<li><p>SENSOR_DELAY_UI (60000微秒)</p>
</li>
<li><p>SENSOR_DELAY_GAME (20000微秒)</p>
</li>
<li><p>SENSOR_DELAY_FASTEST (0微秒)</p>
</li>
</ul>
<p>在后台时注意及时注销传感器监听</p>
<h2 id="Doze-and-App-Standby"><a href="#Doze-and-App-Standby" class="headerlink" title="Doze and App Standby"></a>Doze and App Standby</h2><p>最后提这一点，理论上不是电量优化，而是做电量优化要注意的一个坑。Doze and App Standby是Android 6.0以后，提供了两种省电延长电池寿命的功能。</p>
<p>具体可参考google官方介绍文档。<br><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html</a></p>
<blockquote>
<p>这个东西目前已基本无解，特别是国内的不支持google的GCM。这个地方只能控制让用户授权加入白名单来解除限制。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>
<p><a href="http://www.kancloud.cn/kancloud/android-performance/53235" target="_blank" rel="external">Android性能优化篇(谷歌官方)</a></p>
<p><a href="http://www.jianshu.com/p/5d83d8649c98" target="_blank" rel="external">Android性能优化（九）之不可忽视的电量</a></p>
<p><a href="http://www.jianshu.com/p/ebac88cdf9d6" target="_blank" rel="external">Android应用耗电量分析与优化建议</a></p>
<p>推荐资料(Google方法教程)</p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/index.html" target="_blank" rel="external">官方建议优化的一些方法</a></p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a></p>
<p><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perf" target="_blank" rel="external">Android 7.0新特性对电池管理进一步加强，一些新的变化可能多对我们现有的业务会造成影响需关注</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/08/JVM学习笔记-3-垃圾收集算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/08/JVM学习笔记-3-垃圾收集算法/" itemprop="url">
                  JVM学习笔记(3)-垃圾收集算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-08T14:42:19+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/JVM学习笔记-3-垃圾收集算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/08/JVM学习笔记-3-垃圾收集算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>JVM垃圾收集算法有四种：标记-清除算法、复制算法、标记-整理算法、分代收集算法</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除是最基础的收集算法。算法分为“标记”和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：</p>
<ol>
<li>效率问题，标记和清除两个过程效率都不高</li>
<li>空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程汇总需要分配大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作。其执行的过程如下：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-48b83adf2c09bf67?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题，一种称为复制的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一个块上面，然后再把已使用的内存空间一次清理掉。这样使得每次都是对整个半区域进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动栈顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高。其执行的过程如下：<br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象是98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据，我们没办法保证每次回收都有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（年老代）进行分配担保。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-806c627e99c49a50?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间闷酒需要有额外的空间进行内存分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以年老代一般不能直接选用这种算法。<br>根据年老代的特点，有人提出了另外一种“标记-整理”算法，标记过程任然与“标记-清除”算法一样，但后续步骤不足是直接对可回收对象进行清理，而是让所有的对象都向一段移动，然后直接清理掉端边界以外的内存，“标记-整理”算法其过程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-7fd6a26b4c6c579f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成手机，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/03/JVM学习笔记-内存分配与回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/JVM学习笔记-内存分配与回收/" itemprop="url">
                  JVM学习笔记-内存分配与回收
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:03:11+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/03/JVM学习笔记-内存分配与回收/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/03/JVM学习笔记-内存分配与回收/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们介绍了new一个对象需要经过类加载、内存分配、初始化、对象设置、执行init等操作。那么在我们的代码中，一个对象是怎么样就被回收的呢？我们所知道的当一个对象实例没用被引用持有，就会被GC回收，究竟JVM是怎样来判断一个对象是否被持有引用的呢？下面我们将一一来进行分析。</p>
<h1 id="如何判断对象是否被持有引用？"><a href="#如何判断对象是否被持有引用？" class="headerlink" title="如何判断对象是否被持有引用？"></a>如何判断对象是否被持有引用？</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><ul>
<li>定义：引用计数算法（Reference Counting）:给对象添加一个引用计数器，每当一个地方引用它时，计数器值就+1；当引用失效时，计数器值就-1；任何时刻计数器为0的对象就是不可能被再使用的；</li>
<li>优点：实现简单，判定效率高；微软的COM技术、Python中都使用了Reference Couting算法进行内存管理；</li>
<li>缺点：由于其很难解决对象之间相互循环引用的问题，主流Java虚拟机里面都没有选用Refrence Couting算法来管理内存；<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2>定义：可达性分析（Reachability Analysis）判断对象存活的基本思路：通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-0b5d19574afc5621?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Java语言中，可作为GC Roots对象包括：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中产量引用的对象；</li>
<li>本地方法栈中JNI（即一般的Native方法）引用的对象</li>
</ol>
<h1 id="没有持有引用就会被GC回收么？"><a href="#没有持有引用就会被GC回收么？" class="headerlink" title="没有持有引用就会被GC回收么？"></a>没有持有引用就会被GC回收么？</h1><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，而真正宣告一个对象死亡，至少要经历两次标记过程；如果对象在进行可达性分析后发现没有GC Roots想连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize()方法中执行缓慢，或者发送了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只有重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移除出F-Queue；如果对象这时候还没有逃脱，那就会被GC回收。</p>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>由于不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收的效率。因此JVM采用了分代垃圾回收。在JVM的内存空间中把堆空间分为年老代和年轻代。将大量创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。年轻代中又被分为Eden区、和两个Survivor区。新的对象分配是首先放在Eden区、Survivor区作为Eden区和Old区的缓冲，在Survivor区的对象经历若干次收集任然存活的，就会被转移到年老区。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-7cc47a60fd0e8dc5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>对象的内存分配，主要分配在年轻代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用了哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数配置，接下来将会介绍几条最普遍的内存分配规则。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来存放</p>
<h3 id="长期存活的对象将进入年老代"><a href="#长期存活的对象将进入年老代" class="headerlink" title="长期存活的对象将进入年老代"></a>长期存活的对象将进入年老代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该在年轻代，哪些应该在年老代。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次的GC后任然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中每熬过一次GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>为了能更换地适应不同程序的内存情况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升年老代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入年老代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生MinorGC之前，虚拟机会先检查年老代最大可用的连续空间是否大于年轻代所有对象空间，如果这个条件成立，那么GC可以确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查年老代最大可用的连续空间是否大于历次晋升到年老代的对象的平均大小。如果大于，将尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromotionFailure不允许冒险，那这时也要改为进行一次FullGC</p>
<h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发SMinorGC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li><p>年老代（Tenured）被写满</p>
</li>
<li><p>持久代（Perm）被写满</p>
</li>
<li><p>System.gc()被显示调用</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文主要参考《深入理解Java虚拟机：JVM高级特性与最佳实践》后的学习笔记及总结</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/27/JVM学习笔记-内存管理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/27/JVM学习笔记-内存管理机制/" itemprop="url">
                  JVM学习笔记-内存管理机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T15:31:07+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/27/JVM学习笔记-内存管理机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/27/JVM学习笔记-内存管理机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java与C++之间有一堆由内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 —— 《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-27e80eb1c5c73953.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器只占用了一块比较小的内存空间。</p>
<p>可以看作是当前线程所执行的字节码文件（class）的行号指示器。在虚拟机的世界中，字节码解析器就是通过改变计数器的值来选取下一条执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等，都需要通过程序计数器来实现。</p>
<p>因为处理器在一个确定的时刻只会执行一个线程中的指令，线程切换后，是通过计数器来记录执行痕迹，因而可以看出，程序计数器是每个线程私有的</p>
<p>如果执行的是java方法，那么记录的是正在执行的虚拟机字节码指令的地址的地址，如果是native方法，计数器的值为空（undefined）</p>
<p>这个内存区域是唯一一个在java虚拟机规范中没有规定任务OutOfMemoryError的情况区域</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法都在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和局部变量。变量槽（Variable Slot）是局部变量表的最小单位，没有强制规定大小为32位，虽然32位足够存放大部分类型的数据。一个Slot可以方法boolean、byte、char、short、int、float、reference、和returnAddress 8种类型。其中reference表示对一个对象实例的引用，通过它可以得到对象在java堆中存放的起始地址的索引和该数据所属数据类型的方法区的类型信息。returnAddress则指向一条字节码指令的地址。对于64位的long和double变量而言，虚拟机会为其分配两个连续的slot空间。</p>
<p>虚拟机通过索引定位的方式使用局部变量表。为了节省栈帧空间，局部变量表中的Slot是可以重要的。当离开了某些变量的作用域之后，这些变量对应的Slot就可以交给其他变量使用。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也称为操作栈，是一个后入先出的栈。方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行以后，只有两种方法可以退出当前方法：</p>
<ul>
<li>当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口，一般来说，调用者的PC计数器可以作为返回地址</li>
<li>当执行遇到一次，并且当前方法体内没有得到处理，就会导致方法退出，此时没有返回值，称为异常完成出口，返回地址要通过异常处理器表来确定</li>
</ul>
<p>当方法返回时，可能进行3个操作：</p>
<ul>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值压入调用者调用栈帧的操作数栈</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令</li>
<li></li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地的方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言，使用方式和数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 Sun HotSport虚拟机）直接就把本地方法栈和虚拟机栈合二为一，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集管理器的主要区域。因此很多时候也被称做“GC”堆。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法。所以Java堆中还可以细分为：新生代和老年代：再细致一点的有Eden空间、From Survivor空间、ToSurvivor空间等，从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私用的分配缓冲区。不过无论如何如何划分，都与存放内容无关，无论哪个区域，存储的都任然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>Java堆可以处理物理上不连续的内存空间，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMenoryError异常</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，<br>方法区也叫永久代。在过去（自定义类加载器还不是很常见的时候），类大多是”static”的，很少被卸载或收集，因此被称为“永久的(Permanent)”。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。同时，由于类class是JVM实现的一部分，并不是由应用创建的，所以又被认为是“非堆(non-heap)”内存。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外们还有一项信息是常量池，用于存放编译期生成的各种常量和符合引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了MIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在Java堆和Native堆中来回复制数据</p>
<h1 id="new-一个对象-发生了什么？"><a href="#new-一个对象-发生了什么？" class="headerlink" title="new 一个对象 发生了什么？"></a>new 一个对象 发生了什么？</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来，在语言层面只是使用new关键字，而在虚拟机中，对象的创建又是怎样一个过程呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ec514d3f1620b0c2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li><p>类加载检查<br>虚拟机遇到一条new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符合引用，并且检查这个符合引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p>对象分配内存</p>
</li>
</ol>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。根据Java堆中的内存是否规整，有2种处理方式。</p>
<ul>
<li>指针碰撞(Bump the pointer) </li>
</ul>
<p>Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：Serial、ParNew等收集器。</p>
<ul>
<li>空闲列表(Free List) </li>
</ul>
<p>Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。例如：CMS这种基于Mark-Sweep算法的收集器。</p>
<ol>
<li>并发处理</li>
</ol>
<p>对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。处理方案有2种。</p>
<ul>
<li>同步处理</li>
</ul>
<p>对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p>
<ul>
<li><p>TLAB</p>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。那个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需同步锁定。</p>
</li>
</ul>
<ol>
<li>内存空间初始化</li>
</ol>
<p>虚拟机将分配到的内存空间都初始化为零值（不包括对象头）,如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行。<br>内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<ol>
<li>对象设置</li>
</ol>
<p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。</p>
<ol>
<li>执行init()</li>
</ol>
<p>在上面的工作都完成之后，从虚拟机的角度看，一个新的对象已经产生了。但是从Java程序的角度看，对象的创建才刚刚开始init()方法还没有执行，所有的字段都还是零。</p>
<p>所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行init()方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算产生出来。</p>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p> 对象的内存结构又可以被分为：对象头，实例数据，对象填充。</p>
<ul>
<li>对象头</li>
</ul>
<p>对象头包括两部分信息</p>
<p>第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody>
</table>
<p>第二部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<ul>
<li>实例数据</li>
</ul>
<p>对象真正存储的有效信息，也是在程序代码中定义的各种类型字段内容。无论是从父类继承下来的还是子类定义的，都需要记录下来。 </p>
<ul>
<li>对象填充</li>
</ul>
<p>没有实际意义，仅仅起着占位符的作用。以为对象的大小必须是8字节的整数倍。 </p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于在Java虚拟机规范里面只规定了reference类型是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。  </p>
<ul>
<li>句柄访问</li>
</ul>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4f9fb3059d34d7a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>指针访问对象</li>
</ul>
<p>使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-dfdf9058de2064b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可 观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种 语言、框架中使用句柄来访问的情况也十分常见</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文主要参考《深入理解Java虚拟机：JVM高级特性与最佳实践》后的学习笔记及总结</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/19/Android之Binder底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/Android之Binder底层原理/" itemprop="url">
                  Android之Binder底层原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T08:44:42+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/19/Android之Binder底层原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/19/Android之Binder底层原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h1><p>Binder是Android中特有的一种跨进程通讯的方式。但我们在平时的开发过程中，可能很少用的。而Binder的整个体系结构又尤为复杂，一般很难通过网上的一两篇博客，就能把Binder吃透，我们需要通过源码及Binder的一些架构原理，来进行研究。后面的章节我们将主要通过3个部分来由浅至深来了解Binder。首先我们先看在实际的开发中怎么来实现Binder通讯，接着分析Binder框架的原理，最后结合源码进行分析。</p>
<h2 id="为什么感觉Binder很陌生？"><a href="#为什么感觉Binder很陌生？" class="headerlink" title="为什么感觉Binder很陌生？"></a>为什么感觉Binder很陌生？</h2><ol>
<li>项目业务简单，不涉及多进程通讯</li>
<li>涉及多进程通讯，只简单用AIDL，没深入了解</li>
</ol>
<h2 id="为什么要学习Binder？"><a href="#为什么要学习Binder？" class="headerlink" title="为什么要学习Binder？"></a>为什么要学习Binder？</h2><p>Binder作为Android核心的跨进程通讯方式。如果我们要研究Android的源码，Binder是一道需要跨过去的坎。我们都知道系统的各种服务运行在SystemServer进程中，我们应用与系统的各种交互都涉及到跨进程通讯。</p>
<p>例如最简单的启动一个Activity、启动一个Service。到例如使用系统的网络、硬件、等各种Service，其实都涉及到跨进程通讯。只是系统为我们做好了各种封装调用而已。</p>
<p>所以如果你只希望一直停留在应用层的业务开发，其实你可能一直永远都不知道Binder，但是一旦你开始了解Android的源码，那么你总会与Binder相遇。</p>
<h2 id="Android为什么使用Binder作为主要进程间通讯机制？"><a href="#Android为什么使用Binder作为主要进程间通讯机制？" class="headerlink" title="Android为什么使用Binder作为主要进程间通讯机制？"></a>Android为什么使用Binder作为主要进程间通讯机制？</h2><ol>
<li>安全性：Binder机制从协议本身就支持对通信双方做身份校检，安全性高。传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造</li>
<li>性能：socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信，Binder其实通过Binder驱动在内核区域进行了数据的传输，性能高</li>
</ol>
<h1 id="如何实现一个Binder通讯？"><a href="#如何实现一个Binder通讯？" class="headerlink" title="如何实现一个Binder通讯？"></a>如何实现一个Binder通讯？</h1><ol>
<li>在项目中新建一个aidl</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// IBookManager.aidl</div><div class="line"></div><div class="line">package com.jd.test.myapplication;</div><div class="line">import com.jd.test.myapplication.Book;</div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">interface IBookManager &#123;</div><div class="line">    /**</div><div class="line">     * Demonstrates some basic types that you can use as parameters</div><div class="line">     * and return values in AIDL.</div><div class="line">     */</div><div class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</div><div class="line">            double aDouble, String aString);</div><div class="line"></div><div class="line">    List&lt;Book&gt; getBooks();</div><div class="line"></div><div class="line">    void addBook(in Book book);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个在独立进程的Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=&quot;.BookManagerService&quot;</div><div class="line">            android:process=&quot;:remote&quot;/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class BookManagerService extends Service &#123;</div><div class="line">    private CopyOnWriteArrayList&lt;Book&gt; mBookList=new CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        mBookList.add(new Book(1,&quot;Android&quot;));</div><div class="line">        mBookList.add(new Book(2,&quot;IOS&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Binder mBinder=new IBookManager.Stub()&#123;</div><div class="line">        @Override</div><div class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public List&lt;Book&gt; getBooks() throws RemoteException &#123;</div><div class="line">            return mBookList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void addBook(Book book) throws RemoteException &#123;</div><div class="line">            mBookList.add(book);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return mBinder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>另外一个进程，启用远程的Service，并调用接口方法，进行通讯</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        Intent intent=new Intent(this,BookManagerService.class);</div><div class="line">        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> private ServiceConnection mConnection=new ServiceConnection() &#123;</div><div class="line">     @Override</div><div class="line">     public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</div><div class="line">        IBookManager manager=IBookManager.Stub.asInterface(iBinder);</div><div class="line">         try &#123;</div><div class="line">             List&lt;Book&gt; books=manager.getBooks();</div><div class="line">             System.out.println(&quot;books:&quot;+books);</div><div class="line">         &#125; catch (RemoteException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     @Override</div><div class="line">     public void onServiceDisconnected(ComponentName componentName) &#123;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 只能说so easy。Android提供了优秀的API，使得我们可以很方便的通过AIDL实现进程间的通讯。貌似我们实现了进程间通讯，但是连Binder的身影都没看到，这也就是上面的Binder对很多童鞋都很陌生的原因。</p>
<h1 id="Binder的原理"><a href="#Binder的原理" class="headerlink" title="Binder的原理"></a>Binder的原理</h1><p>我们定义了AIDI后，默认系统都会生成一个集成了IInterface的接口的类，eclipse默认是在gen目录下。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-54449047e423b0a3?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * This file is auto-generated.  DO NOT MODIFY.</div><div class="line"> * Original file: G:\\Source\\Demo\\MyApplication\\app\\src\\main\\aidl\\com\\jd\\test\\myapplication\\IBookManager.aidl</div><div class="line"> */</div><div class="line">package com.jd.test.myapplication;</div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">public interface IBookManager extends android.os.IInterface</div><div class="line">&#123;</div><div class="line">/** Local-side IPC implementation stub class. */</div><div class="line">public static abstract class Stub extends android.os.Binder implements com.jd.test.myapplication.IBookManager</div><div class="line">&#123;</div><div class="line">private static final java.lang.String DESCRIPTOR = &quot;com.jd.test.myapplication.IBookManager&quot;;</div><div class="line">/** Construct the stub at attach it to the interface. */</div><div class="line">public Stub()</div><div class="line">&#123;</div><div class="line">this.attachInterface(this, DESCRIPTOR);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Cast an IBinder object into an com.jd.test.myapplication.IBookManager interface,</div><div class="line"> * generating a proxy if needed.</div><div class="line"> */</div><div class="line">public static com.jd.test.myapplication.IBookManager asInterface(android.os.IBinder obj)</div><div class="line">&#123;</div><div class="line">if ((obj==null)) &#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">if (((iin!=null)&amp;&amp;(iin instanceof com.jd.test.myapplication.IBookManager))) &#123;</div><div class="line">return ((com.jd.test.myapplication.IBookManager)iin);</div><div class="line">&#125;</div><div class="line">return new com.jd.test.myapplication.IBookManager.Stub.Proxy(obj);</div><div class="line">&#125;</div><div class="line">@Override public android.os.IBinder asBinder()</div><div class="line">&#123;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">switch (code)</div><div class="line">&#123;</div><div class="line">case INTERFACE_TRANSACTION:</div><div class="line">&#123;</div><div class="line">reply.writeString(DESCRIPTOR);</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">case TRANSACTION_basicTypes:</div><div class="line">&#123;</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line">int _arg0;</div><div class="line">_arg0 = data.readInt();</div><div class="line">long _arg1;</div><div class="line">_arg1 = data.readLong();</div><div class="line">boolean _arg2;</div><div class="line">_arg2 = (0!=data.readInt());</div><div class="line">float _arg3;</div><div class="line">_arg3 = data.readFloat();</div><div class="line">double _arg4;</div><div class="line">_arg4 = data.readDouble();</div><div class="line">java.lang.String _arg5;</div><div class="line">_arg5 = data.readString();</div><div class="line">this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</div><div class="line">reply.writeNoException();</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">case TRANSACTION_getBooks:</div><div class="line">&#123;</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line">java.util.List&lt;com.jd.test.myapplication.Book&gt; _result = this.getBooks();</div><div class="line">reply.writeNoException();</div><div class="line">reply.writeTypedList(_result);</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">case TRANSACTION_addBook:</div><div class="line">&#123;</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line">com.jd.test.myapplication.Book _arg0;</div><div class="line">if ((0!=data.readInt())) &#123;</div><div class="line">_arg0 = com.jd.test.myapplication.Book.CREATOR.createFromParcel(data);</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">_arg0 = null;</div><div class="line">&#125;</div><div class="line">this.addBook(_arg0);</div><div class="line">reply.writeNoException();</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return super.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div><div class="line">private static class Proxy implements com.jd.test.myapplication.IBookManager</div><div class="line">&#123;</div><div class="line">private android.os.IBinder mRemote;</div><div class="line">Proxy(android.os.IBinder remote)</div><div class="line">&#123;</div><div class="line">mRemote = remote;</div><div class="line">&#125;</div><div class="line">@Override public android.os.IBinder asBinder()</div><div class="line">&#123;</div><div class="line">return mRemote;</div><div class="line">&#125;</div><div class="line">public java.lang.String getInterfaceDescriptor()</div><div class="line">&#123;</div><div class="line">return DESCRIPTOR;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">     * Demonstrates some basic types that you can use as parameters</div><div class="line">     * and return values in AIDL.</div><div class="line">     */</div><div class="line">@Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">try &#123;</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">_data.writeInt(anInt);</div><div class="line">_data.writeLong(aLong);</div><div class="line">_data.writeInt(((aBoolean)?(1):(0)));</div><div class="line">_data.writeFloat(aFloat);</div><div class="line">_data.writeDouble(aDouble);</div><div class="line">_data.writeString(aString);</div><div class="line">mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);</div><div class="line">_reply.readException();</div><div class="line">&#125;</div><div class="line">finally &#123;</div><div class="line">_reply.recycle();</div><div class="line">_data.recycle();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">@Override public java.util.List&lt;com.jd.test.myapplication.Book&gt; getBooks() throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">java.util.List&lt;com.jd.test.myapplication.Book&gt; _result;</div><div class="line">try &#123;</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">mRemote.transact(Stub.TRANSACTION_getBooks, _data, _reply, 0);</div><div class="line">_reply.readException();</div><div class="line">_result = _reply.createTypedArrayList(com.jd.test.myapplication.Book.CREATOR);</div><div class="line">&#125;</div><div class="line">finally &#123;</div><div class="line">_reply.recycle();</div><div class="line">_data.recycle();</div><div class="line">&#125;</div><div class="line">return _result;</div><div class="line">&#125;</div><div class="line">@Override public void addBook(com.jd.test.myapplication.Book book) throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">try &#123;</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">if ((book!=null)) &#123;</div><div class="line">_data.writeInt(1);</div><div class="line">book.writeToParcel(_data, 0);</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">_data.writeInt(0);</div><div class="line">&#125;</div><div class="line">mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</div><div class="line">_reply.readException();</div><div class="line">&#125;</div><div class="line">finally &#123;</div><div class="line">_reply.recycle();</div><div class="line">_data.recycle();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</div><div class="line">static final int TRANSACTION_getBooks = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</div><div class="line">static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">     * Demonstrates some basic types that you can use as parameters</div><div class="line">     * and return values in AIDL.</div><div class="line">     */</div><div class="line">public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;</div><div class="line">public java.util.List&lt;com.jd.test.myapplication.Book&gt; getBooks() throws android.os.RemoteException;</div><div class="line">public void addBook(com.jd.test.myapplication.Book book) throws android.os.RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类也就是我们在onServiceConnected中使用的接口。在这个IBookManager中我们有几个关键的类Stub、Proxy，也见到了久违的Binder。那么纠结Binder是怎么样来进行间通讯的呢？下面我们先通过一个示例图来简单描述一下该流程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ee815022cc036d97?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<h2 id="IInterface结构分析"><a href="#IInterface结构分析" class="headerlink" title="IInterface结构分析"></a>IInterface结构分析</h2><p>首先变量DESCRIPTOR定义了接口和对应方法的唯一标示。因为Binder其实是一种底层的通讯方式，Google工程师将Binder包装成了一种对象的引用。所以这里的标识是告诉底层的Binder驱动，我的Binder引用标识，对应的方法标识。这样Binder驱动才能在进程间进行装换。</p>
<p>Proxy：实现了IBookManager接口，这个代理类是往Binder驱动里面写数据，通过调用Binder的transact方法往Binder驱动写Parcel数据。可以理解为告诉Binder驱动我们要调用什么方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</div></pre></td></tr></table></figure></p>
<p>Stub：继承了Binder，实现了IBookManager接口。Binder驱动调用远程方法成功后，要回调告诉执行的结果。通过回调onTransact方法。将Binder驱动中的Parcel数据转换为我们的回调数据。</p>
<h2 id="IBinder引用是什么时候注册到了Binder驱动中呢？"><a href="#IBinder引用是什么时候注册到了Binder驱动中呢？" class="headerlink" title="IBinder引用是什么时候注册到了Binder驱动中呢？"></a>IBinder引用是什么时候注册到了Binder驱动中呢？</h2><p>我们知道Stub继承了Binder，那么当Stub实例化的时候，这个时候Binder无参构造被调用，执行了一个native 的init方法。这个时候向Binder驱动注册了IBinder的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public Binder() &#123;</div><div class="line">        init();</div><div class="line"></div><div class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            final Class&lt;? extends Binder&gt; klass = getClass();</div><div class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">                Log.w(TAG, &quot;The following Binder class should be static or leaks might occur: &quot; +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private native final void init();</div></pre></td></tr></table></figure></p>
<h2 id="transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact"><a href="#transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact" class="headerlink" title="transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact"></a>transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</div><div class="line">     Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</div><div class="line">     return transactNative(code, data, reply, flags);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">   public native boolean transactNative(int code, Parcel data, Parcel reply,</div><div class="line">         int flags) throws RemoteException;</div></pre></td></tr></table></figure>
<h2 id="onTransact方法-（Binder驱动回调数据）"><a href="#onTransact方法-（Binder驱动回调数据）" class="headerlink" title="onTransact方法 （Binder驱动回调数据）"></a>onTransact方法 （Binder驱动回调数据）</h2><p>根据定义的常量标识，解析Parcel数据，回调本地方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">       public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</div><div class="line">           switch (code) &#123;</div><div class="line">               case INTERFACE_TRANSACTION: &#123;</div><div class="line">                   reply.writeString(DESCRIPTOR);</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">               case TRANSACTION_basicTypes: &#123;</div><div class="line">                   data.enforceInterface(DESCRIPTOR);</div><div class="line">                   int _arg0;</div><div class="line">                   _arg0 = data.readInt();</div><div class="line">                   long _arg1;</div><div class="line">                   _arg1 = data.readLong();</div><div class="line">                   boolean _arg2;</div><div class="line">                   _arg2 = (0 != data.readInt());</div><div class="line">                   float _arg3;</div><div class="line">                   _arg3 = data.readFloat();</div><div class="line">                   double _arg4;</div><div class="line">                   _arg4 = data.readDouble();</div><div class="line">                   java.lang.String _arg5;</div><div class="line">                   _arg5 = data.readString();</div><div class="line">                   this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</div><div class="line">                   reply.writeNoException();</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">               case TRANSACTION_getBooks: &#123;</div><div class="line">                   data.enforceInterface(DESCRIPTOR);</div><div class="line">                   java.util.List&lt;com.jd.test.myapplication.Book&gt; _result = this.getBooks();</div><div class="line">                   reply.writeNoException();</div><div class="line">                   reply.writeTypedList(_result);</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">               case TRANSACTION_addBook: &#123;</div><div class="line">                   data.enforceInterface(DESCRIPTOR);</div><div class="line">                   com.jd.test.myapplication.Book _arg0;</div><div class="line">                   if ((0 != data.readInt())) &#123;</div><div class="line">                       _arg0 = com.jd.test.myapplication.Book.CREATOR.createFromParcel(data);</div><div class="line">                   &#125; else &#123;</div><div class="line">                       _arg0 = null;</div><div class="line">                   &#125;</div><div class="line">                   this.addBook(_arg0);</div><div class="line">                   reply.writeNoException();</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           return super.onTransact(code, data, reply, flags);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Binder应用层源码实现流程分析"><a href="#Binder应用层源码实现流程分析" class="headerlink" title="Binder应用层源码实现流程分析"></a>Binder应用层源码实现流程分析</h1><p>我们了解了Binder通讯的一些基础原理后，通过应用层的调用来追踪整个执行的流程。下面我们通过一个表格索引来描述Binder通讯的结构</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>调用的类间关系</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Activity：bindService</td>
<td>执行服务的绑定</td>
</tr>
<tr>
<td>2</td>
<td>Context：bindService</td>
<td>基类的的服务绑定抽象方法</td>
</tr>
<tr>
<td>3</td>
<td>ContextImpl：bindService</td>
<td>Context实现类的方法</td>
</tr>
<tr>
<td>4</td>
<td>ContextImpl:bindServiceCommon</td>
<td>进行一些Intent校验等，调用ActivityManagerNative.getDefault().bindService</td>
</tr>
<tr>
<td>5</td>
<td>ActivityManagerService:bindService</td>
<td>进行一些合法 非空的校验</td>
</tr>
<tr>
<td>6</td>
<td>ActiveServices:bindServiceLocked</td>
<td>创建Service，对服务进行缓存记录，同时回调了connection方法</td>
</tr>
<tr>
<td>7</td>
<td>ActiveServices：requestServiceBindingLocked</td>
<td>校验服务进程是否存在，调用ApplicationThread的scheduleBindService</td>
</tr>
<tr>
<td>8</td>
<td>ApplicationThread：scheduleBindService</td>
<td>ApplicationThread是ActivityThread的内部类，该方法发送了一个Message sendMessage(H.BIND_SERVICE, s);</td>
</tr>
<tr>
<td>9</td>
<td>ActiviThread：handleBindService</td>
<td>校验Service是否存在，执行AMS的publishService方法</td>
</tr>
<tr>
<td>10</td>
<td>ActivityManagerService：publishService</td>
<td>校验及调用ActiveServices的publishServiceLocked方法</td>
</tr>
<tr>
<td>11</td>
<td>ActiveServices：publishServiceLocked</td>
<td>执行Binder的restoreCallingIdentity方法</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>本文对Bidner做了一些整体的介绍，主要是基于应用层的流程进行分析，如果要彻底搞清楚Bidner，可能还需阅读Binder驱动的源码及Bidner的协议等</li>
<li>Binder在Android体系中，有着非常重要的地位，是核心的IPC方式。如果希望学习Android源码，Binder是一道需要越过去的坎。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/10/Android之Activity启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/Android之Activity启动流程/" itemprop="url">
                  Android之Activity启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T18:25:25+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/10/Android之Activity启动流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/10/Android之Activity启动流程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么要学习Android的源码"><a href="#为什么要学习Android的源码" class="headerlink" title="为什么要学习Android的源码"></a>为什么要学习Android的源码</h2><ol>
<li>学习优秀的代码，可能是进步最快的方式之一，特别是看一群优秀的Google开发工程师的代码。</li>
<li>知己知彼，了解系统的运行原理。在实际的项目开发中，解决一些疑难杂症，对于排障分析有很重要的意义。（开发中最怕就是特殊机型兼容，一些无日志的问题，这个时候只能靠经验来分析，熟悉系统的运行流程就显得很重要）</li>
<li>不要做一个只会堆砌API的工程师，否则无论3年或者5年，你始终会感觉到瓶颈的到来。其实换个角度学Android，例如源码分析、性能优化。你可能可以看到不一样的世界。</li>
</ol>
<h2 id="什么是Activity的启动流程"><a href="#什么是Activity的启动流程" class="headerlink" title="什么是Activity的启动流程"></a>什么是Activity的启动流程</h2><p>很多童鞋可能想，这还不简单，项目中用了千千万万遍了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivity(new Intent(this, Activity.class));</div></pre></td></tr></table></figure></p>
<p>只能说Too young,Too simple。</p>
<p>我一开始也以为只是简单调用个startActivity，然后屏幕就跳转到指定的Activity，这就是Activity的启动流程。</p>
<p>我们都知道Activity有一个栈，当我们按了back键的时候，就会回到上一个Activity。那么系统是如何来管理这个栈的呢？</p>
<p>我们从launcher点击一个应用图标，那么会启动一个新的进程，系统如何控制多进程之间的Activity切换呢？</p>
<p>我们都知道Activity有它自己的生命周期，那么这个生命周期在运行的过程中，系统是怎么去做控制的呢？</p>
<p>实际上问题远远不止这些，可见Activity的启动流程不是想象中的那么简单，所以为了找寻真相，我们需要从Android的源码来分析Activity的启动流程。</p>
<h1 id="Activity基础"><a href="#Activity基础" class="headerlink" title="Activity基础"></a>Activity基础</h1><p>这里我们先简单来了解一些我们开发项目过程中，常用的一些Activity的基础知识，然后后续才来进行源码的分析。在源码的分析中，我们也可以结合日常的使用来结合分析。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>这里使用Google官方的示例图来说明</p>
<p><img src="https://developer.android.google.cn/images/activity_lifecycle.png" alt="Google官方示例图"></p>
<ul>
<li><p>Activity 的整个生命周期发生在 onCreate() 调用与 onDestroy() 调用之间。您的 Activity 应在 onCreate() 中执行“全局”状态设置（例如定义布局），并释放 onDestroy() 中的所有其余资源。例如，如果您的 Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate() 中创建该线程，然后在 onDestroy() 中停止该线程。</p>
</li>
<li><p>Activity 的可见生命周期发生在 onStart() 调用与 onStop() 调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 onStop()。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 onStart() 中注册一个 BroadcastReceiver 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop() 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart() 和 onStop()。</p>
</li>
<li><p>Activity 的前台生命周期发生在 onResume() 调用与 onPause() 调用之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。</p>
</li>
</ul>
<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><ul>
<li>standard（默认模式）</li>
</ul>
<p>默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p>
<ul>
<li>singleTop</li>
</ul>
<p>如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。 </p>
<ul>
<li>singleTask</li>
</ul>
<p>系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。 </p>
<ul>
<li>singleInstance</li>
</ul>
<p>与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p>
<h2 id="运行状态保存"><a href="#运行状态保存" class="headerlink" title="运行状态保存"></a>运行状态保存</h2><p>这里同样借助Google官方的示例图来说明<br><img src="https://developer.android.google.cn/images/fundamentals/restore_instance.png" alt="Google官方示例图"></p>
<p>这个运行状态的保存，往往很容易在开发中被遗忘。如果不注意，却很容易引起一些程序的异常。首先，系统的运行的中，如果内存不足，会回收一些资源。再者，一些ROM会开启例如开发中选项中的不保留活动，当应用到后台时，则会被回收，或者屏幕旋转等一些配置变更。这些情况都需要我们处理好运行状态的保存。例如Viewpager保存好当前的tab位置，一些数据的保存和恢复，避免空指针等。</p>
<p>在界面被回收时，系统会先调用 onSaveInstanceState()，然后再使 Activity 变得易于销毁。系统会向该方法传递一个 Bundle，您可以在其中使用 putString() 和 putInt() 等方法以名称-值对形式保存有关 Activity 状态的信息。然后，如果系统终止您的应用进程，并且用户返回您的 Activity，则系统会重建该 Activity，并将 Bundle 同时传递给 onCreate() 和 onRestoreInstanceState()。您可以使用上述任一方法从 Bundle 提取您保存的状态并恢复该 Activity 状态。如果没有状态信息需要恢复，则传递给您的 Bundle 是空值</p>
<h1 id="源码相关类介绍"><a href="#源码相关类介绍" class="headerlink" title="源码相关类介绍"></a>源码相关类介绍</h1><p>过完了Activity的基础知识后，我们通过一个表格来分析一下Activity启动流程中核心的一些类的设计及作用，这样可以让我们更好的来了解启动的流程。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td>Activity 是一个应用组件，用户可与其提供的屏幕进行交互。</td>
</tr>
<tr>
<td>Instrumentation</td>
<td>每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。当ActivityThread需要操作Activity的生命周期，都是通过Instrumentation来完成，实际Activity的实例化，也是在里面的newActivity完成。</td>
</tr>
<tr>
<td>ActivityManagerService</td>
<td>AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作</td>
</tr>
<tr>
<td>PackageManagerService</td>
<td>Android系统下的apk程序都是通过名为PackageManagerService的包管理服务来管理的。PacketManagerService是安卓系统的一个重要服务，由SystemServer启动，主要实现apk程序包的解析，安装，更新，移动，卸载等服务。不管是系统apk(/system/app)，还是我们手工安装上去的，系统所有的apk都是由其管理</td>
</tr>
<tr>
<td>ActivityStackSupervisor</td>
<td>主要是对整个APP的Task进行管理，通常一个进程拥有一个或多个Task</td>
</tr>
<tr>
<td>ActivityStack</td>
<td>传说中的Activity栈，我们都知道Activity的管理就是通过栈管理，默认显示栈顶，当按back键后，就将栈顶的Activity移除，遵循后进先去原则</td>
</tr>
<tr>
<td>ActivityRecord</td>
<td>ActivityRecord 是Activity的标识，与每个Activity是一一对应的，存储这Activity的一些信息，便于后续操作Activity </td>
</tr>
<tr>
<td>ActivityThread</td>
<td>传说中的UI线程， 它管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，并根据AMS的要求（通过IApplicationThread接口）负责调度和执行activities、broadcasts和其它操作</td>
</tr>
</tbody>
</table>
<h1 id="源码启动流程分析"><a href="#源码启动流程分析" class="headerlink" title="源码启动流程分析"></a>源码启动流程分析</h1><p>Activity的源码启动流程，其实一开始想试试用流程图来说明，但最后发现实在太长，欲生欲死。下面我们同样通过表格，以序号的方式来一步步显示Activity启动流程。这个可以更清晰便捷的来理解。具体的关键实现源码会在说明中分析，可以自己在结合源码进行分析。</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>调用的类间关系</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Activity：startActivity-&gt;startActivityForResult</td>
<td>startActivity其实最终也是调用了startActivityForResult</td>
</tr>
<tr>
<td>2</td>
<td>Intrumentation：execStartActivity</td>
<td>mInstrumentation类似与管家婆，ActivityThread与AMS交互后，最后都是交由Intrumentation来处理</td>
</tr>
<tr>
<td>3</td>
<td>ActivityManagerNative.getDefault().startActivity(AIDL)-&gt;最后执行到AMS的startActivity</td>
<td>这是一个IPC的过程</td>
</tr>
<tr>
<td>4</td>
<td>AMS：startActivityAsUser</td>
<td>生成了userId</td>
</tr>
<tr>
<td>5</td>
<td>ActivityStackSupervisor：startActivityMyWait()</td>
<td>校验Intent的一些合法性,其中调用了PackageManagerService的resolveIntent</td>
</tr>
<tr>
<td>6</td>
<td>ActivityStackSupervisor：startActivityLocked()</td>
<td>验证intent、Class、Permission等保存将要启动的Activity的Record</td>
</tr>
<tr>
<td>7</td>
<td>ActivityStackSupervisor：startActivityUncheckedLocked()</td>
<td>检查将要启动的Activity的launchMode和启动Flag根据launcheMode和Flag配置task</td>
</tr>
<tr>
<td>8</td>
<td>ActvityStack：startActivityLocked</td>
<td>对栈进行初始化配置</td>
</tr>
<tr>
<td>9</td>
<td>ActivityStack： resumeTopActivityInnerLocked()</td>
<td>查找需要进入onPause的Activity</td>
</tr>
<tr>
<td>10</td>
<td>ActivityStack：startPausingLocked()</td>
<td>IPC，控制将需要OnPause的Activity进行暂停</td>
</tr>
<tr>
<td>11</td>
<td>ActivityThread： handlePauseActivity()</td>
<td>回调Activity的onPause，并通知AMS</td>
</tr>
<tr>
<td>12</td>
<td>ActivityManagerService:activityPaused()</td>
<td>获取对应的栈，执行activityPausedLocked</td>
</tr>
<tr>
<td>13</td>
<td>ActivityStack：activityPausedLocked</td>
<td>获取ActivityRecord，调用completePauseLocked</td>
</tr>
<tr>
<td>14</td>
<td>ActivityStackSuperVisor： resumeTopActivitiesLocked()</td>
<td>找出当前自己管理的task的栈，执行resumeTopActivityLocked</td>
</tr>
<tr>
<td>15</td>
<td>ActivityStack：resumeTopActivityLocked()</td>
<td>调用ActivityStackSuperVisor：resumeTopActivityInnerLocked验证是否该启动的Activity所在进程和app是否存在，若存在，直接启动。否则，准备创建该进程</td>
</tr>
<tr>
<td>16</td>
<td>ActivityStackSuperVisor：startSpecificActivityLocked()</td>
<td>该进程不存在，创建进程</td>
</tr>
<tr>
<td>17</td>
<td>ActivityManagerService：startProcessLocked()</td>
<td>通过Process.start()启动进程 entryPoint = “android.app.ActivityThread”</td>
</tr>
<tr>
<td>18</td>
<td>ActivityThread：main()</td>
<td>主线程的Looper也在这里初始化，这里是我们应用层的主入口。</td>
</tr>
<tr>
<td>19</td>
<td>ActivityThread：attach</td>
<td>调用attachApplication()</td>
</tr>
<tr>
<td>20</td>
<td>IActivityManager：attachApplication()</td>
<td>调用attachApplicationLocked，我们的Application也会在这个地方来创建</td>
</tr>
<tr>
<td>21</td>
<td>ActivityStackSuperVisor：attachApplicationLocked()</td>
<td>通过ActivityRecord找出具体的栈</td>
</tr>
<tr>
<td>22</td>
<td>ActivityStackSuperVisor：realStartActivityLocked()</td>
<td>IPC通知ActivityThread </td>
</tr>
<tr>
<td>23</td>
<td>ActivityThread：scheduleLaunchActivity()</td>
<td>通过handler调用handleLaunchActivity,接着performLaunchActivity</td>
</tr>
<tr>
<td>24</td>
<td>ActivityThread：接着performLaunchActivity</td>
<td>进行了一些Avcitity的状态判断，执行了mInstrumentation.newActivity。Activity对象真正通过反射实例化出来</td>
</tr>
<tr>
<td>25</td>
<td>Intrumentation：callActivityOnCreate</td>
<td>调用了Activity的onCreate</td>
</tr>
</tbody>
</table>
<p>过完一遍，反正欲生欲死了。觉得不是当初想象的那么简单。过源码，我们尽量保持流程性上的理解吧，如果纠结于实现的细节，反倒会适得其反，不可自拔。通过流程上的梳理，来理解设计的精髓。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>Android源码中大量使用了Service的思想。提供统一的服务，这样使得系统可以统一来调用一些任务。为什么这里的Activity启动要设计得如此的复杂？因为系统需要统一管理窗口的显示，这里涉及多进程、多窗口的管理控制。</li>
<li>单一责任原则。这个是设计模式里面的东西。不同的功能让不同的类来实现，减低耦合性。例如这里的ActivityStackSupervisor用来管理Task,ActivityStack用来管理栈。而不会将所有的东西都塞在Activity中</li>
<li>模块化思想。系统的各种Service其实很好的体现了这一点。AMS管理Activity，WMS管理窗口，PMS管理安装包，还有例如网络、电量等的管理都一致。这样使得系统逻辑更加清晰，便于维护管理及使用</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">76</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
