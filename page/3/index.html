<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/3/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/3/">





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/12/14/玩转Android状态栏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/玩转Android状态栏/" itemprop="url">
                  玩转Android状态栏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T08:45:35+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/14/玩转Android状态栏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/14/玩转Android状态栏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，突然收到一个状态栏颜色优化设计的任务，将原本应用整体的黑色状态栏修改为根据标题栏颜色进行沉浸式设计，显示效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-3c19e25bec23ae1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>经过分析及踩过N多坑，终于完成了APP全局的修改。现将一些需要注意的问题及踩过的坑进行梳理总结，主要从系统版本区别、各大厂商的ROM区别及具体的设置进行分析，期间也参考了很多资料，会在文末附上对应的链接</p>
<h2 id="Android各版本状态栏区别"><a href="#Android各版本状态栏区别" class="headerlink" title="Android各版本状态栏区别"></a>Android各版本状态栏区别</h2><p>首先我们需要注意，Android不是各个版本都支持设置状态栏的颜色，只有在5.0以上才支持。另外6.0以上才支持设置状态栏黑色图标（避免白色状态栏及白色图标导致看不清电量 时间等问题）</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-682a47055173face?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th>是否支持设置状态栏颜色</th>
<th>是否允许设置状态栏黑色图标</th>
</tr>
</thead>
<tbody>
<tr>
<td>4.4</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>5.0</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>6.0+</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="各个ROM状态栏区别"><a href="#各个ROM状态栏区别" class="headerlink" title="各个ROM状态栏区别"></a>各个ROM状态栏区别</h2><h3 id="是不是设置了状态栏透明就真透明了？"><a href="#是不是设置了状态栏透明就真透明了？" class="headerlink" title="是不是设置了状态栏透明就真透明了？"></a>是不是设置了状态栏透明就真透明了？</h3><p>这个问题一开始也困扰了我，后面分析，在原生的系统虽然设置了状态栏透明，但是状态栏区域也会有一层半透明的遮罩（估计就是考虑到白色状态栏引起的问题），但是测试发现部分国产ROM设置穿透栏透明则会完全透明（例如MIUI）</p>
<p>原生系统效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-296dc3db09ecc9c0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>MIUI系统效果如下：<br> <img src="http://upload-images.jianshu.io/upload_images/5125122-4f4ac539c4d45a49?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="是不是6-0都支持系统状态栏黑条图标？"><a href="#是不是6-0都支持系统状态栏黑条图标？" class="headerlink" title="是不是6.0都支持系统状态栏黑条图标？"></a>是不是6.0都支持系统状态栏黑条图标？</h3><p>原生6.0以上有API支持，但是国产各ROM经过定制，有的需要特定的设置才能实现</p>
<p>原生系统设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setLightStatusBar(Window window, boolean lightStatusBar) &#123;</span><br><span class="line">          // 设置浅色状态栏时的界面显示</span><br><span class="line">          View decor = window.getDecorView();</span><br><span class="line">          int ui = decor.getSystemUiVisibility();</span><br><span class="line">          if (lightStatusBar) &#123;</span><br><span class="line">              ui |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              ui &amp;= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;</span><br><span class="line">          &#125;</span><br><span class="line">          decor.setSystemUiVisibility(ui);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>小米：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static boolean MIUISetStatusBarLightMode(Window window, boolean dark) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if (window != null) &#123;</span><br><span class="line">            Class clazz = window.getClass();</span><br><span class="line">            try &#123;</span><br><span class="line">                int darkModeFlag = 0;</span><br><span class="line">                Class layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);</span><br><span class="line">                Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);</span><br><span class="line">                darkModeFlag = field.getInt(layoutParams);</span><br><span class="line">                Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);</span><br><span class="line">                if (dark) &#123;</span><br><span class="line">                    extraFlagField.invoke(window, darkModeFlag, darkModeFlag);//状态栏透明且黑色字体</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    extraFlagField.invoke(window, 0, darkModeFlag);//清除黑色字体</span><br><span class="line">                &#125;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>魅族：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static boolean FlymeSetStatusBarLightMode(Window window, boolean dark) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if (window != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                WindowManager.LayoutParams lp = window.getAttributes();</span><br><span class="line">                Field darkFlag = WindowManager.LayoutParams.class</span><br><span class="line">                        .getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;);</span><br><span class="line">                Field meizuFlags = WindowManager.LayoutParams.class</span><br><span class="line">                        .getDeclaredField(&quot;meizuFlags&quot;);</span><br><span class="line">                darkFlag.setAccessible(true);</span><br><span class="line">                meizuFlags.setAccessible(true);</span><br><span class="line">                int bit = darkFlag.getInt(null);</span><br><span class="line">                int value = meizuFlags.getInt(lp);</span><br><span class="line">                if (dark) &#123;</span><br><span class="line">                    value |= bit;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value &amp;= ~bit;</span><br><span class="line">                &#125;</span><br><span class="line">                meizuFlags.setInt(lp, value);</span><br><span class="line">                window.setAttributes(lp);</span><br><span class="line">                result = true;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>华为手机：<br>部分测试发现华为的EMUI手机状态栏会跟系统桌面的状态栏一样，设置了没用，这里如果要特殊设置状态栏颜色，只能参考4.4的处理方式（后续介绍）</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-c559fc450208c6d0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="如何进行定制状态栏"><a href="#如何进行定制状态栏" class="headerlink" title="如何进行定制状态栏"></a>如何进行定制状态栏</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ul>
<li>4.4</li>
</ul>
<p>通过上述的版本及分析，可见完善的的状态栏兼容是一个大工程，需要综合考虑系统版本及各个厂商ROM等因素。5.0以上有系统API进行支持，这里我们主要来分析一些4.4的实现原理。<br>简单来说，4.4的实现方式就是使用透明的状态栏，然后做一个和状态栏一样高度的View，加入到Windows的DecorView，然后给这个View设置背景色，达到实现状态栏颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line"></span><br><span class="line">       ViewGroup decorViewGroup = (ViewGroup) window.getDecorView();</span><br><span class="line">       View statusBarView = decorViewGroup.findViewWithTag(STATUS_BAR_VIEW_TAG);</span><br><span class="line">       if (statusBarView == null) &#123;</span><br><span class="line">           statusBarView = new StatusBarView(window.getContext());</span><br><span class="line">           statusBarView.setTag(STATUS_BAR_VIEW_TAG);</span><br><span class="line">           FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(</span><br><span class="line">                   FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);</span><br><span class="line">           params.gravity = Gravity.TOP;</span><br><span class="line">           statusBarView.setLayoutParams(params);</span><br><span class="line">           decorViewGroup.addView(statusBarView);</span><br><span class="line">       &#125;</span><br><span class="line">       statusBarView.setBackgroundColor(color);</span><br><span class="line">       StatusBarCompat.internalSetFitsSystemWindows(window, true);</span><br></pre></td></tr></table></figure></p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-7dadf90e78c14b97?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>5.0</li>
</ul>
<p>注意5.0一般不用使用白色的状态栏（因为不能设置状态栏灰色图标），可在资源文件定义一个rgb，区分版本，5.0使用白灰色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">@Override</span><br><span class="line">public void setStatusBarColor(Window window, int color) &#123;</span><br><span class="line">    //取消设置透明状态栏,使 ContentView 内容不再覆盖状态栏</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">    //需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">    //设置状态栏颜色</span><br><span class="line">    window.setStatusBarColor(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-1f899b0ae03f1576?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li><p>6.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.M)</span><br><span class="line">  @Override</span><br><span class="line">  public void setStatusBarColor(Window window, int color) &#123;</span><br><span class="line">      //取消设置透明状态栏,使 ContentView 内容不再覆盖状态栏</span><br><span class="line">      window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">      //需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色</span><br><span class="line">      window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">      //设置状态栏颜色</span><br><span class="line">      window.setStatusBarColor(color);</span><br><span class="line"></span><br><span class="line">      // 去掉系统状态栏下的windowContentOverlay</span><br><span class="line">      View v = window.findViewById(android.R.id.content);</span><br><span class="line">      if (v != null) &#123;</span><br><span class="line">          v.setForeground(null);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-cc8e3645cceebf35?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
</ul>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>这里不重复造轮子，先提供一下github上比较完善的处理方案</p>
<p><a href="https://github.com/msdx/status-bar-compat" target="_blank" rel="noopener">status-bar-compat</a></p>
<p>StatusBarCompat是一个用于设置系统状态栏颜色的兼容库，兼容Android 4.4.2(API 19)以上，使用简单，仅需要一行代码的调用。</p>
<p><a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="noopener">SystemBarTint</a></p>
<p>支持4.4以上的，主要使用透明状态栏的方式实现</p>
<p>推荐使用status-bar-compat，已考虑到整体的版本兼容机及各厂ROM，调用简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Activity的setContentView()方法调用之后，调用以下方法即可。</span><br><span class="line"></span><br><span class="line">    StatusBarCompat.setStatusBarColor(this, color, lightStatusBar);</span><br><span class="line">或者是</span><br><span class="line"></span><br><span class="line">    StatusBarCompat.setStatusBarColor(this, color);</span><br></pre></td></tr></table></figure>
<p>本文主要源码使用status-bar-compat中的代码进行说明</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="关于全屏及非全屏界面切换导致页面移动问题"><a href="#关于全屏及非全屏界面切换导致页面移动问题" class="headerlink" title="关于全屏及非全屏界面切换导致页面移动问题"></a>关于全屏及非全屏界面切换导致页面移动问题</h3><p>例如在应用中有全屏的看图页面，点击返回为非全屏（带状态栏）页面，非全屏页面由于现实状态，会出现页面抖动。目前暂无完善的处理方案，项目中暂时使用的方式是延迟全屏页面的finish，先显示状态栏后再关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">复写onBackPressed</span><br><span class="line"></span><br><span class="line"> getActivity().getWindow().clearFlags(</span><br><span class="line">                WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">        if(getView()!=null)&#123;</span><br><span class="line">            getView().postDelayed(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    getActivity().finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,10);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态栏一片白色"><a href="#状态栏一片白色" class="headerlink" title="状态栏一片白色"></a>状态栏一片白色</h3><p>上面已有分析，要注意如果状态栏为白色，需要设置状态栏的图标颜色。status-bar-compat中会把颜色转换成灰度值，然后自己控制状态栏图标颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void setStatusBarColor(Activity activity, @ColorInt int color) &#123;</span><br><span class="line">      boolean isLightColor = toGrey(color) &gt; 225;</span><br><span class="line">      setStatusBarColor(activity, color, isLightColor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 把颜色转换成灰度值。</span><br><span class="line">   * 代码来自 Flyme 示例代码</span><br><span class="line">   */</span><br><span class="line">  public static int toGrey(@ColorInt int color) &#123;</span><br><span class="line">      int blue = Color.blue(color);</span><br><span class="line">      int green = Color.green(color);</span><br><span class="line">      int red = Color.red(color);</span><br><span class="line">      return (red * 38 + green * 75 + blue * 15) &gt;&gt; 7;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="部分第三方组件的弹层和白色状态栏显得比较突兀"><a href="#部分第三方组件的弹层和白色状态栏显得比较突兀" class="headerlink" title="部分第三方组件的弹层和白色状态栏显得比较突兀"></a>部分第三方组件的弹层和白色状态栏显得比较突兀</h3><p> <img src="http://upload-images.jianshu.io/upload_images/5125122-fdf0bb4eeef724b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这个目前也尚无方法，考虑可以在弹层出现时，动态修改状态的颜色，但是工作量比较大，可先适当调整弹层的rgb，减低透明度</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/p/a9f2174b7714" target="_blank" rel="noopener">Android 6.0 以上实现状态栏白底黑字</a></p>
<p><a href="https://github.com/msdx/status-bar-compat" target="_blank" rel="noopener">status-bar-compat</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/Java并发编程-锁及并发容器/" itemprop="url">
                  Java并发编程-锁及并发容器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T18:52:01+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/Java并发编程-锁及并发容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/10/Java并发编程-锁及并发容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<h2 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-77d650be264e60e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。ReentrantLock是java.unti.concurrent包下的一个类，它的一般使用结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void lockMethod() &#123;  </span><br><span class="line">    ReentrantLock myLock = new ReentrantLock();  </span><br><span class="line">    myLock.lock();  </span><br><span class="line">    try&#123;  </span><br><span class="line">        // 受保护的代码段  </span><br><span class="line">        //critical section  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        // 可以保证发生异常 锁可以得到释放 避免死锁的发生  </span><br><span class="line">        myLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock与synchronized的比较"><a href="#ReentrantLock与synchronized的比较" class="headerlink" title="ReentrantLock与synchronized的比较"></a>ReentrantLock与synchronized的比较</h3><ul>
<li>相同：ReentrantLock提供了synchronized类似的功能和内存语义。</li>
<li>不同：</li>
</ul>
<ol>
<li>ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</li>
<li>ReentrantLock 的性能比synchronized会好点。</li>
<li>ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。</li>
</ol>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>  在Java的ReentrantLock构造函数中提供了两种锁：创建公平锁和非公平锁（默认）。代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  public ReentrantLock() &#123;</span><br><span class="line"></span><br><span class="line">       sync = new NonfairSync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public ReentrantLock(boolean fair) &#123;</span><br><span class="line">          sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。</p>
<p>非公平锁性能高于公平锁性能的原因：<br>在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。</p>
<h2 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h2><p>之前提到锁基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写<br>的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-d28778b6ec512021?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">static Lock r = rwl.readLock();</span><br><span class="line">static Lock w = rwl.writeLock();</span><br><span class="line">// 获取一个key对应的value</span><br><span class="line">public static final Object get(String key) &#123;</span><br><span class="line">r.lock();</span><br><span class="line">try &#123;</span><br><span class="line">return map.get(key);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 设置key对应的value，并返回旧的value</span><br><span class="line">public static final Object put(String key, Object value) &#123;</span><br><span class="line">w.lock();</span><br><span class="line">try &#123;</span><br><span class="line">return map.put(key, value);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 清空所有的内容</span><br><span class="line">public static final void clear() &#123;</span><br><span class="line">w.lock();</span><br><span class="line">try &#123;</span><br><span class="line">map.clear();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的<br>读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使<br>得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新<br>HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而<br>只有写锁被释放之后，其他读写操作才能继续。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。</p>
<p>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p>
<ul>
<li>Conditon中的await()对应Object的wait()</li>
<li>Condition中的signal()对应Object的notify()</li>
<li>Condition中的signalAll()对应Object的notifyAll()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ConTest &#123;  </span><br><span class="line">      </span><br><span class="line">     final Lock lock = new ReentrantLock();  </span><br><span class="line">     final Condition condition = lock.newCondition();  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        ConTest test = new ConTest();  </span><br><span class="line">        Producer producer = test.new Producer();  </span><br><span class="line">        Consumer consumer = test.new Consumer();  </span><br><span class="line">                </span><br><span class="line">          </span><br><span class="line">        consumer.start();   </span><br><span class="line">        producer.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     class Consumer extends Thread&#123;  </span><br><span class="line">           </span><br><span class="line">            @Override  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                consume();  </span><br><span class="line">            &#125;  </span><br><span class="line">                </span><br><span class="line">            private void consume() &#123;  </span><br><span class="line">                               </span><br><span class="line">                    try &#123;  </span><br><span class="line">                           lock.lock();  </span><br><span class="line">                        System.out.println(&quot;我在等一个新信号&quot;+this.currentThread().getName());  </span><br><span class="line">                        condition.await();  </span><br><span class="line">                          </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        // TODO Auto-generated catch block  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125; finally&#123;  </span><br><span class="line">                        System.out.println(&quot;拿到一个信号&quot;+this.currentThread().getName());  </span><br><span class="line">                        lock.unlock();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       </span><br><span class="line">     class Producer extends Thread&#123;  </span><br><span class="line">           </span><br><span class="line">            @Override  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                produce();  </span><br><span class="line">            &#125;  </span><br><span class="line">                </span><br><span class="line">            private void produce() &#123;                   </span><br><span class="line">                    try &#123;  </span><br><span class="line">                           lock.lock();  </span><br><span class="line">                           System.out.println(&quot;我拿到锁&quot;+this.currentThread().getName());  </span><br><span class="line">                            condition.signalAll();                             </span><br><span class="line">                        System.out.println(&quot;我发出了一个信号：&quot;+this.currentThread().getName());  </span><br><span class="line">                    &#125; finally&#123;  </span><br><span class="line">                        lock.unlock();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在等一个新信号Thread-1</span><br><span class="line">我拿到锁Thread-0</span><br><span class="line">我发出了一个信号：Thread-0</span><br><span class="line">拿到一个信号Thread-1</span><br></pre></td></tr></table></figure></p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(T e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        int len = elements.length;</span><br><span class="line">        // 复制出新数组</span><br><span class="line"></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        // 把新元素添加到新数组里</span><br><span class="line"></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        // 把原数组引用指向新数组</span><br><span class="line"></span><br><span class="line">        setArray(newElements);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void setArray(Object[] a) &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>ConcurrentHashMap是线程安全且高效的HashMap。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ac27c7bad8a42712?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><ul>
<li>线程不安全的HashMap</li>
</ul>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap</p>
<ul>
<li>效率低下的HashTable</li>
</ul>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低</p>
<ul>
<li>ConcurrentHashMap的锁分段技术可有效提升并发访问率</li>
</ul>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</p>
<h3 id="hash定位"><a href="#hash定位" class="headerlink" title="hash定位"></a>hash定位</h3><p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的hash算法</span><br><span class="line">int index = hash &amp; (tab.length - 1);　　// 定位HashEntry所使用的hash算法</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散<br>列运算定位到Segment，再通过散列算法定位到元素，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">int hash = hash(key.hashCode());</span><br><span class="line">return segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。我们<br>知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       if (value == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       int hash = hash(key);</span><br><span class="line">       int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       return s.put(key, hash, value, false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Segment的put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">         HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">             scanAndLockForPut(key, hash, value);</span><br><span class="line">         V oldValue;</span><br><span class="line">         try &#123;</span><br><span class="line">             HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">             int index = (tab.length - 1) &amp; hash;</span><br><span class="line">             HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">             for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                 if (e != null) &#123;</span><br><span class="line">                     K k;</span><br><span class="line">                     if ((k = e.key) == key ||</span><br><span class="line">                         (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                         oldValue = e.value;</span><br><span class="line">                         if (!onlyIfAbsent) &#123;</span><br><span class="line">                             e.value = value;</span><br><span class="line">                             ++modCount;</span><br><span class="line">                         &#125;</span><br><span class="line">                         break;</span><br><span class="line">                     &#125;</span><br><span class="line">                     e = e.next;</span><br><span class="line">                 &#125;</span><br><span class="line">                 else &#123;</span><br><span class="line">                     if (node != null)</span><br><span class="line">                         node.setNext(first);</span><br><span class="line">                     else</span><br><span class="line">                         node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                     int c = count + 1;</span><br><span class="line">                     if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                         rehash(node);</span><br><span class="line">                     else</span><br><span class="line">                         setEntryAt(tab, index, node);</span><br><span class="line">                     ++modCount;</span><br><span class="line">                     count = c;</span><br><span class="line">                     oldValue = null;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             unlock();</span><br><span class="line">         &#125;</span><br><span class="line">         return oldValue;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不<br>满。</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器</li>
</ol>
<p>插入和移除操作的4中处理方式</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td> 移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(e,time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移<br>除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者<br>线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队<br>列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程<br>一段时间，如果超过了指定的时间，生产者线程就会退出</li>
</ul>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下。</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
</ul>
<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列 </p>
<ul>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
</ul>
<p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>
<ul>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
</ul>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序 </p>
<ul>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
</ul>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素</p>
<ul>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
<p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素</p>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
</ul>
<p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<ul>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/zmx729618/article/details/51593666" target="_blank" rel="noopener">ReentrantLock之公平锁与非公平锁浅析</a></p>
<p><a href="http://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="noopener"> java condition使用及分析</a></p>
<p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器</a></p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">Java集合—ConcurrentHashMap原理分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/10/09/Java并发编程-原子类及并发工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/09/Java并发编程-原子类及并发工具类/" itemprop="url">
                  Java并发编程-原子类及并发工具类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T14:22:41+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/09/Java并发编程-原子类及并发工具类/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/09/Java并发编程-原子类及并发工具类/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中<br>的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<br>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更<br>新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。<br>Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p>java.util.concurrent.atomic中的类可以分成4组：</p>
<ul>
<li>标量类（Scalar）：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>
<li>数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>
<li>更新器类：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li>
<li>复合变量类：AtomicMarkableReference，AtomicStampedReference</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS（Compare-And-Swap）算法保证数据操作的原子性。</p>
<p>CAS 算法是硬件对于并发操作共享数据的支持。</p>
<p>CAS 包含了三个操作数：<br>　　内存值 V<br>　　预估值 A<br>　　更新值 B</p>
<p>当且仅当 V == A 时，V 将被赋值为 B，否则循环着不断进行判断 V 与 A 是否相等。</p>
<p>CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。<br>atomic包的原子包下使用这种方案。例如AtomicInteger的getAndIncrement自增+1的方法，经查看源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">int current = get();</span><br><span class="line">int next = current + 1;</span><br><span class="line">if (compareAndSet(current, next))</span><br><span class="line">return current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作</p>
<p>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare-AndSwapInt和compareAndSwapLong，具体实现都是使用了native方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如果当前数值是expected，则原子的将Java变量更新成x</span><br><span class="line">* @return 如果更新成功则返回true</span><br><span class="line">*/</span><br><span class="line">public final native boolean compareAndSwapObject(Object o,</span><br><span class="line">long offset,</span><br><span class="line">Object expected,</span><br><span class="line">Object x);</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">int expected,</span><br><span class="line">int x);</span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,</span><br><span class="line">long expected,</span><br><span class="line">long x);</span><br></pre></td></tr></table></figure>
<h2 id="标量类"><a href="#标量类" class="headerlink" title="标量类"></a>标量类</h2><ul>
<li>AtomicBoolean：原子更新布尔变量</li>
<li>AtomicInteger：原子更新整型变量</li>
<li>AtomicLong：原子更新长整型变量</li>
<li>AtomicReference：原子更新引用类型</li>
</ul>
<p>具体到每个类的源代码中，提供的方法基本相同，这里以AtomicInteger为例进行说明<br>AtomicInteger源码主要的方法如下，原理主要都要都是采用了CAS，这里不再累述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">   </span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> //返回当前的值</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终会设置成新值</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">      //原子更新为新值并返回旧值</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            if (compareAndSet(current, newValue))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     //如果输入的值等于预期值，则以原子方式更新为新值</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //原子自增</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            int next = current + 1;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//原子方式将当前值与输入值相加并返回结果</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            int next = current + delta;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><ul>
<li>AtomicIntegerArray：原子更新整型数组的某个元素</li>
<li>AtomicLongArray：原子更新长整型数组的某个元素</li>
<li>AtomicReferenceArray：原子更新引用类型数组的某个元素</li>
</ul>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。</p>
<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</li>
</ul>
<p>以上几个类提供的方法几乎一样，所以这里以AtomicIntegerArray为例进行讲解 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2862133569453604235L;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line">    private static final int shift;</span><br><span class="line">    private final int[] array;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    private long checkedByteOffset(int i) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line"></span><br><span class="line">        return byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static long byteOffset(int i) &#123;</span><br><span class="line">        return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    public AtomicIntegerArray(int length) &#123;</span><br><span class="line">        array = new int[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public final int get(int i) &#123;</span><br><span class="line">        return getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getRaw(long offset) &#123;</span><br><span class="line">        return unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public final void set(int i, int newValue) &#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public final void lazySet(int i, int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public final int getAndSet(int i, int newValue) &#123;</span><br><span class="line">        long offset = checkedByteOffset(i);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int current = getRaw(offset);</span><br><span class="line">            if (compareAndSetRaw(offset, current, newValue))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final boolean compareAndSet(int i, int expect, int update) &#123;</span><br><span class="line">        return compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean compareAndSetRaw(long offset, int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里关键的实现也还是使用了CAS的策略，具体通过unsafe的native方法进行实现</p>
<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p> 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供<br>了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起<br>来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的<br>ABA问题。<br>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的<br>时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第<br>二步，更新类的字段（属性）必须使用public volatile修饰符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span><br><span class="line">private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">newUpdater(User.class， &quot;old&quot;);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 设置柯南的年龄是10岁</span><br><span class="line">User conan = new User(&quot;conan&quot;， 10);</span><br><span class="line">// 柯南长了一岁，但是仍然会输出旧的年龄</span><br><span class="line">System.out.println(a.getAndIncrement(conan));</span><br><span class="line">// 输出柯南现在的年龄</span><br><span class="line">System.out.println(a.get(conan));</span><br><span class="line">&#125;</span><br><span class="line">public static class User &#123;</span><br><span class="line">private String name;</span><br><span class="line">public volatile int old;</span><br><span class="line">public User(String name， int old) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.old = old;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public int getOld() &#123;</span><br><span class="line">return old;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行后输出如下。</p>
<p>10</p>
<p>11</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch类是一个同步计数器,构造时默认接收一个初始值，每调用一次countDown()方法，计数器减1。计数器&gt;0时，await()方法会阻塞;当计数器=0时会得到await()会立即得到响应<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     public static void main(String[] args) &#123;   </span><br><span class="line">         final CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line">          </span><br><span class="line">         new Thread()&#123;</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         new Thread()&#123;</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">                     Thread.sleep(3000);</span><br><span class="line">                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</span><br><span class="line">                     latch.countDown();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         try &#123;</span><br><span class="line">             System.out.println(&quot;等待2个子线程执行完毕...&quot;);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(&quot;2个子线程已经执行完毕&quot;);</span><br><span class="line">            System.out.println(&quot;继续执行主线程&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0正在执行</span><br><span class="line">线程Thread-1正在执行</span><br><span class="line">等待2个子线程执行完毕...</span><br><span class="line">线程Thread-0执行完毕</span><br><span class="line">线程Thread-1执行完毕</span><br><span class="line">2个子线程已经执行完毕</span><br><span class="line">继续执行主线程</span><br></pre></td></tr></table></figure></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会<br>开门，所有被屏障拦截的线程才会继续运行。当所有等待线程都被释放以后，CyclicBarrier可以被重用。CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 4;</span><br><span class="line">        CyclicBarrier barrier  = new CyclicBarrier(N);</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">            new Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Writer extends Thread&#123;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line">        public Writer(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);      //以睡眠来模拟写入数据操作</span><br><span class="line">                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;catch(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　执行结果：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。Semaphore可以控同时访问的线程个数，通过acquire()获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 8;            //工人数</span><br><span class="line">        Semaphore semaphore = new Semaphore(5); //机器数目</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">            new Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    static class Worker extends Thread&#123;</span><br><span class="line">        private int num;</span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line">        public Worker(int num,Semaphore semaphore)&#123;</span><br><span class="line">            this.num = num;</span><br><span class="line">            this.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);</span><br><span class="line">                semaphore.release();           </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">工人0占用一个机器在生产...</span><br><span class="line">工人1占用一个机器在生产...</span><br><span class="line">工人2占用一个机器在生产...</span><br><span class="line">工人4占用一个机器在生产...</span><br><span class="line">工人5占用一个机器在生产...</span><br><span class="line">工人0释放出机器</span><br><span class="line">工人2释放出机器</span><br><span class="line">工人3占用一个机器在生产...</span><br><span class="line">工人7占用一个机器在生产...</span><br><span class="line">工人4释放出机器</span><br><span class="line">工人5释放出机器</span><br><span class="line">工人1释放出机器</span><br><span class="line">工人6占用一个机器在生产...</span><br><span class="line">工人3释放出机器</span><br><span class="line">工人7释放出机器</span><br><span class="line">工人6释放出机器</span><br></pre></td></tr></table></figure></p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。当在运行不对称的活动时很有用。比如说，一个线程向buffer中填充数据，另一个线程从buffer中消费数据；这些线程可以用Exchange来交换数据。这个交换对于两个线程来说都是全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.clzhang.sample.thread;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line">public class SyncExchanger &#123;</span><br><span class="line">    private static final Exchanger exchanger = new Exchanger();</span><br><span class="line"></span><br><span class="line">    class DataProducer implements Runnable &#123;</span><br><span class="line">        private List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                System.out.println(&quot;生产了一个数据，耗时1秒&quot;);</span><br><span class="line">                list.add(new Date());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                list = (List) exchanger.exchange(list);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">                System.out.println(&quot;Producer &quot; + iterator.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DataConsumer implements Runnable &#123;</span><br><span class="line">        private List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                list.add(&quot;这是一个收条。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                list = (List) exchanger.exchange(list);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">                Date d = (Date) iterator.next();</span><br><span class="line">                System.out.println(&quot;Consumer: &quot; + d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SyncExchanger ins = new SyncExchanger();</span><br><span class="line">        new Thread(ins.new DataProducer()).start();</span><br><span class="line">        new Thread(ins.new DataConsumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">生产了一个数据，耗时1秒</span><br><span class="line">生产了一个数据，耗时1秒</span><br><span class="line">生产了一个数据，耗时1秒</span><br><span class="line">生产了一个数据，耗时1秒</span><br><span class="line">生产了一个数据，耗时1秒</span><br><span class="line">Producer 这是一个收条。</span><br><span class="line">Producer 这是一个收条。</span><br><span class="line">Producer 这是一个收条。</span><br><span class="line">Producer 这是一个收条。</span><br><span class="line">Producer 这是一个收条。</span><br><span class="line">Consumer: Thu Sep 12 17:21:39 CST 2013</span><br><span class="line">Consumer: Thu Sep 12 17:21:40 CST 2013</span><br><span class="line">Consumer: Thu Sep 12 17:21:41 CST 2013</span><br><span class="line">Consumer: Thu Sep 12 17:21:42 CST 2013</span><br><span class="line">Consumer: Thu Sep 12 17:21:43 CST 2013</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</a></p>
<p><a href="http://blog.csdn.net/u011116672/article/details/51068828" target="_blank" rel="noopener"> Java并发编程系列之十九：原子操作类</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/27/Java并发编程-多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/27/Java并发编程-多线程/" itemprop="url">
                  Java并发编程-多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-27T08:37:47+08:00">
                2017-09-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/27/Java并发编程-多线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/27/Java并发编程-多线程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><ul>
<li>更多的处理器核心</li>
<li>更快的相应时间</li>
<li>更好到编程模型</li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程在运行的生命周期中可能处于6种不同的状态，在给定的一个时刻，线程只能处于其他的一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（通知或者中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，该状态不用与WAITING，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td>TREMINATED</td>
<td>终止状态,表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-74c6e6679124c37c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>start方法</td>
<td>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</td>
</tr>
<tr>
<td>run方法</td>
<td>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务</td>
</tr>
<tr>
<td>sleep方法</td>
<td>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象</td>
</tr>
<tr>
<td>yield方法</td>
<td>用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的</td>
</tr>
<tr>
<td>join方法</td>
<td>join方法顾名思义 就是往线程中添加东西的；join方法可以用于临时加入线程，一个线程在运算过程中，如果满足于条件，我们可以临时加入一个线程，让这个线程运算完，另外一个线程再继续运行</td>
</tr>
<tr>
<td>interrupt方法</td>
<td>nterrupt，顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。注意通过interrupt方法可以中断处于阻塞状态的线程，直接调用interrupt方法不能中断正在运行中的线程。一般通过增加一个属性 isStop来标志是否结束while循环</td>
</tr>
<tr>
<td>过期的suspend()、resume()和stop()</td>
<td>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下</td>
</tr>
<tr>
<td>getId</td>
<td>用来得到线程ID</td>
</tr>
<tr>
<td>getName和setName</td>
<td>用来得到或者设置线程名称</td>
</tr>
<tr>
<td>getPriority和setPriority</td>
<td>用来获取和设置线程优先级</td>
</tr>
<tr>
<td>setDaemon和isDaemon</td>
<td>用来设置线程是否成为守护线程和判断线程是否是守护线程，守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖</td>
</tr>
</tbody>
</table>
<h2 id="等待与通知"><a href="#等待与通知" class="headerlink" title="等待与通知"></a>等待与通知</h2><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者,后者是消费者,这种模式隔离了”怎么做”,”做什么”，在功能层面上实现了解耦，体系结构上具备了良好的伸缩性。</p>
<p>等待方的原则:</p>
<ol>
<li>获取对象的锁</li>
<li>如果条件不满足，那么调用锁的wait()方法，使该线程进入waiting，被通知后依然要检查条件</li>
<li>条件满足则执行对应的逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">伪代码:</span><br><span class="line"></span><br><span class="line">  synchronized(对象)&#123;</span><br><span class="line">    while(条件不满足)&#123;</span><br><span class="line">     对象.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  对应的逻辑处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通知方的原则:</p>
<ol>
<li>获取对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在该对象上的线程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">伪代码:</span><br><span class="line"></span><br><span class="line">  synchronized(对象)&#123;</span><br><span class="line">     改变条件</span><br><span class="line">     对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotify&#123;</span><br><span class="line">  static boolean flag = true;</span><br><span class="line">  static Object lock = new Object();</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) throws Exception&#123;</span><br><span class="line">           Thread waitThread = new Thread(new Wait(),&quot;WaitThread&quot;);</span><br><span class="line">           waitThread.start();</span><br><span class="line">           TimeUtil.SECONDS.sleep(1);</span><br><span class="line">           Thread notifyThread = new Thread(new Notify(),&quot;NotifyThread&quot;);</span><br><span class="line">           notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static class  Wait implements Runnable&#123;</span><br><span class="line">   public void run()&#123;</span><br><span class="line">      //加锁</span><br><span class="line">      synchronized(lock)&#123;</span><br><span class="line">       //当条件不满足的时候，进入WAITTING状态，同时释放lock锁</span><br><span class="line">       while(flag)&#123;</span><br><span class="line">        System.out.println(&quot;flag is true &quot;);</span><br><span class="line">          lock.wait();</span><br><span class="line">          &#125;</span><br><span class="line">        //条件满足</span><br><span class="line">        System.out.println(&quot;doSomething&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> static class  Notify implements Runnable&#123;</span><br><span class="line">   public void run()&#123;</span><br><span class="line">      //加锁</span><br><span class="line">      synchronized(lock)&#123;</span><br><span class="line">         //获取lock的锁，然后进行通知，通知不会释放lock锁</span><br><span class="line">         //直到发出通知的线程执行完毕释放了lock锁，WaitThread线程才能从wait方法返回</span><br><span class="line">         lock.notifyAll();</span><br><span class="line">          System.out.println(&quot;flag is false now&quot;);</span><br><span class="line">         flag = false;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出内容如下:</p>
<p>flag is true</p>
<p>flag is false now</p>
<p>doSomething</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的应用场景"><a href="#线程池的应用场景" class="headerlink" title="线程池的应用场景"></a>线程池的应用场景</h2><p> Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌</li>
</ol>
<h2 id="线程池的实现原理-ThreadPoolExecutor"><a href="#线程池的实现原理-ThreadPoolExecutor" class="headerlink" title="线程池的实现原理-ThreadPoolExecutor"></a>线程池的实现原理-ThreadPoolExecutor</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-d8efcf86bdee20ac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>ThreadPoolExecutor执行execute方法分下面4种情况。</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执<br>行这一步骤需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p>
<h3 id="executor执行流程-基于JDK7-0"><a href="#executor执行流程-基于JDK7-0" class="headerlink" title="executor执行流程(基于JDK7.0)"></a>executor执行流程(基于JDK7.0)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">     if (command == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     int c = ctl.get();//AtomicInteger</span><br><span class="line">    //1.</span><br><span class="line">     if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         if (addWorker(command, true))</span><br><span class="line">             return;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     //2.</span><br><span class="line">     if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         int recheck = ctl.get();</span><br><span class="line">         if (! isRunning(recheck) &amp;&amp; remove(command))//（21）</span><br><span class="line">             reject(command);</span><br><span class="line">         else if (workerCountOf(recheck) == 0)//（22）</span><br><span class="line">             addWorker(null, false);//为什么是false</span><br><span class="line">     &#125;//3.</span><br><span class="line">     else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先查看了当前线程池中的线程数量是否小于我们指定的核心线程池的数目，如果是就尝试新建一个线程，把command作为他的第一个任务，并把他们加入到线程池中。但是我们在判断了线程池的数量合法后，调用addWorker(command, true)把线程加入到线程池中时，是多线程并发的，可能会导致加入失败。如果加入成功，则直接返回，若假如失败，则重新获取clt，因为此时clt必发生了变化，否则不会失败，继续往下执行（2）。 </li>
<li>通过isRunning(c) 判断如果线程池还在运行，那我们就尝试把当前的command加入到阻塞队列中。加入的过程也是并发的，也可能会出现失败。如果失败在继续执行（3）。加入阻塞队列成功后我们要重新在检查一遍，防止在加入的过程中线程时关闭了或者线程池中没有线程了，全部因为空闲时间超过了我们指定的alivetime被回收了。如果是线程池已经不再是RUNNING状态，则用我们的拒绝策略去丢弃它（21）。如果是线程池没有了线程，那我们新建一个空线程，让他去阻塞队列中去获取任务执行（22）。 </li>
<li>如果上面的两步都没有执行成功，那我们此时就需要使用我们指定的最大线程池，来处理它，但是此时也是可能失败的，可能有多个线程执行么，如果失败，就用拒绝策略丢弃该线程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">      //（1）循环CAS操作，将线程池中的线程数+1.</span><br><span class="line">      retry:</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          int c = ctl.get();</span><br><span class="line">          int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">          // Check if queue empty only if necessary.</span><br><span class="line"></span><br><span class="line">          if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">              ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                 firstTask == null &amp;&amp;</span><br><span class="line">                 ! workQueue.isEmpty()))</span><br><span class="line">              return false;</span><br><span class="line"></span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              int wc = workerCountOf(c);</span><br><span class="line">              //core true代表是往核心线程池中增加线程 false代表往最大线程池中增加线程</span><br><span class="line">              //线程数超标，不能再添加了，直接返回</span><br><span class="line">              if (wc &gt;= CAPACITY ||</span><br><span class="line">                  wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                  return false;</span><br><span class="line">              //CAS修改clt的值+1，在线程池中为将要添加的线程流出空间，成功退出cas循环，失败继续</span><br><span class="line">              if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                  break retry;</span><br><span class="line">              c = ctl.get();  // Re-read ctl</span><br><span class="line">              //如果线程池的状态发生了变化回到retry外层循环</span><br><span class="line">              if (runStateOf(c) != rs)</span><br><span class="line">                  continue retry;</span><br><span class="line">              // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //(2)新建线程，并加入到线程池workers中。</span><br><span class="line">      boolean workerStarted = false;</span><br><span class="line">      boolean workerAdded = false;</span><br><span class="line">      Worker w = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          //对workers操作要通过加锁来实现</span><br><span class="line">          final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">          w = new Worker(firstTask);</span><br><span class="line">          final Thread t = w.thread;</span><br><span class="line">          if (t != null) &#123;</span><br><span class="line">             //细化锁的力度，防止临界区过大，浪费时间</span><br><span class="line">              mainLock.lock();</span><br><span class="line">              try &#123;</span><br><span class="line">                  // Recheck while holding lock.</span><br><span class="line">                  // Back out on ThreadFactory failure or if</span><br><span class="line">                  // shut down before lock acquired.</span><br><span class="line">                  int c = ctl.get();</span><br><span class="line">                  int rs = runStateOf(c);</span><br><span class="line">                  //判断线程池的状态</span><br><span class="line">                  if (rs &lt; SHUTDOWN ||</span><br><span class="line">                      (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                      //判断添加的任务状态,如果已经开始丢出异常</span><br><span class="line">                      if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                          throw new IllegalThreadStateException();</span><br><span class="line">                     //将新建的线程加入到线程池中</span><br><span class="line">                      workers.add(w);</span><br><span class="line">                      int s = workers.size();</span><br><span class="line">                      //修正largestPoolSize的值</span><br><span class="line">                      if (s &gt; largestPoolSize)</span><br><span class="line">                          largestPoolSize = s;</span><br><span class="line">                      workerAdded = true;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  mainLock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              //线程添加线程池成功，则开启新创建的线程</span><br><span class="line">              if (workerAdded) &#123;</span><br><span class="line">                  t.start();//(3)</span><br><span class="line">                  workerStarted = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          //线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数，如果添加成功则需要移除，并回复clt的值</span><br><span class="line">          if (! workerStarted)</span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">      return workerStarted;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="如何实现线程复用"><a href="#如何实现线程复用" class="headerlink" title="如何实现线程复用"></a>如何实现线程复用</h3><p>线程池中，每一个线程都是一个Worker，Worker是一个内部类，继承了AbstractQueuedSynchronizer。</p>
<p>Worker的run方法会调用runWorker方法，runWorker方法会循环调用getTask获取阻塞队列的任务，达到线程复现的目的</p>
<p>Worker的主要字段就下面三个，代码也比较简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//线程池中正真运行的线程。通过我们指定的线程工厂创建而来</span><br><span class="line">final Thread thread;</span><br><span class="line">//线程包装的任务。thread 在run时主要调用了该任务的run方法</span><br><span class="line">Runnable firstTask;</span><br><span class="line">//记录当前线程完成的任务数</span><br><span class="line">volatile long completedTasks;</span><br></pre></td></tr></table></figure>
<p>Worker的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-1); // inhibit interrupts until runWorker（写的很清楚）</span><br><span class="line">    this.firstTask = firstTask;</span><br><span class="line">    //利用我们指定的线程工厂创建一个线程，注意，参数是this，也就是在执行thread.run时，正真执行的是我们Woker类的run方法</span><br><span class="line">    this.thread = getThreadFactory().newThread(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = null;</span><br><span class="line">        w.unlock(); // allow interrupts</span><br><span class="line">        boolean completedAbruptly = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                //线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态。但是当前线程没有中断，则发出中断请求</span><br><span class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                try &#123;</span><br><span class="line">                //开始执行任务前的Hook，类似回调函数</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //执行任务</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown = x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown = x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                    //任务执行后的Hook，类似回调函数</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                //执行完毕后task重置，completedTasks计数器++，解锁</span><br><span class="line">                    task = null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           //线程空闲达到我们设定的值时，Worker退出销毁。</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">       boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">       retry:</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           //如果线程池处于shutdown状态，并且队列为空，或者线程池处于stop或者terminate状态，在线程池数量-1，返回null，回收线程</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //标识当前线程在空闲时，是否应该超时回收</span><br><span class="line">           boolean timed;    </span><br><span class="line"></span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               int wc = workerCountOf(c);</span><br><span class="line">               //如果allowCoreThreadTimeOut 为ture或者当前线程数量大于核心线程池数目，则需要超时回收</span><br><span class="line">               timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">               //（1）</span><br><span class="line">               //如果线程数目小于最大线程数目，且不允许超时回收或者未超时，则跳出循环，继续去阻塞队列中取任务（2）</span><br><span class="line">               if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                   break;</span><br><span class="line">               //如果上面if没有成立，则当前线程数-1，返回null，回收该线程</span><br><span class="line">               if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   return null;</span><br><span class="line">               //如果上面if没有成立，则CAS修改ctl失败，重读，cas循环重新尝试修改</span><br><span class="line">               c = ctl.get();  // Re-read ctl</span><br><span class="line">               if (runStateOf(c) != rs)</span><br><span class="line">                   continue retry;</span><br><span class="line">               // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           （2）</span><br><span class="line">           try &#123;</span><br><span class="line">           //如果允许空闲回收，则调用阻塞队列的poll，否则take，一直等到队列中有可取任务</span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               //取到任务，返回任务，否则超时timedOut = true;进入下一个循环,并且在（1）处会不成立，进而进入到cas修改ctl的程序中</span><br><span class="line">               if (r != null)</span><br><span class="line">                   return r;</span><br><span class="line">               timedOut = true;</span><br><span class="line">           &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何处理异常"><a href="#如何处理异常" class="headerlink" title="如何处理异常"></a>如何处理异常</h3><p>当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法，默认的异常处理为AbortPolicy</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A handler for rejected tasks that throws a</span><br><span class="line"> * &#123;@code RejectedExecutionException&#125;.</span><br><span class="line"> */</span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Creates an &#123;@code AbortPolicy&#125;.</span><br><span class="line">     */</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Always throws RejectedExecutionException.</span><br><span class="line">     *</span><br><span class="line">     * @param r the runnable task requested to be executed</span><br><span class="line">     * @param e the executor attempting to execute this task</span><br><span class="line">     * @throws RejectedExecutionException always.</span><br><span class="line">     */</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * A handler for rejected tasks that silently discards the</span><br><span class="line">  * rejected task.</span><br><span class="line">  */</span><br><span class="line"> public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">     /**</span><br><span class="line">      * Creates a &#123;@code DiscardPolicy&#125;.</span><br><span class="line">      */</span><br><span class="line">     public DiscardPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      * Does nothing, which has the effect of discarding task r.</span><br><span class="line">      *</span><br><span class="line">      * @param r the runnable task requested to be executed</span><br><span class="line">      * @param e the executor attempting to execute this task</span><br><span class="line">      */</span><br><span class="line">     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * A handler for rejected tasks that discards the oldest unhandled</span><br><span class="line">   * request and then retries &#123;@code execute&#125;, unless the executor</span><br><span class="line">   * is shut down, in which case the task is discarded.</span><br><span class="line">   */</span><br><span class="line">  public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">      /**</span><br><span class="line">       * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</span><br><span class="line">       */</span><br><span class="line">      public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * Obtains and ignores the next task that the executor</span><br><span class="line">       * would otherwise execute, if one is immediately available,</span><br><span class="line">       * and then retries execution of task r, unless the executor</span><br><span class="line">       * is shut down, in which case task r is instead discarded.</span><br><span class="line">       *</span><br><span class="line">       * @param r the runnable task requested to be executed</span><br><span class="line">       * @param e the executor attempting to execute this task</span><br><span class="line">       */</span><br><span class="line">      public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">          if (!e.isShutdown()) &#123;</span><br><span class="line">              e.getQueue().poll();</span><br><span class="line">              e.execute(r);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * A handler for rejected tasks that throws a</span><br><span class="line">    * &#123;@code RejectedExecutionException&#125;.</span><br><span class="line">    */</span><br><span class="line">   public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">       /**</span><br><span class="line">        * Creates an &#123;@code AbortPolicy&#125;.</span><br><span class="line">        */</span><br><span class="line">       public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Always throws RejectedExecutionException.</span><br><span class="line">        *</span><br><span class="line">        * @param r the runnable task requested to be executed</span><br><span class="line">        * @param e the executor attempting to execute this task</span><br><span class="line">        * @throws RejectedExecutionException always.</span><br><span class="line">        */</span><br><span class="line">       public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">           throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                                &quot; rejected from &quot; +</span><br><span class="line">                                                e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">0L, TimeUnit.MILLISECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器</p>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor。下面是Executors提供的，创建使用单个线程的SingleThread-<br>Executor的API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">       return new FinalizableDelegatedExecutorService</span><br><span class="line">           (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadExecutor适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多<br>个线程是活动的应用场景</p>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool。下面是Executors提供的，创建一个会根据需要创建新线程的CachedThreadPool的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下。</p>
<ul>
<li>ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor。</li>
<li>SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">       return new DelegatedScheduledExecutorService</span><br><span class="line">           (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">      return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/liuguangqiang/article/details/52169926" target="_blank" rel="noopener">JDK1.7中的ThreadPoolExecutor源码剖析</a></p>
<p><a href="http://www.cnblogs.com/renhui/p/6066852.html" target="_blank" rel="noopener">Java Thread 的使用</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/23/Java并发编程-基础原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/23/Java并发编程-基础原理/" itemprop="url">
                  Java并发编程-基础原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-23T10:13:59+08:00">
                2017-09-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/23/Java并发编程-基础原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/23/Java并发编程-基础原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发编的挑战"><a href="#并发编的挑战" class="headerlink" title="并发编的挑战"></a>并发编的挑战</h1><h2 id="上下文切换（并行不一定比串行快）"><a href="#上下文切换（并行不一定比串行快）" class="headerlink" title="上下文切换（并行不一定比串行快）"></a>上下文切换（并行不一定比串行快）</h2><p>时间片是CPU分配给各个线程的时间，一般是几十毫秒。因为时间片非常短，所以CPU通过不停地切换线程执行，达到多个线程同时执行的效果</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换</p>
<p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程</p>
<p>无锁并发编程：如将数据的ID按照Hash算法取模分段，不同的线程处理不同的段的数据</p>
<p>CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁</p>
<p>使用最少线程：避免创建不需要的线程</p>
<p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>锁是个非常有用的工具，运用场景非常多。但同时它也会带来一些困扰，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。</p>
<p>避免死锁的常用方法</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定向锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必现在一个数据库连接池里，否则会出现解锁失败的现象</li>
</ul>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件或软件资源。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU处理速度。软件资源限制有数据库的连接数和socket连接数等。<br>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源复用。需要根据不同的资源限制调整程序的并发度</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java的并发采用的是共享内存模型，Java线程之间的通讯总是隐式进行，整个通信过程对程序员完全透明。Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入核实对另一个线程可见<br><img src="http://upload-images.jianshu.io/upload_images/5125122-2fb19f7bf25ce364?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ol>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>
<li><p>线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：</p>
<p> 把工作内存1中更新过的共享变量刷新到主内存中</p>
<p> 将主内存中最新的共享变量的值更新到工作内存2中</p>
</li>
</ol>
<h1 id="可见性、原子性、重排序"><a href="#可见性、原子性、重排序" class="headerlink" title="可见性、原子性、重排序"></a>可见性、原子性、重排序</h1><p>   可见性：一个线程对共享变量的修改，更够及时的被其他线程看到</p>
<p>   原子性：即不可再分了，不能分为多步操作。比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：</p>
<ol>
<li>　取出a和b</li>
<li>　计算a+b</li>
<li>　将计算结果写入内存</li>
</ol>
<p>重排序：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”</p>
<p> Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> class MyThread extends Thread &#123;             </span><br><span class="line">    private volatile boolean isStop = false;          </span><br><span class="line">    public void run() &#123;      </span><br><span class="line">        while (!isStop) &#123;      </span><br><span class="line">            System.out.println(&quot;do something&quot;);      </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;      </span><br><span class="line">    public void setStop() &#123;      </span><br><span class="line">        isStop = true;      </span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 线程执行run()的时候我们需要在线程中不停的做一些事情，比如while循环，那么这时候该如何停止线程呢？如果线程做的事情不是耗时的，那么只需要使用一个标志即可。如果需要退出时，调用setStop()即可。这里就使用了关键字volatile，这个关键字的目的是如果修改了isStop的值，那么在while循环中可以立即读取到修改后的值</p>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Synchronized在JVM的实现原理，主要是使用了monitorenter和monitorexit指令实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证整个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且有一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁</p>
<p>synchronized用的锁是存在Java对象头里面的。Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化<br>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-cdeffbbfe86e5c74?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<table>
<thead>
<tr>
<th>锁</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex互斥的功能，它还负责实现了Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody>
</table>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p> synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 </li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 </li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
<li>synchronized关键字不能继承</li>
</ul>
<p>## </p>
<h2 id="Synchronized和Volatile的比较"><a href="#Synchronized和Volatile的比较" class="headerlink" title="Synchronized和Volatile的比较"></a>Synchronized和Volatile的比较</h2><ol>
<li>Synchronized保证内存可见性和操作的原子性</li>
<li>Volatile只能保证内存可见性</li>
<li>Volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）</li>
<li>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）.</li>
<li>volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/guyuealian/article/details/52525724" target="_blank" rel="noopener">内存可见性和原子性：Synchronized和Volatile的比较</a></p>
<p><a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">Java中Synchronized的用法</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/14/Android程序员，你应该知道的设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/14/Android程序员，你应该知道的设计模式/" itemprop="url">
                  Android程序员，你应该知道的设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T09:32:54+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/14/Android程序员，你应该知道的设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/14/Android程序员，你应该知道的设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://upload-images.jianshu.io/upload_images/5125122-d59992dd7add23e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自百度搜索"></p>
<p>设计模式这个东西，听起来很玄乎。有时候看起来似懂非懂。平时编码中可能大部分也没考虑应该用怎样的设计来编码。</p>
<p>如果你是一个外包的人员，干完就撤。有可能确实不需要用到什么设计模式，满足功能则可。如果你是一个有产品迭代的开发人员或者代码维护人员。也许你有过背后吐槽这代码真是乱得可以，干不动了的经验。</p>
<p>在应用的开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护中让应用系统能够拥抱变化。拥抱变化也就是意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了各版本的变更之后依旧保持清晰、灵活、稳定的系统架构。</p>
<p>虽然在实际的应该开发中，要饱受产品的折磨和摧残、需要在极其有限的研发时间里完成功能、上线。为了赶工，这里Copy一份代码，哪里黏贴一个类。如果有多个项目，甚至经常在这个项目挪点功能，那个项目移植个模块，到最后干不动了，苦的还是自己。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-df5cd619b5875553?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>排除一切不可抗力因素，我们还是需要保持良好的编码习惯，在动手编码前多思考，尽量让结构更加灵活、低耦合。本文主要是对一些编码的设计原则及设计模式进行整理，便于学习及复习。</p>
<h1 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h1><table>
<thead>
<tr>
<th>原则</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一责任原则</td>
<td>就一个类而言，应该只有一个引起变化的原因</td>
<td>责任界限比较难划分，尽量满足单一责任原则。接口一定要做到单一责任原则，类的设计尽量做到只有一个引起变化的原因</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>所有引用父类的地方，必要能透明的使用其子类</td>
<td>在项目中，采用里氏替换原则，应尽量避免子类的个性（拥有自己的业务实现方法）</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</td>
<td>每个类尽量都有接口或抽象类，或者抽象类和两者都具备，任何类尽量都不应该从具体的类派生</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</td>
<td>每个类尽量都有接口或抽象类，或者抽象类和两者都具备，任何类尽量都不应该从具体的类派生</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上</td>
<td>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口和原子类来组织</td>
</tr>
<tr>
<td>迪米特原则</td>
<td>一个对象应该对自己需要耦合或调用的类知道最少，尽量不要对外公布太多的public方法和非静态的public变量</td>
<td>迪米特法则的核心观念就是类间解耦，提高类的复用率，可能产生大量的中转或者跳转类，导致系统的复杂性提高</td>
</tr>
<tr>
<td>开放封闭原则</td>
<td>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的</td>
<td>通过接口或者抽象类约束扩展，封装变化，对扩展进行边界开放</td>
</tr>
</tbody>
</table>
<p>详细可参考：<a href="http://huangjunbin.com/2017/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">设计模式-面向对象的六大设计原则</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="代码中常用的设计模式"><a href="#代码中常用的设计模式" class="headerlink" title="代码中常用的设计模式"></a>代码中常用的设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>例子</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>单例模式</td>
<td>确保某一个类只有一个实例，而且自行示例化并向整个系统提供这个实例。确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源</td>
<td>实际开发中，好多数据库Dao操作、或者Service都是直接采用单例的方式，应注意线程安全及内存泄漏问题</td>
<td><a href="http://huangjunbin.com/2017/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式 </a></td>
</tr>
<tr>
<td>建造者模式</td>
<td>Builder模式是一步一步创建一个复制对象的创建型模式，他允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程</td>
<td>new AlertDialog.Builder(self).setTitle(“列表框”).setItems(new String[] {“列表项1”,”列表项2”,”列表项3”}, null).setNegativeButton(“确定”, null) .show();有时候Activity的启动构造参数复杂，也可使用Builder模式进行控制</td>
<td><a href="http://huangjunbin.com/2017/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">建造者模式</a></td>
</tr>
<tr>
<td>适配器模式</td>
<td>适配器模式把一个类在接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作</td>
<td>ListView作为重要的控件，它需要能够显示各种各样的视图（ItemView），每个人需要的显示效果各不同。Android的做法是增加一个Adapter层来隔离变化，将ListView需要的关于Item View接口抽象到Adapter对象中，并且在ListView内部调用Adapter这些接口完成布局操作。这样只用用户实现了Adapter的接口，并且将该Adapter设置给ListView，ListView就可以按照用户设定的UI效果、数量、数据来显示每一项数据</td>
<td><a href="http://huangjunbin.com/2017/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">适配器模式</a></td>
</tr>
<tr>
<td>观察者模式</td>
<td>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统，订阅-发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小</td>
<td>广播、EventBus、Rxjava，一些上传下载进度回调监听</td>
<td><a href="http://huangjunbin.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">观察者模式 </a></td>
</tr>
<tr>
<td>外观模式</td>
<td>外观模式（Facade）在开发过程中的运用频率非常高，尤其是在现阶段各个第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式，通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节</td>
<td>例如Context统一了很多系统资源的范围，实际开发过程中使用的图片库、网络库等，提供统一的Facade，避免更换影响全局</td>
<td><a href="http://huangjunbin.com/2017/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">外观模式 </a></td>
</tr>
</tbody>
</table>
<h2 id="经常用但却不知道的设计模式"><a href="#经常用但却不知道的设计模式" class="headerlink" title="经常用但却不知道的设计模式"></a>经常用但却不知道的设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>例子</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>模板模式</td>
<td>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td>
<td>AsyncTask，在使用AsyncTask时，我们都知道把耗时的方法放在doInBackground（Params… params）中，在doInBackground之前，如果还想做一些类似初始化的操作，可以把实现卸载onPreExecutre方法中，当doInBackground方法执行完成后，会执行onPostExecutre方法</td>
<td><a href="http://huangjunbin.com/2017/01/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">模板模式 </a></td>
</tr>
<tr>
<td>中介者模式</td>
<td>该模式将对象之间的多对多关系变成一对多关系</td>
<td>Android的Activity实际就是一个中介者模式，形形式式的View交互都在Activity中统一执行，View之间彼此不交互（你有可能点一个Button,让一个ImageView变化图片，但这个逻辑不会写在Button中）</td>
<td><a href="http://huangjunbin.com/2017/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">中介者模式 </a></td>
</tr>
<tr>
<td>责任链模式</td>
<td>责任链模式是行为型设计模式之一。使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</td>
<td>在Android源码中比较类似的实现就是对于触摸事件的分发处理。每当用户接触屏幕时，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下地分发传递。ViewGroup事件投递的递归调用就类似于一条责任链，一旦寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现在View的onTouchEvent方法中返回值的设置，如果onTouchEvent返回false，那么意味着当前View不会是该次事件的复制人，将不会对其持有；如果为true则相反，此时View会持有该事件并不再向外传递</td>
<td><a href="http://huangjunbin.com/2017/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">责任链模式 </a></td>
</tr>
<tr>
<td>装饰模式</td>
<td>装饰模式也称为包装模式，结构型设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。动态地给一个对象添加一些额外的职责</td>
<td>Context类本身是一个纯abstract类，他有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象</td>
<td><a href="http://huangjunbin.com/2017/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">装饰模式 </a></td>
</tr>
<tr>
<td>组合模式</td>
<td>组合模式也称为部分整体模式，结构型设计模式之一，组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象</td>
<td>Android源码中关于组合模式有一个非常经典的实现，我们几乎每天都会使用到，那就是View和ViewGroup的嵌套组合</td>
<td><a href="http://huangjunbin.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">组合模式 </a></td>
</tr>
<tr>
<td>备忘录模式</td>
<td>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露</td>
<td>在Android开发中，状态模式应用是Android中的状态保持，也就是里面的onSaveInstanceState和onRestoreInstanceState。当Activity不是正常方式退出，且Activity在随后的时间内被系统杀死之前会调用这两个方法让开发人员可以有机会存储Activity的相关信息，并且在下次放好Activity的时候恢复这些数据</td>
<td><a href="http://huangjunbin.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">备忘录模式 </a></td>
</tr>
<tr>
<td>享元模式</td>
<td>享元模式是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</td>
<td>数据库链接池、长连接池</td>
<td><a href="http://huangjunbin.com/2017/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">享元模式 </a></td>
</tr>
<tr>
<td>迭代器模式</td>
<td>迭代器模式提供一种方法顺序访问一个容器对象的各个元素，而又不需要暴露该对象的内部表示</td>
<td>JDK中各种集合的遍历</td>
<td><a href="http://huangjunbin.com/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">迭代器模式</a></td>
</tr>
</tbody>
</table>
<h2 id="其他设计模式"><a href="#其他设计模式" class="headerlink" title="其他设计模式"></a>其他设计模式</h2><table>
<thead>
<tr>
<th>设计模式</th>
<th>速记</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>工厂模式</td>
<td>工厂模式是创建型设计模式之一。定义一个用户创建对象的接口，让子类决定实例化那个类。工厂模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用</td>
<td><a href="http://huangjunbin.com/2017/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">工厂模式</a></td>
</tr>
<tr>
<td>抽象工厂模式</td>
<td>抽象工厂也是创建型设计模式之一。为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体类。一个对象族有相同约束时可以使用抽象工厂模式</td>
<td><a href="http://huangjunbin.com/2017/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">抽象工厂模式</a></td>
</tr>
<tr>
<td>代理模式</td>
<td>为其他对象提供一种代理以控制对这个对象的访问，有静态代码和动态代理</td>
<td><a href="http://huangjunbin.com/2017/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">代理模式</a></td>
</tr>
<tr>
<td>原型模式</td>
<td>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</td>
<td><a href="http://huangjunbin.com/2017/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">原型模式</a></td>
</tr>
<tr>
<td>策略模式</td>
<td>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化</td>
<td><a href="http://huangjunbin.com/2017/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">策略模式</a></td>
</tr>
<tr>
<td>访问者模式</td>
<td>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</td>
<td><a href="http://huangjunbin.com/2017/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">访问者模式</a></td>
</tr>
<tr>
<td>状态模式</td>
<td>状态模式中的行为是由状态来决定的，不同的状态下又不同的行为。状态模式和策略模式的结构几乎完全一样，但他们的目的，本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、互相替换的</td>
<td><a href="http://huangjunbin.com/2017/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">状态模式</a></td>
</tr>
<tr>
<td>解释器模式</td>
<td>解释器模式是一种用得比较少的行为模式，其提供了一种解释语言的语法或表达式的方式，该模式定义了一个表达式接口，通过该接口解释一个特定的上下文</td>
<td><a href="http://huangjunbin.com/2017/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">解释器模式</a></td>
</tr>
<tr>
<td>桥梁模式</td>
<td>桥梁模式也称为桥接模式，是结构型设计模式之一。将抽象和实现解耦，使得两者可以独立地变化</td>
<td><a href="http://huangjunbin.com/2017/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">桥梁模式</a></td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="装饰模式、代理模式、外观模式区别"><a href="#装饰模式、代理模式、外观模式区别" class="headerlink" title="装饰模式、代理模式、外观模式区别"></a>装饰模式、代理模式、外观模式区别</h2><p>代理模式注重的是隔离限制，关注于控制对对象的访问，让外部不能访问你实际的调用对象，比如权限控制。代理和真实对象之间的的关系通常在编译时就已经确定了。<br>装饰模式注重的是功能的拓展，关注于在一个对象上动态的添加方法，在同一个方法下实现更多的功能。装饰者能够在运行时递归地被构造。<br>适配器模式注重的是接口的兼容。<br>外观模式注重的是多个类的集成、统一适配。</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《设计模式之禅》<br>《Android源码设计模式解析与实战》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/09/12/你应该知道的JDK知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/12/你应该知道的JDK知识/" itemprop="url">
                  你应该知道的JDK知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T09:28:33+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/12/你应该知道的JDK知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/12/你应该知道的JDK知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无论是从事Javaee开发或者是Android开发，JDK的基础知识都尤为重要。我们在代码里经常使用ArrayList、HashMap等，但却很少思考为什么是使用它，使用的时候需要注意什么。甚至有可能去面试的时候，人家一问HashMap的实现原理，但却只知道put和get，非常尴尬。</p>
<p>所以为了开发更高质量的程序，写出更优秀的代码，还是需要好好研究一下JDK的一些关键源码。本文主要对JDK进行一些重要的的知识的梳理及整理，便于学习及复习。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位</th>
<th>默认值 </th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8(1字节)</td>
<td>0 </td>
</tr>
<tr>
<td>short</td>
<td>16(2字节)</td>
<td>0 </td>
</tr>
<tr>
<td>int</td>
<td>32(4字节)</td>
<td>0 </td>
</tr>
<tr>
<td>long</td>
<td>64(8字节)</td>
<td>0L </td>
</tr>
<tr>
<td>float</td>
<td>32(4字节)</td>
<td>0.0f </td>
</tr>
<tr>
<td>double</td>
<td>64(8字节)</td>
<td>0.0d </td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>false </td>
</tr>
<tr>
<td>char</td>
<td>16 位 Unicode 字符</td>
<td>“” </td>
</tr>
</tbody>
</table>
<h2 id="equal-hashcode-的区别"><a href="#equal-hashcode-的区别" class="headerlink" title="equal hashcode ==的区别"></a>equal hashcode ==的区别</h2><table>
<thead>
<tr>
<th>==</th>
<th>内存地址比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>equal</td>
<td>Object默认内存地址比较，一般需要复写</td>
</tr>
<tr>
<td>hashcode</td>
<td>主要用于集合的散列表，Object默认为内存地址，一般不用设置，除非作用于散列集合。</td>
</tr>
</tbody>
</table>
<p>hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。当equals方法被重写时，通常有必要重写 hashCode 方法。但hashCode相等，不一定equals（）</p>
<h2 id="String、StringBuffer与StringBuilder的区别。"><a href="#String、StringBuffer与StringBuilder的区别。" class="headerlink" title="String、StringBuffer与StringBuilder的区别。"></a>String、StringBuffer与StringBuilder的区别。</h2><p>Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。</p>
<h1 id="Java的四种引用，强弱软虚，用到的场景。"><a href="#Java的四种引用，强弱软虚，用到的场景。" class="headerlink" title="Java的四种引用，强弱软虚，用到的场景。"></a>Java的四种引用，强弱软虚，用到的场景。</h1><p>JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.</p>
<p>强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。</p>
<p>软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null</p>
<p>弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同</p>
<p>虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有</p>
<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><p><img src="http://upload-images.jianshu.io/upload_images/5125122-32995bf94f0f4f7a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java 集合类结构图"></p>
<p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>
<p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>
<p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。 我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>
<p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>
<p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>
<p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>
<h2 id="Collection-List-Set-Map-区别"><a href="#Collection-List-Set-Map-区别" class="headerlink" title="Collection List Set Map 区别"></a>Collection List Set Map 区别</h2><table>
<thead>
<tr>
<th>接口</th>
<th>是否有序</th>
<th>允许元素重复</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>List</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>AbstractSet</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>HashSet</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>TreeSet</td>
<td>是（用二叉树排序）</td>
<td>否</td>
</tr>
<tr>
<td>AbstractMap</td>
<td>否</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td>HashMap</td>
<td>否</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td>TreeMap</td>
<td>是（用二叉树排序）</td>
<td>使用 key-value 来映射和存储数据， Key 必须惟一， value  </td>
</tr>
</tbody>
</table>
<h2 id="常用集合分析"><a href="#常用集合分析" class="headerlink" title="常用集合分析"></a>常用集合分析</h2><table>
<thead>
<tr>
<th>集合</th>
<th>主要算法</th>
<th>源码分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>基于数组的List，封装了动态增长的Object[] 数组</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-ArrayList%E3%80%81Vector/" target="_blank" rel="noopener">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-ArrayList%E3%80%81Vector/</a></td>
</tr>
<tr>
<td>Stack</td>
<td>是Vector 的子类，栈 的结构（后进先出）</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-Stack/" target="_blank" rel="noopener">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-Stack/</a></td>
</tr>
<tr>
<td>LinkedList</td>
<td>实现List，Deque；实现List，可以进行队列操作，可以通过索引来随机访问集合元素；实现Deque，也可当作双端队列，也可当作栈来使用</td>
<td><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-LinkedList/" target="_blank" rel="noopener">http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-LinkedList/</a></td>
</tr>
<tr>
<td>HashMap</td>
<td>基于哈希表的 Map 接口的实现, 使用顺序存储及链式存储的结构</td>
<td><a href="http://huangjunbin.com/2016/11/24/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9B%86%E5%90%88-HashMap%E3%80%81HashTable/" target="_blank" rel="noopener">http://huangjunbin.com/2016/11/24/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9B%86%E5%90%88-HashMap%E3%80%81HashTable/</a></td>
</tr>
<tr>
<td> LinkedHashMap</td>
<td>LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同</td>
<td><a href="https://github.com/francistao/LearningNotes/blob/master/Part2/JavaSE/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/francistao/LearningNotes/blob/master/Part2/JavaSE/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md</a></td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMap的实现是红黑树算法的实现，支持排序</td>
<td><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/26668941</a></td>
</tr>
</tbody>
</table>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>Lists</strong>    </p>
<ul>
<li>ArrayList——基于泛型数组</li>
<li>LinkedList——不推荐使用</li>
<li>Vector——已废弃（deprecated）</li>
</ul>
<p>CopyOnWriteArrayList——几乎不更新，常用来遍历</p>
<p><strong>Queues / deques</strong></p>
<ul>
<li>ArrayDeque——基于泛型数组</li>
<li>Stack——已废弃（deprecated）</li>
<li>PriorityQueue——读取操作的内容已排序</li>
</ul>
<ul>
<li>ArrayBlockingQueue——带边界的阻塞式队列</li>
<li>ConcurrentLinkedDeque / ConcurrentLinkedQueue——无边界的链表队列（CAS）</li>
<li>DelayQueue——元素带有延迟的队列</li>
<li>LinkedBlockingDeque / LinkedBlockingQueue——链表队列（带锁），可设定是否带边界</li>
<li>LinkedTransferQueue——可将元素<code>transfer</code>进行w/o存储</li>
<li>PriorityBlockingQueue——并发PriorityQueue</li>
<li>SynchronousQueue——使用Queue接口进行Exchanger</li>
</ul>
<p><strong>Maps</strong></p>
<ul>
<li>HashMap——通用Map</li>
<li>EnumMap——键使用enum</li>
<li>Hashtable——已废弃（deprecated）</li>
<li>IdentityHashMap——键使用==进行比较</li>
<li>LinkedHashMap——保持插入顺序</li>
<li>TreeMap——键已排序</li>
<li>WeakHashMap——适用于缓存（cache）</li>
</ul>
<ul>
<li>ConcurrentHashMap——通用并发Map</li>
<li>ConcurrentSkipListMap——已排序的并发Map</li>
</ul>
<p><strong>Sets</strong>    </p>
<ul>
<li>HashSet——通用set</li>
<li>EnumSet——enum Set</li>
<li>BitSet——比特或密集的整数Set</li>
<li>LinkedHashSet——保持插入顺序</li>
<li>TreeSet——排序Set</li>
</ul>
<ul>
<li>ConcurrentSkipListSet——排序并发Set</li>
<li>CopyOnWriteArraySet——几乎不更新，通常只做遍历</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Set的选择</strong></p>
<ol>
<li>HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</li>
<li>对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</li>
<li>EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</li>
<li>HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。<br>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…));</li>
</ol>
<p><strong>List 选择</strong></p>
<ol>
<li>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</li>
<li>Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)</li>
<li>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</li>
<li>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</li>
<li>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</li>
<li>当要大量的插入，删除，应当选用LinkedList；当需要快速随机访问则选用ArrayList;</li>
</ol>
<p><strong>Map 的选择</strong></p>
<ol>
<li>HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</li>
<li>TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</li>
<li>使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</li>
<li>HahMap 是利用hashCode 进行查找，而TreeMap 是保持者某种有序状态</li>
<li>所以，插入，删除，定位操作时，HashMap 是最好的选择；如果要按照自然排序或者自定义排序，那么就选择TreeMap</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.imooc.com/article/1080" target="_blank" rel="noopener">Java 学习之集合类（Collections）</a></p>
<p><a href="http://www.importnew.com/13801.html" target="_blank" rel="noopener">Java集合总览</a></p>
<p><a href="https://github.com/francistao/LearningNotes/tree/master/Part2/JavaSE" target="_blank" rel="noopener">JavaSE(Java基础)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/08/23/程序员，30而立。你是否觉得迷茫？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/23/程序员，30而立。你是否觉得迷茫？/" itemprop="url">
                  程序员，30而立。你是否觉得迷茫？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T18:03:02+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/23/程序员，30而立。你是否觉得迷茫？/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/23/程序员，30而立。你是否觉得迷茫？/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在程序员这个圈子，一直都有一种说法，程序员都是吃青春饭的。这个团体中，很多到了30岁，或者还没有到30岁的幵发者对以后的发展便感到了迷茫，当然也有可能有人没有思考过这个问题。<br>30岁了，你可能面临娶妻生子、面临房贷车贷；30岁了，你需要面临竞争、面临选择，面临日新月异的技术。当你觉得迷茫的时候，又当何去何从？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-9bf456e56c68e5b6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="转变你的想法"><a href="#转变你的想法" class="headerlink" title="转变你的想法"></a>转变你的想法</h2><h3 id="危机感"><a href="#危机感" class="headerlink" title="危机感"></a>危机感</h3><p>也许当你感到迷茫的时候，是一件好事。证明自己也是有危机感，而不是浑浑噩噩。意识到危机，才能有更好的动力去规划及调整。作为一个程序员，安安逸逸，朝九晚五，肯定是有问题的。而我们常常在一家公司久了，也容易变得温水煮青蛙，每天上班干好自己的本职工作，然后就这样日复一日。渐渐的，迷茫也就随之而来了</p>
<h3 id="为自己而工作"><a href="#为自己而工作" class="headerlink" title="为自己而工作"></a>为自己而工作</h3><p>可能有大部分人会犯一个很严重的问题。那就是认为一直都是在为公司而工作。其实每个人应该都是为自己而工作。基本没有一个人在一家公司一直长久的待着，也没有公司愿意为一个没有贡献的员工一直支付酬劳，尽管你可能是老员工了。对于自己，应该时刻让自己保持竞争力，这样才是最重要的。我们应该思考如何去提升自己的技能、如何在工作中更好的成长、如何做出更优秀的产品。</p>
<h2 id="从现在开始"><a href="#从现在开始" class="headerlink" title="从现在开始"></a>从现在开始</h2><h3 id="分析自己的不足"><a href="#分析自己的不足" class="headerlink" title="分析自己的不足"></a>分析自己的不足</h3><p>科学合理的安排自己的学习计划，根据自身的技术栈及不足进行补充，才能有效的提升自己。</p>
<p>如自身基础知识较为薄弱，可能需要计划补充基础的算法、数据结构、计算机原理、网络通信、英语等知识。</p>
<p>如技术深度不够，每天都只是重复的堆砌API，那么可能需要深入学习系统源码、框架源码、性能优化等知识</p>
<p>如沟通及人际关系的处理，作为程序员，整天与机器打交道，往往忽视了自己的沟通及人际关系，一个项目有时不止是技术才能解决问题</p>
<p>如技术广度不够，需要及时了解及掌握业内新的技术点</p>
<p>总结下来，就是需要先找出自己的不足，这是开始最重要的一步</p>
<h3 id="制度计划"><a href="#制度计划" class="headerlink" title="制度计划"></a>制度计划</h3><p>技术零零散散，永远都学不完。需要根据自己的发展规划，有意识来补充自己的短板。</p>
<p>所以有一个清晰的目标非常重要。基础的知识，作为必备要素，是需要每天进行点滴积累才能有明显的效果。然而相关的技术栈则需要有所取舍。</p>
<p>所以我们需要制定一个长期的计划及阶段的计划。分清楚那些技能是需要每天持之以恒，点滴积累，例如一些基础知识的积累。那些是阶段性攻坚可以有成果的。制定年度计划、月度计划、每周计划，来补足自己的短板。</p>
<h3 id="总结与输出"><a href="#总结与输出" class="headerlink" title="总结与输出"></a>总结与输出</h3><p>其实可能大部分人都有一种经历，就是看一本书或者学一项技能，可能过段时间就遗忘了。所以有了学习计划，为了更好的巩固，我们需要阶段性进行总结。</p>
<ol>
<li>笔记：无论是看书或者自己学习一些博客，都可以将一些重点及精华的部分做为自己的笔记，可以更好的理解及便于复习</li>
<li>博客：长期坚持写博客，可以更好的升华自己的笔记，同时也做为对自己学习的一项监督，给自己定一个目标，例如每周一篇。</li>
<li>应用：将学习的新技能及知识，找到契合点，应用到自己的项目中。也可以尝试自己开源一些示例、库等</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>也许有段时间你会松懈了，但及时的调整很重要。</p>
<p>坚持可能是一辈子的事情，放弃却是一瞬间。</p>
<p>30岁了，可能也不知道自己是否会迷茫，但最起码每天保持好的学习状态，可以让自己更加充实，不会有遗憾。</p>
<p>也许当每天都在进步，每天都在成长，迷茫也就随着而去吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/12/Android性能优化-电量优化/" itemprop="url">
                  Android性能优化-电量优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T16:40:55+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/12/Android性能优化-电量优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/12/Android性能优化-电量优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：</p>
<ol>
<li>移动设备，不能一直使用电源供电，且电池容量有限</li>
<li>对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高</li>
</ol>
<blockquote>
<p>曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡了个觉。起床发现电量只充满了70-80%，然后… …<br>最后发现是一个重要原因由于内测版本的长连接开启了日志记录，频繁的进行IO操作引起.<br>这个时候你还不能狡辩了，因为用户最简单能通过系统设置来查看应用的耗电量排名。</p>
</blockquote>
<p>在电子编程世界，这种硬件消耗电量 来执行任务的过程，叫做超时电流消耗，<br>任何电子编程专业的人都会告诉你，你的设备的各项活动在相同时间内，消耗的电量是不同的。比如，很多手机号称待机好几天，这个确实是真的，不过就是使用飞行模式放在家里什么都不干，确实可以甚至可以坚持10多天。但是我们一旦使用它，比如使用蜂窝式无线数据交换(3G4G)、屏幕保持唤醒状态等。作为开发者，我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情（所以很多设备都把这个监测电量的功能阉割掉了。）。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-f3d81d33d585aa7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google电量优化-示例图"></p>
<h1 id="手机那些地方最耗电？"><a href="#手机那些地方最耗电？" class="headerlink" title="手机那些地方最耗电？"></a>手机那些地方最耗电？</h1><h2 id="唤醒屏幕"><a href="#唤醒屏幕" class="headerlink" title="唤醒屏幕"></a>唤醒屏幕</h2><p>当用户电量屏幕的时候，意味着系统的各组件要开始进行工作，界面也需要开始执行渲染。</p>
<p>待机状态的电量消耗：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-c9a590b400a4a292?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>使用和唤醒屏幕后：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5be155e7a92274b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当设备从休眠状态中，被应用程序假面唤醒时，你会看到在第一次唤醒时，这里有一条电量使用高峰线</p>
<h2 id="CPU唤醒使用"><a href="#CPU唤醒使用" class="headerlink" title="CPU唤醒使用"></a>CPU唤醒使用</h2><p>CUP唤醒时的高峰线：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-e7c2717bc74a7d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>接下来就是后续的一些执行的消耗了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-1be98683a95ee9a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量</p>
<h2 id="蜂窝式无线"><a href="#蜂窝式无线" class="headerlink" title="蜂窝式无线"></a>蜂窝式无线</h2><p>当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。接下来还有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6ddb4cbc82b1a33a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>
<ul>
<li>Full power: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li>Low power: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li>Standby: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>
<h1 id="如何进行电量使用分析？"><a href="#如何进行电量使用分析？" class="headerlink" title="如何进行电量使用分析？"></a>如何进行电量使用分析？</h1><p>电量使用优化, 基本上是我们最不怎么关注的一项优化。可能很多公司连QA/Tester也不会关注测试App电量的使用。一般来说开发和测试的测试设备也一直是连着USB处于充电状态的,感官上也体会不到电量的损耗。要进行电量优化，我们首先得知道电都消耗到那里去了，不然如何进行针对性的优化呢？答案是通过google开源的Battery Historian来进行分析。</p>
<h2 id="电量数据收集"><a href="#电量数据收集" class="headerlink" title="电量数据收集"></a>电量数据收集</h2><p>Android 5.0及以上的设备, 允许我们通过adb命令dump出电量使用统计信息.</p>
<ol>
<li><p>因为电量统计数据是持续的, 会非常大, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys batterystats --reset</span><br><span class="line">Battery stats reset.</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开测试设备, 操作我们的待测试App.</p>
</li>
<li>重新连接设备, 使用adb命令导出相关统计数据:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.</span><br><span class="line">$ adb bugreport &gt; bugreport.txt</span><br></pre></td></tr></table></figure>
<p>导出的统计数据存储到bugreport.txt, 此时我们可以借助如下工具来图形化展示电池的消耗情况.</p>
<blockquote>
<p>注意, 官方SDK文档导出文件方式为:<br>adb shell dumpsys batterystats &gt; batterystats.txt<br>使用python historian.py batterystats.txt &gt; batterystats.html查看数据<br>是battery-historian老版本的使用方式. 目前Battery Historian已更新2.0版本, 推荐使用bugreport方式导出数据分析, 可以看到更多信息.</p>
</blockquote>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>工具开源地址: <a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">Battery Historian</a></p>
<p>根据gitbub上面介绍，Battery History工具的安装有两种方式：</p>
<ol>
<li>通过安装Docker环境来安装。（这种方式很简单，Docker真心好用，太彪悍了！）<br>Docker是一种容器，一般用于云计算和大数据平台。提倡的一种思想就是：软件即服务。这句话不是盖的，一句话就可以将别人发布的docker服务环境一次全部copy过来(注意是整个软件环境哦，相当于复制了一台一模一样的主机，连软件都不要安装了，全有了。彪悍吧！)<br>Docker只支持Windows10</li>
</ol>
<blockquote>
<p>由于笔者使用的window，无法通过Docker的方式，所以是采用第2点进行安装</p>
</blockquote>
<p>2.通过编译gitbub上面的源码来安装</p>
<p>这真是一个虐心的过程，因为Battery History是Go语言开发的。我们需要安装Go环境、Pytho环境、Git环境，并配置好相关的环境变量。具体的软件安装教程就不附上了，这里贴一下工具的下载地址。</p>
<p>Go下载地址：<a href="https://golang.org/doc/install?download=go1.7.3.windows-amd64.msi" target="_blank" rel="noopener">GO环境安装</a></p>
<p>Python下载地址：<a href="https://www.python.org/" target="_blank" rel="noopener">Python环境安装</a></p>
<p>Git下载地址：<a href="https://git-scm.com/" target="_blank" rel="noopener">Git环境安装</a></p>
<blockquote>
<p>需要注意的是, Battery Historian是Go语言的, 安装Go的时候需要配置其bin的环境变量.<br>Python环境需要是2.7的(3.x不行), 建议使用pyenv管理本地的python环境.<br>另外, 因为Battery Historian是一个网页版工具, 涉及一些JS引用, 有时需要翻墙.</p>
</blockquote>
<p>安装及成果配置环境变量后</p>
<p>1.输入命令行go get -d -u github.com/google/battery-historian/…<br>**下载到GOPATH配置目录下</p>
<p>2.进入到$GOPATH/src/github.com/google/battery-historian目录下方<br>$ cd $GOPATH/src/github.com/google/battery-historian</p>
<p>3.运行Battery Historian</p>
<p>1） go run setup.go<br>Compile Javascript files using the Closure compiler<br>$ go run setup.go<br>等待数分钟或者10分钟左右，如果仍然没有下载成功，可以手动下载，如下操作<br>**下载【closure-library】和【closure-compiler】和【flot-axislabels】，解压放到GOROOT目录下third_party文件夹下方的的closure-compiler和closure-library和flot-axislabels文件夹 ../battery-historian\third_party；如果没有均手动创建</p>
<p>2）go run cmd/battery-historian/battery-historian.go<br>Run Historian on your machine (make sure $PATH contains $GOBIN)<br>$ go run cmd/battery-historian/battery-historian.go [–port <a href="default:9999" target="_blank" rel="noopener">default:9999</a>]</p>
<p>4.检查/battery-historian是否运行，登录网址 <a href="http://localhost:9999查看" target="_blank" rel="noopener">http://localhost:9999查看</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-db908127e9e5e7ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<blockquote>
<p>千呼万唤使出来，不容易。这里建议使用Chrome浏览器，并且一定要使用VPN，不然各种莫名的问题</p>
</blockquote>
<h2 id="分析指标"><a href="#分析指标" class="headerlink" title="分析指标"></a>分析指标</h2><p>工具安装完成后，我们将adb采集的数据上传至Battery Historian，就可以得到电量的分析情况。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-8320242fc1011e82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="http://upload-images.jianshu.io/upload_images/5125122-fb4297e921d3402f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>那么关键来了，这些指标具体代表什么含义呢？这里我们来做一下解释。</p>
<ol>
<li>横坐标 </li>
</ol>
<p>横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取bugreport内容时刻为终点。我们一共采集了多长时间的数据</p>
<ol start="2">
<li>纵坐标</li>
</ol>
<p>关键的数据点我们用表格来汇总一下。</p>
<table>
<thead>
<tr>
<th>数据项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>battery_level</td>
<td>电量，可以看出电量的变化</td>
</tr>
<tr>
<td>plugged</td>
<td>充电状态，这一栏显示是否进行了充电，以及充电的时间范围</td>
</tr>
<tr>
<td>screen</td>
<td>屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息</td>
</tr>
<tr>
<td>top</td>
<td>该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app，用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助</td>
</tr>
<tr>
<td>wake_lock</td>
<td>wake_lock 该属性是记录wake_lock模块的工作时间。是否有停止的时候等</td>
</tr>
<tr>
<td>running</td>
<td>界面的状态，主要判断是否处于idle的状态。用来判断无操作状态下电量的消耗</td>
</tr>
<tr>
<td>Job</td>
<td>后台的工作，比如服务service的运行</td>
</tr>
<tr>
<td>data_conn</td>
<td>数据连接方式的改变，上面的edge是说明采用的gprs的方式连接网络的。此数据可以看出手机是使用2g，3g，4g还是wifi进行数据交换的。这一栏可以看出不同的连接方式对电量使用的影响</td>
</tr>
<tr>
<td>status</td>
<td>电池状态信息，有充电，放电，未充电，已充满，未知等不同状态</td>
</tr>
<tr>
<td>phone_signal_strength</td>
<td>手机信号状态的改变。 这一栏记录手机信号的强弱变化图，依次来判断手机信号对电量的影响</td>
</tr>
<tr>
<td>health</td>
<td>电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间</td>
</tr>
<tr>
<td>plug</td>
<td>充电方式，usb或者插座，以及显示连接的时间</td>
</tr>
<tr>
<td>Sync</td>
<td>是否跟后台同步</td>
</tr>
<tr>
<td>phone_in_call</td>
<td>是否进行通话</td>
</tr>
<tr>
<td>gps</td>
<td>gps是否开启</td>
</tr>
</tbody>
</table>
<h1 id="如何进行电量优化？"><a href="#如何进行电量优化？" class="headerlink" title="如何进行电量优化？"></a>如何进行电量优化？</h1><p>关键的地方来了。了解了手机关键耗电的地方及分析耗电的工具后。接下来就是我们的核心，如何来进行电量的优化呢？首先我们先简单总结汇总一下耗电的相关因素</p>
<ul>
<li>屏幕亮暗相关</li>
<li>设备awake,sleep的切换,尤其是唤醒.</li>
<li>CPU运行相关</li>
<li>网络</li>
<li>传感器</li>
</ul>
<p>我们接下来根据因素来逐一进行优化建议。</p>
<h2 id="点滴积累"><a href="#点滴积累" class="headerlink" title="点滴积累"></a>点滴积累</h2><p>我们都知道屏幕的渲染及CPU的运行是耗电的主要因素之一。所以其实当我们在做内存优化、渲染优化、计算优化的时候，就已然在做电量优化。所以平时的开发中，我们要注意点滴性能的优化积累，实际上当我们来做电量分析的时候，也是在找自己挖的坑。所以尽量有意识在项目的开发过程中尽量少挖坑。所以这一点是我们在分析其他优化项首先要提到的一个点。</p>
<h2 id="监听手机充电状态"><a href="#监听手机充电状态" class="headerlink" title="监听手机充电状态"></a>监听手机充电状态</h2><p>我们可以通过下面的代码来获取手机的当前充电状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// It is very easy to subscribe to changes to the battery state, but you can get the current</span><br><span class="line">// state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</span><br><span class="line">IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = this.registerReceiver(null, filter);</span><br><span class="line">int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">if (acCharge) &#123;</span><br><span class="line">    Log.v(LOG_TAG,“The phone is charging!”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时 才去执行一些非常耗电的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This method checks for power by comparing the current battery state against all possible</span><br><span class="line"> * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or</span><br><span class="line"> * wireless charge. (Wireless charge was introduced in API Level 17.)</span><br><span class="line"> */</span><br><span class="line">private boolean checkForPower() &#123;</span><br><span class="line">    // It is very easy to subscribe to changes to the battery state, but you can get the current</span><br><span class="line">    // state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</span><br><span class="line">    IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">    Intent batteryStatus = this.registerReceiver(null, filter);</span><br><span class="line"></span><br><span class="line">    // There are currently three ways a device can be plugged in. We should check them all.</span><br><span class="line">    int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">    boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);</span><br><span class="line">    boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">    boolean wirelessCharge = false;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">        wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);</span><br><span class="line">    &#125;</span><br><span class="line">    return (usbCharge || acCharge || wirelessCharge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里我们就需要思考，根据我们自己的业务，那些为了省电，可以放当手机插上电源的时候去做。<br>往往这样的情况非常多。像这些不需要及时地和用户交互的操作可以放到后面处理。<br>比如：360手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人等到云端；再比如我们自己的APP，其中有一块业务是相册备份，这个时候有一个选项控制让用户选择是否在低于15%的电量时还继续进行备份，从而避免当用户手机低电量时，任然继续进行耗电操作。</p>
</blockquote>
<h2 id="屏幕唤醒"><a href="#屏幕唤醒" class="headerlink" title="屏幕唤醒"></a>屏幕唤醒</h2><p>当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。</p>
<p>保持屏幕常亮<br>最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。<br>另一个方式是在布局文件中使用android:keepScreenOn属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:keepScreenOn=&quot;true&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。使用代码的好处是你允许你在需要的地方关闭屏幕。</p>
<p>注意：一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</p>
<blockquote>
<p>所以这里我们自己的APP需要根据业务来控制好是否保持屏幕常量。比如我们的APP需要支持视频播放。那么在播放的界面需要控制好不熄屏。当退出播放时，当然就没有了这个设置。</p>
</blockquote>
<h2 id="WakeLock"><a href="#WakeLock" class="headerlink" title="WakeLock"></a>WakeLock</h2><p>wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题。<br>需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述的FLAG_KEEP_SCREEN_ON。<br>只有一种合理的使用场景，是在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。 要使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止，这不是我们想要的。</p>
<blockquote>
<p>有的人可能认为我以前写的后台服务就没掉过链子呀运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。</p>
</blockquote>
<p>唤醒锁可划分为并识别四种用户唤醒锁：</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>CPU</th>
<th>屏幕</th>
<th>键盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>开启</td>
<td>关闭</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>开启</td>
<td>变暗</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>关闭</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>变亮</td>
</tr>
</tbody>
</table>
<p>请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。<br>第一步就是添加唤醒锁权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>直接使用唤醒锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);</span><br><span class="line">WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;MyWakelockTag&quot;);</span><br><span class="line">wakeLock.acquire();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在使用该类的时候，必须保证acquire和release是成对出现的。不然当我们业务已经不需要时，当CPU处于唤醒状态，这个时候就会损耗多余的电量。</p>
</blockquote>
<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p> 自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobSchedule的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理。这样做有两个好处：</p>
<p>避免频繁的唤醒硬件模块，造成不必要的电量消耗。<br>避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量；<br>JobScheduler的简单使用，首先自定义一个Service类，继承自JobService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedulerService extends JobService&#123;</span><br><span class="line">    private String TAG = JobSchedulerService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(JobParameters jobParameters) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStartJob:&quot; + jobParameters.getJobId());</span><br><span class="line"></span><br><span class="line">        if(true) &#123;</span><br><span class="line">            // JobService在主线程运行，如果我们这里需要处理比较耗时的业务逻辑需单独开启一条子线程来处理并返回true，</span><br><span class="line">            // 当给定的任务完成时通过调用jobFinished(JobParameters params, boolean needsRescheduled)告知系统。</span><br><span class="line"></span><br><span class="line">            //假设开启一个线程去下载文件</span><br><span class="line">            new DownloadTask().execute(jobParameters);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //如果只是在本方法内执行一些简单的逻辑话返回false就可以了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 比如我们的服务设定的约束条件为在WIFI状态下运行，结果在任务运行的过程中WIFI断开了系统</span><br><span class="line">     * 就会通过回掉onStopJob()来通知我们停止运行，正常的情况下不会回掉此方法</span><br><span class="line">     *</span><br><span class="line">     * @param jobParameters</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters jobParameters) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStopJob:&quot; + jobParameters.getJobId());</span><br><span class="line"></span><br><span class="line">        //如果需要服务在设定的约定条件再次满足时再次执行服务请返回true，反之false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DownloadTask extends AsyncTask&lt;JobParameters, Object, Object&gt; &#123;</span><br><span class="line">        JobParameters mJobParameters;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInBackground(JobParameters... jobParameterses) &#123;</span><br><span class="line">            mJobParameters = jobParameterses[0];</span><br><span class="line"></span><br><span class="line">            //比如说我们这里处理一个下载任务</span><br><span class="line">            //或是处理一些比较复杂的运算逻辑</span><br><span class="line">            //...</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(30*1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Object o) &#123;</span><br><span class="line">            super.onPostExecute(o);</span><br><span class="line">            //如果在onStartJob()中返回true的话,处理完成逻辑后一定要执行jobFinished()告知系统已完成，</span><br><span class="line">            //如果需要重新安排服务请true，反之false</span><br><span class="line">            jobFinished(mJobParameters, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得在Manifest文件内配置Service <service android:name=".JobSchedulerService" android:permission="android.permission.BIND_JOB_SERVICE"></service></p>
<p>创建工作计划<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity&#123;</span><br><span class="line">    private JobScheduler mJobScheduler;</span><br><span class="line">    private final int JOB_ID = 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.mai_layout);</span><br><span class="line"></span><br><span class="line">        mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE );</span><br><span class="line"></span><br><span class="line">        //通过JobInfo.Builder来设定触发服务的约束条件，最少设定一个条件</span><br><span class="line">        JobInfo.Builder jobBuilder = new JobInfo.Builder(JOB_ID, new ComponentName(this, JobSchedulerService.class));</span><br><span class="line"></span><br><span class="line">        //循环触发，设置任务每三秒定期运行一次</span><br><span class="line">        jobBuilder.setPeriodic(3000);</span><br><span class="line"></span><br><span class="line">        //单次定时触发，设置为三秒以后去触发。这是与setPeriodic(long time)不兼容的，</span><br><span class="line">        // 并且如果同时使用这两个函数将会导致抛出异常。</span><br><span class="line">        jobBuilder.setMinimumLatency(3000);</span><br><span class="line"></span><br><span class="line">        //在约定的时间内设置的条件都没有被触发时三秒以后开始触发。类似于setMinimumLatency(long time)，</span><br><span class="line">        // 这个函数是与 setPeriodic(long time) 互相排斥的，并且如果同时使用这两个函数，将会导致抛出异常。</span><br><span class="line">        jobBuilder.setOverrideDeadline(3000);</span><br><span class="line"></span><br><span class="line">        //在设备重新启动后设置的触发条件是否还有效</span><br><span class="line">        jobBuilder.setPersisted(false);</span><br><span class="line"></span><br><span class="line">        // 只有在设备处于一种特定的网络状态时，它才触发。</span><br><span class="line">        // JobInfo.NETWORK_TYPE_NONE,无论是否有网络均可触发，这个是默认值；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_ANY，有网络连接时就触发；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_UNMETERED，非蜂窝网络中触发；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_NOT_ROAMING，非漫游网络时才可触发；</span><br><span class="line">        jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);</span><br><span class="line"></span><br><span class="line">        //设置手机充电状态下触发</span><br><span class="line">        jobBuilder.setRequiresCharging(true);</span><br><span class="line"></span><br><span class="line">        //设置手机处于空闲状态时触发</span><br><span class="line">        jobBuilder.setRequiresDeviceIdle(true);</span><br><span class="line"></span><br><span class="line">        //得到JobInfo对象</span><br><span class="line">        JobInfo jobInfo = jobBuilder.build();</span><br><span class="line"></span><br><span class="line">        //设置开始安排任务，它将返回一个状态码</span><br><span class="line">        //JobScheduler.RESULT_SUCCESS，成功</span><br><span class="line">        //JobScheduler.RESULT_FAILURE，失败</span><br><span class="line">        if (mJobScheduler.schedule(jobInfo) == JobScheduler.RESULT_FAILURE) &#123;</span><br><span class="line">            //安排任务失败</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //停止指定JobId的工作服务</span><br><span class="line">        mJobScheduler.cancel(JOB_ID);</span><br><span class="line">        //停止全部的工作服务</span><br><span class="line">        mJobScheduler.cancelAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h2><h3 id="选择合适的Location-Provider"><a href="#选择合适的Location-Provider" class="headerlink" title="选择合适的Location Provider"></a>选择合适的Location Provider</h3><p>Android系统支持多个Location Provider：</p>
<ul>
<li>GPS_PROVIDER:</li>
</ul>
<p>GPS定位，利用GPS芯片通过卫星获得自己的位置信息。定位精准度高，一般在10米左右，耗电量大；但是在室内，GPS定位基本没用。</p>
<ul>
<li>NETWORK_PROVIDER：</li>
</ul>
<p>网络定位，利用手机基站和WIFI节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或WIF节点信息翻译成位置信息的服务器的能力。</p>
<ul>
<li>PASSIVE_PROVIDER:</li>
</ul>
<p>被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接收到消息后直接读取就可以了。比如如果系统中已经安装了百度地图，高德地图(室内可以实现精确定位)，你只要使用它们定位过后，再使用这种方法在你的程序肯定是可以拿到比较精确的定位信息。</p>
<p>例如你的App只是需要一个粗略的定位那么就不需要使用GPS进行定位，既耗费电量，定位的耗时也久。</p>
<h3 id="及时注销定位监听"><a href="#及时注销定位监听" class="headerlink" title="及时注销定位监听"></a>及时注销定位监听</h3><p>在获取到定位之后或者程序处于后台时，注销定位监听，此时监听GPS传感器相当于执行no-op（无操作指令），用户不会有感知但是却耗电。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onPause() &#123;</span><br><span class="line">    super.onPause();</span><br><span class="line">    locationManager.removeListener(locationListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onResume()&#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    locationManager.requestLocationUpdates(locationManager.getBestProvider(criteria, true),6000,100,locationListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多模块使用定位尽量复用"><a href="#多模块使用定位尽量复用" class="headerlink" title="多模块使用定位尽量复用"></a>多模块使用定位尽量复用</h3><p>多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗；例如：在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。</p>
<h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><p>使用传感器，选择合适的采样率，越高的采样率类型则越费电；</p>
<ul>
<li><p>SENSOR_DELAY_NOMAL (200000微秒)</p>
</li>
<li><p>SENSOR_DELAY_UI (60000微秒)</p>
</li>
<li><p>SENSOR_DELAY_GAME (20000微秒)</p>
</li>
<li><p>SENSOR_DELAY_FASTEST (0微秒)</p>
</li>
</ul>
<p>在后台时注意及时注销传感器监听</p>
<h2 id="Doze-and-App-Standby"><a href="#Doze-and-App-Standby" class="headerlink" title="Doze and App Standby"></a>Doze and App Standby</h2><p>最后提这一点，理论上不是电量优化，而是做电量优化要注意的一个坑。Doze and App Standby是Android 6.0以后，提供了两种省电延长电池寿命的功能。</p>
<p>具体可参考google官方介绍文档。<br><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html</a></p>
<blockquote>
<p>这个东西目前已基本无解，特别是国内的不支持google的GCM。这个地方只能控制让用户授权加入白名单来解除限制。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>
<p><a href="http://www.kancloud.cn/kancloud/android-performance/53235" target="_blank" rel="noopener">Android性能优化篇(谷歌官方)</a></p>
<p><a href="http://www.jianshu.com/p/5d83d8649c98" target="_blank" rel="noopener">Android性能优化（九）之不可忽视的电量</a></p>
<p><a href="http://www.jianshu.com/p/ebac88cdf9d6" target="_blank" rel="noopener">Android应用耗电量分析与优化建议</a></p>
<p>推荐资料(Google方法教程)</p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/index.html" target="_blank" rel="noopener">官方建议优化的一些方法</a></p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a></p>
<p><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perf" target="_blank" rel="noopener">Android 7.0新特性对电池管理进一步加强，一些新的变化可能多对我们现有的业务会造成影响需关注</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/08/JVM学习笔记-3-垃圾收集算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/08/JVM学习笔记-3-垃圾收集算法/" itemprop="url">
                  JVM学习笔记(3)-垃圾收集算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-08T14:42:19+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/JVM学习笔记-3-垃圾收集算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/08/JVM学习笔记-3-垃圾收集算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>JVM垃圾收集算法有四种：标记-清除算法、复制算法、标记-整理算法、分代收集算法</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除是最基础的收集算法。算法分为“标记”和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：</p>
<ol>
<li>效率问题，标记和清除两个过程效率都不高</li>
<li>空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程汇总需要分配大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作。其执行的过程如下：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-48b83adf2c09bf67?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题，一种称为复制的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一个块上面，然后再把已使用的内存空间一次清理掉。这样使得每次都是对整个半区域进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动栈顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高。其执行的过程如下：<br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象是98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据，我们没办法保证每次回收都有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（年老代）进行分配担保。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-806c627e99c49a50?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间闷酒需要有额外的空间进行内存分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以年老代一般不能直接选用这种算法。<br>根据年老代的特点，有人提出了另外一种“标记-整理”算法，标记过程任然与“标记-清除”算法一样，但后续步骤不足是直接对可回收对象进行清理，而是让所有的对象都向一段移动，然后直接清理掉端边界以外的内存，“标记-整理”算法其过程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-7fd6a26b4c6c579f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成手机，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
