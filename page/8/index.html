<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/8/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/8/">





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-希尔排序/" itemprop="url">
                  排序算法-希尔排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:43:28+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-希尔排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-希尔排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>希尔排序（Shell Sort）</strong><br>升级版的插入排序，先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为dl的倍数的记录放在同一个组中。先在各组内进行直接插人排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)， 即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</p>
<p>   时间复杂度：</p>
<p>1）最好情况o(n)</p>
<p>  2）最坏情况o(n^3/2)</p>
<p>性能高于插入排序 但不稳定。<br>算法稳定性:通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。<br><img src="http://img.blog.csdn.net/20161212174842643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void shellSort(int[] array) &#123;  </span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">            int i, j, gap, key;  </span><br><span class="line">            int n = array.length;  </span><br><span class="line">            for (gap = n / 2; gap &gt; 0; gap /= 2) //步长  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (i = 0; i &lt; gap; i++)        //直接插入排序  </span><br><span class="line">                &#123;  </span><br><span class="line">                    for (j = i + gap; j &lt; n; j += gap) &#123;  </span><br><span class="line">                        if (array[j] &lt; array[j - gap]) &#123;  </span><br><span class="line">                            key = array[j];  </span><br><span class="line">                            int k = j - gap;  </span><br><span class="line">                            while (k &gt;= 0 &amp;&amp; array[k] &gt; key) &#123;  </span><br><span class="line">                                array[k + gap] = array[k];  </span><br><span class="line">                                k -= gap;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            array[k + gap] = key;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 将数组的2个位置交换 </span><br><span class="line"> */  </span><br><span class="line">static void swap(int[] array, int i, int j) &#123;  </span><br><span class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </span><br><span class="line">            int temp = array[i];  </span><br><span class="line">            array[i] = array[j];  </span><br><span class="line">            array[j] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-插入排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-插入排序/" itemprop="url">
                  排序算法-插入排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:42:40+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-插入排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-插入排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>插入排序（Insert Sort）</strong><br>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的、记录数增1的有序表，类似打扑克牌排列表。</p>
<p>时间复杂度：</p>
<p> 1）最好情况o(n)</p>
<p> 2）最坏情况o(n²/4)<br> 插入排序比选择排序及冒泡排序性能好些<br> <img src="http://img.blog.csdn.net/20161212174059326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void insertSort(int[] array) &#123;  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           int i, j, key;  </span><br><span class="line">           for (i = 1; i &lt; array.length; i++) &#123;  </span><br><span class="line">               key = array[i];  </span><br><span class="line">               j = i - 1;  </span><br><span class="line">               while (j &gt;= 0 &amp;&amp; key &lt; array[j]) &#123;  </span><br><span class="line">                   array[j + 1] = array[j];//// 如果要插入的元素小于第j个元素,就将第j个元素向后移动  </span><br><span class="line">                   j--;  </span><br><span class="line">               &#125;  </span><br><span class="line">               array[j + 1] = key;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 将数组的2个位置交换 </span><br><span class="line"> */  </span><br><span class="line">static void swap(int[] array, int i, int j) &#123;  </span><br><span class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </span><br><span class="line">            int temp = array[i];  </span><br><span class="line">            array[i] = array[j];  </span><br><span class="line">            array[j] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-选择排序/" itemprop="url">
                  排序算法-选择排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:36:50+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-选择排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-选择排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>简单选择排序（Simple Selection Sort）</strong><br>就是通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1&lt;=i&lt;=n）个记录交换之</p>
<p> 时间复杂度：</p>
<p> 1） 最好情况：本身有序，需要比较n-1次 时间复杂度为o(n)</p>
<p> 2）最坏情况：逆序情况，需要比较（n-1）+(n-2)+…+2+1=n(n-1)/2 时间复杂度为o（n²）<br>性能上略优于冒泡排序 减少了交换次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void selectionSort(int[] array) &#123;  </span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">            int i, j,min;  </span><br><span class="line">            for (i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">                min=i;  </span><br><span class="line">                for (j = i + 1; j &lt; array.length; j++) &#123;  </span><br><span class="line">                    if (array[min] &gt; array[j]) &#123;  </span><br><span class="line">                        min=j;//找出最小记录  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if(i!=min)&#123;//如果最小记录位置有变化，执行交换  </span><br><span class="line">                    swap(array, i, min);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 将数组的2个位置交换 </span><br><span class="line"> */  </span><br><span class="line">static void swap(int[] array, int i, int j) &#123;  </span><br><span class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </span><br><span class="line">            int temp = array[i];  </span><br><span class="line">            array[i] = array[j];  </span><br><span class="line">            array[j] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-冒泡排序/" itemprop="url">
                  排序算法-冒泡排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:26:01+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-冒泡排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-冒泡排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>冒泡排序（Bubble BubbleSort）</strong><br>是一种交换排序，他的基本思路是： 两两比较相邻记录的关键字，如果反序则交换。<br>时间复杂度：<br>     1）最好情况：本身有序，需要比较n-1次 时间复杂度为o(n)<br>     2）最坏情况：逆序情况，需要比较（n-1）+(n-2)+…+2+1=n(n-1)/2 时间复杂度为o（n²）<br>每一轮的排序对下一轮的排序有帮助，数字如同气泡慢慢往上浮</p>
<p><img src="http://img.blog.csdn.net/20161212172353380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void bubbleSort(int[] array) &#123;  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           int i, j;  </span><br><span class="line">           for (i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">               for (j = array.length - 1; j &gt; i; j--) &#123;  </span><br><span class="line">                   if (array[j] &lt; array[j - 1]) &#123;  </span><br><span class="line">                       swap(array, j, j - 1);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    * 将数组的2个位置交换 </span><br><span class="line">    */  </span><br><span class="line">   static void swap(int[] array, int i, int j) &#123;  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </span><br><span class="line">               int temp = array[i];  </span><br><span class="line">               array[i] = array[j];  </span><br><span class="line">               array[j] = temp;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 冒泡排序优化(增加tag)，极端情况{2,1,3,4,5,6,7,8,9}后续不用交换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void bubbleSortTag(int[] array) &#123;  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           int i, j;  </span><br><span class="line">           boolean tag = true;//每一轮有木有交换数据  </span><br><span class="line">           for (i = 0; i &lt; array.length &amp;&amp; tag; i++) &#123;  </span><br><span class="line">               tag = false;  </span><br><span class="line">               for (j = array.length - 1; j &gt; i; j--) &#123;  </span><br><span class="line">                   if (array[j] &lt; array[j - 1]) &#123;  </span><br><span class="line">                       swap(array, j, j - 1);  </span><br><span class="line">                       tag = true;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/" itemprop="url">
                  查找算法-稠密索引、分块索引、倒排索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T10:28:16+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/10/查找算法-稠密索引、分块索引、倒排索引/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h1><p>稠密索引时指在线性索引中，将数据集中的每个记录都对应一个索引项 。对于索引项一定是按照关键码有序的排列 索引项有序意味着可以使用顺序查找算法，这是稠密索引的有点， 但是如果数据集非常大，意味着索引也得有同样的数据集长度规模。</p>
<p><img src="http://img.blog.csdn.net/20161210103900031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<figure class="highlight plain"><figcaption><span>&#123;  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    public int key;  </span><br><span class="line">    public Object value;  </span><br><span class="line">    public int size;//分块存储数量  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;Index&#123;&quot; +  </span><br><span class="line">                &quot;key=&quot; + key +  </span><br><span class="line">                &quot;, value=&quot; + value +  </span><br><span class="line">                &quot;, size=&quot; + size +  </span><br><span class="line">                &apos;&#125;&apos;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Comparable &#123;  </span><br><span class="line">  </span><br><span class="line">    public Student(int no, String name) &#123;  </span><br><span class="line">        this.no = no;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public int no;  </span><br><span class="line">    public String name;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;Student&#123;&quot; +  </span><br><span class="line">                &quot;no=&quot; + no +  </span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +  </span><br><span class="line">                &apos;&#125;&apos;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compareTo(Object o) &#123;  </span><br><span class="line">        Student other = (Student) o;  </span><br><span class="line">        if (no &lt; other.no) //这里比较的是什么 sort方法实现的就是按照此比较的东西从小到大排列  </span><br><span class="line">            return -1;  </span><br><span class="line">        if (no &gt; other.no)  </span><br><span class="line">            return 1;  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearch(Index[] array, int key) &#123;  </span><br><span class="line">        if (array.length &gt; 0) &#123;  </span><br><span class="line">            int low, high, mid;  </span><br><span class="line">            low = 0;  </span><br><span class="line">            high = array.length - 1;  </span><br><span class="line">            while (low &lt;= high) &#123;  </span><br><span class="line">                mid = (low + high) / 2;//折半  </span><br><span class="line">                if (key &lt; array[mid].key)  </span><br><span class="line">                    high = mid - 1;  </span><br><span class="line">                else if (key &gt; array[mid].key)  </span><br><span class="line">                    low = mid + 1;  </span><br><span class="line">                else  </span><br><span class="line">                    return mid;  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static Student denseIndex(Student[] array, int key) &#123;  </span><br><span class="line">  </span><br><span class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">        Arrays.sort(array);  </span><br><span class="line">  </span><br><span class="line">        Index[] list = new Index[array.length];  </span><br><span class="line">        //建立索引  </span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">            Index index = new Index();  </span><br><span class="line">            index.key = array[i].no;  </span><br><span class="line">            index.value = array[i];  </span><br><span class="line">            list[i] = index;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        //根据索引关键码搜索  </span><br><span class="line">        int code = binarySearch(list, key);  </span><br><span class="line">        if (code != -1) &#123;  </span><br><span class="line">            return (Student) list[code].value;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h1><p>分块有序-是吧数据集合的记录分成了若干份，并且这些块需要满足2个条件</p>
<p> 1）块内无序，即每一块内的记录不要求有序。（有序更好，但需要付出大量时间和空间代价）</p>
<p>2）块间有序-例如要求第二块所有记录的关键字均要大于第一块所有记录的关键字，第三块的所有记录要大于第二块的所有记录关键字，因为只有块间有序，才能提高查找效率<br> 分块索引的平均查找长度ASL=根号n+1  高于o(n)小于折半查找o(logn)</p>
<p><img src="http://img.blog.csdn.net/20161210103917531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int blockSearch(Index[] array, int key) &#123;  </span><br><span class="line">       if (array.length &gt; 0) &#123;  </span><br><span class="line">           int result, low, high, mid;  </span><br><span class="line">           result = 0;  </span><br><span class="line">           low = 0;  </span><br><span class="line">           high = array.length - 1;  </span><br><span class="line">           while (low &lt;= high) &#123;  </span><br><span class="line">               mid = (low + high) / 2;//折半  </span><br><span class="line">               if (key &lt; array[mid].key) &#123;  </span><br><span class="line">                   high = mid - 1;  </span><br><span class="line">                   result = high;  </span><br><span class="line">               &#125; else if (key &gt; array[mid].key) &#123;  </span><br><span class="line">                   low = mid + 1;  </span><br><span class="line">                   result = mid;  </span><br><span class="line">               &#125; else  </span><br><span class="line">                   return mid;  </span><br><span class="line"> </span><br><span class="line">           &#125;  </span><br><span class="line">           return result;  </span><br><span class="line">       &#125;  </span><br><span class="line"> </span><br><span class="line">       return -1;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public static Student blockIndex(Student[] array, int block, int key) &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">            if (block &lt; 1 || block &gt; array.length) &#123;  </span><br><span class="line">                return null;  </span><br><span class="line">            &#125;  </span><br><span class="line">            Arrays.sort(array);//为了方便构造 块内有序 其实可以无序  </span><br><span class="line">            Index[] list = new Index[block];  </span><br><span class="line">            int blocksize = array.length / block;  </span><br><span class="line">            //建立索引及数据分块  </span><br><span class="line">            for (int i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">  </span><br><span class="line">                if (i % blocksize == 0 || block == 1) &#123;//分块建立索引  </span><br><span class="line">                    Index index = new Index();  </span><br><span class="line">                    index.key = array[i].no;  </span><br><span class="line">                    index.value = array[i];  </span><br><span class="line">                    if (block == 1) &#123;//只分一块 首个是索引  </span><br><span class="line">                        index.size = array.length;  </span><br><span class="line">                        list[0] = index;  </span><br><span class="line">                        break;  </span><br><span class="line">                    &#125; else if (i / blocksize == block - 1) &#123;//长度和分块个数不均匀，剩下最后的数据放在最后一块  </span><br><span class="line">                        index.size = array.length - i;  </span><br><span class="line">                        list[block - 1] = index;  </span><br><span class="line">                        break;  </span><br><span class="line">                    &#125; else if (i / blocksize &lt; block - 1) &#123;  </span><br><span class="line">                        index.size = blocksize;  </span><br><span class="line">                        list[i / blocksize] = index;  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            //根据索引关键码搜索对应的块  </span><br><span class="line">            int mid = blockSearch(list, key);  </span><br><span class="line">            System.out.println(&quot;mid:&quot; + mid);  </span><br><span class="line">            if (mid != -1) &#123;  </span><br><span class="line">                Index index = list[mid];//找出索引  </span><br><span class="line">                System.out.println(&quot;index:&quot; + index);  </span><br><span class="line">                for (int i = 0; i &lt; index.size; i++) &#123;//块内无序 顺序查找  </span><br><span class="line">                    System.out.println(&quot;array[i]:&quot; + array[(mid * blocksize) + i]);  </span><br><span class="line">                    if (key == array[(mid * blocksize) + i].no) &#123;  </span><br><span class="line">                        return array[(mid * blocksize) + i];  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h1><p>倒排索引的概念很简单：就是将文件中的单词作为关键字，然后建立单词与文件的映射关系。 当然，你还可以添加文件中单词出现的频数等信息。 倒排索引是搜索引擎中一个很基本的概念，几乎所有的搜索引擎都会使用到倒排索引。<br>索引项的通用结构是：</p>
<p>1）次关键码，例如上面的英文单词</p>
<p>2） 记录号表，例如上面的文章编号<br> 其中记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字)</p>
<p><img src="http://img.blog.csdn.net/20161210103931110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; invertedIndex(String[] array, String word) &#123;  </span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; lists = new HashMap&lt;&gt;();  </span><br><span class="line"> if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">  //建立索引  </span><br><span class="line">         for (int i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">String page = array[i];  </span><br><span class="line">              String[] words = page.split(&quot; &quot;);  </span><br><span class="line">              for (String str : words) &#123;  </span><br><span class="line">                  if (lists.containsKey(str)) &#123;  </span><br><span class="line">                      List&lt;String&gt; pages = lists.get(str);  </span><br><span class="line">                      pages.add(array[i]);  </span><br><span class="line">                  &#125; else &#123;  </span><br><span class="line">                      List&lt;String&gt; pages = new ArrayList&lt;&gt;();  </span><br><span class="line">                      pages.add(array[i]);  </span><br><span class="line">                      lists.put(str, pages);  </span><br><span class="line">                  &#125;  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">          return lists.get(word);  </span><br><span class="line"></span><br><span class="line">      &#125;  </span><br><span class="line">      return null;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/06/查找算法-顺序查找、有序查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/06/查找算法-顺序查找、有序查找/" itemprop="url">
                  查找算法-顺序查找、有序查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-06T16:15:51+08:00">
                2016-12-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/06/查找算法-顺序查找、有序查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/06/查找算法-顺序查找、有序查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-顺序表的查找"><a href="#1-顺序表的查找" class="headerlink" title="1.顺序表的查找"></a>1.顺序表的查找</h1><h2 id="1）顺序查找"><a href="#1）顺序查找" class="headerlink" title="1）顺序查找"></a>1）顺序查找</h2><p>顺序查找又称为线性查找，是一种最简单的查找方法。<br>        从表的一端开始，向另一端逐个按要查找的值key 与关键码key进行比较，若找到，查找成功，并给出数据元素在表中的位置；若整个表检测完，仍未找到与关键码相同的key值，则查找失败，给出失败信息。<br>说白了就是，从头到尾，一个一个地比，找着相同的就成功，找不到就失败。很明显的缺点就是查找效率低。</p>
<p>【适用性】：适用于线性表的顺序存储结构和链式存储结构。<br> 平均查找长度=（n+1）/2.</p>
<p>【顺序查找优缺点】：<br>缺点:是当n 很大时，平均查找长度较大，效率低；</p>
<p>优点:是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int orederSearch(int[] array, int key) &#123;  </span><br><span class="line">       if (array.length &gt; 0) &#123;  </span><br><span class="line">           for (int i = 0; i &lt; array.length; i++) &#123;  </span><br><span class="line">               if (array[i] == key) &#123;  </span><br><span class="line">                   return i;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       return -1;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-有序表的查找"><a href="#2-有序表的查找" class="headerlink" title="2.有序表的查找"></a>2.有序表的查找</h1><h2 id="1）折半查找"><a href="#1）折半查找" class="headerlink" title="1）折半查找"></a>1）折半查找</h2><p> 在有序表中，取中间元素作为比较对象，若给定值与中间元素的关键码key相等，则查找成功；若给定值小于中间元素的关键码，则在中间元素的左半区继续查找；若给定值大于中间元素的关键码，则在中间元素的右半区继续查找。不断重复上述查找过程，直到查找成功，或所查找的区域无数据元素，查找失败。时间复杂度为o(logn)</p>
<p>折半查找的前提条件是需要有序的顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好。但是对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，不建议使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearch(int[] array, int key) &#123;  </span><br><span class="line">    if (array.length &gt; 0) &#123;  </span><br><span class="line">        int low, high, mid;  </span><br><span class="line">        low = 0;  </span><br><span class="line">        high = array.length - 1;  </span><br><span class="line">        while (low &lt;= high) &#123;  </span><br><span class="line">            mid = (low + high) / 2;//折半  </span><br><span class="line">            if (key &lt; array[mid])  </span><br><span class="line">                high = mid - 1;  </span><br><span class="line">            else if (key &gt; array[mid])  </span><br><span class="line">                low = mid + 1;  </span><br><span class="line">            else  </span><br><span class="line">                return mid;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return -1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2）插值查找"><a href="#2）插值查找" class="headerlink" title="2）插值查找"></a>2）插值查找</h2><p> 插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int interpolationSearch(int[] array, int key) &#123;  </span><br><span class="line">       if (array.length &gt; 0) &#123;  </span><br><span class="line">           int low, high, mid;  </span><br><span class="line">           low = 0;  </span><br><span class="line">           high = array.length - 1;  </span><br><span class="line">           while (low &lt;= high) &#123;  </span><br><span class="line">               mid = low + (high - low) * (key - array[low]) / (array[high] - array[low]);//插值  </span><br><span class="line">               if (key &lt; array[mid])  </span><br><span class="line">                   high = mid - 1;  </span><br><span class="line">               else if (key &gt; array[mid])  </span><br><span class="line">                   low = mid + 1;  </span><br><span class="line">               else  </span><br><span class="line">                   return mid;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       return -1;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3）斐波那契查找"><a href="#3）斐波那契查找" class="headerlink" title="3）斐波那契查找"></a>3）斐波那契查找</h1><p>斐波那契查找的前提是待查找的查找表必须顺序存储并且有序。时间复杂度o(logn)<br>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。</p>
<p>他要求开始表中记录的个数为某个斐波那契数小1，及n=Fk-1;</p>
<p>开始将k值与第F(k-1）位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<p>1）相等，mid位置的元素即为所求</p>
<p>2）&gt; ,low=mid+1,k-=2;<br>    说明:low=mid+1说明待查找的元素在[mid+1,hign]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-（F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找</p>
<p>3)&lt; ,high=mid-1,k-=1;<br>    说明:low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1 个，所以可以递归 的应用斐波那契查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public static int fbnacciSearch(int[] array, int key) &#123;  </span><br><span class="line">       if (array == null || array.length == 0) &#123;  </span><br><span class="line">           return -1;  </span><br><span class="line">       &#125; else &#123;  </span><br><span class="line">           int length=array.length;  </span><br><span class="line">           int[] fb=makeFbnacciArray(20);  </span><br><span class="line">           int k=0;  </span><br><span class="line">           while (length&gt;fb[k]-1)&#123;//找出数组的长度在斐波那契数列中的位置 n&lt;=F[k]-1  </span><br><span class="line">               k++;  </span><br><span class="line">           &#125;  </span><br><span class="line">           //n不一定刚刚好等于F[k]-1 此时扩容原数组 新增的位置的值为原数组的最大值  </span><br><span class="line">           int[] temp= Arrays.copyOf(array,fb[k]-1);  </span><br><span class="line">           for (int i=length;i&lt;temp.length;i++)&#123;  </span><br><span class="line">               if(i&gt;=length)&#123;  </span><br><span class="line">                   temp[i]=array[length-1];  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           int low=0;  </span><br><span class="line">           int high=array.length-1;  </span><br><span class="line">           while (low&lt;=high)&#123;  </span><br><span class="line">               int middle=low+fb[k-1]-1;  </span><br><span class="line">               if(temp[middle]&gt;key)&#123;  </span><br><span class="line">                   high=middle-1;  </span><br><span class="line">                   k=k-1;  </span><br><span class="line">               &#125;else if(temp[middle]&lt;key)&#123;  </span><br><span class="line">                   low=middle+1;  </span><br><span class="line">                   k=k-2;  </span><br><span class="line">               &#125;else&#123;  </span><br><span class="line">                   if(middle&lt;=high)&#123;  </span><br><span class="line">                       return  middle;//若相等则说明middle为查找的位置  </span><br><span class="line">                   &#125;else&#123;  </span><br><span class="line">                       return high;//middle的值已经大于high，进入扩展数组的填充部分，既最后一个数就是要查找的数  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       return -1;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   private static int[] makeFbnacciArray(int length) &#123;  </span><br><span class="line">       int array[] = null;  </span><br><span class="line">       if (length &gt; 2) &#123;  </span><br><span class="line">           array = new int[length];  </span><br><span class="line">           array[0] = 1;  </span><br><span class="line">           array[1] = 1;  </span><br><span class="line">           for (int i = 2; i &lt; length; i++) &#123;  </span><br><span class="line">               array[i] = array[i - 1] + array[i - 2];  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (length == 2) &#123;  </span><br><span class="line">           array = new int[length];  </span><br><span class="line">           array[0] = 1;  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (length == 1) &#123;  </span><br><span class="line">           array = new int[length];  </span><br><span class="line">           array[0] = 1;  </span><br><span class="line">           array[1] = 1;  </span><br><span class="line">       &#125;  </span><br><span class="line">       return array;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>三种有序表的查找本质是分割点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做选择。这里注意主要的运算，折半查找采用乘除（mid = (low + high) / 2）、插值采用的是四则运算（  mid = low + (high - low) * (key - array[low]) / (array[high] - array[low])），斐波那契采用的是加减（middle=low+fb[k-1]-1）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/05/Android的Window底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/05/Android的Window底层原理/" itemprop="url">
                  Android的Window底层原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-05T12:00:11+08:00">
                2016-12-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/05/Android的Window底层原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/05/Android的Window底层原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Window是一个抽象类，他的实现是PhoneWindow。Window通过WindowManager创建，是访问Window的入口。Window的具体实现位于WindowManagerService中，WIndowManager与WindowManagerService的交互是一个IPC的过程。</p>
<p>WindowManager中的Layoutparam中的Type表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，他需要附属在特定的父Window，例如Dialog。系统Window是需要在声明权限在能创建Window，比如Toast。</p>
<p>Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999。对应着LayoutParams的type参数。层级大的会覆盖在层级小的Window上面。</p>
<p>Layoutparams</p>
<p>  public static final int FIRST_SUB_WINDOW = 1000;</p>
<p>  public static final int FIRST_SYSTEM_WINDOW = 2000;</p>
<h1 id="2-Window的内部实现机制"><a href="#2-Window的内部实现机制" class="headerlink" title="2.Window的内部实现机制"></a>2.Window的内部实现机制</h1><h2 id="2-1Window、PhoneWindow、DecorView"><a href="#2-1Window、PhoneWindow、DecorView" class="headerlink" title="2.1Window、PhoneWindow、DecorView"></a>2.1Window、PhoneWindow、DecorView</h2><p><img src="http://img.blog.csdn.net/20161205120243264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p><img src="http://img.blog.csdn.net/20161205120302122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>window是一个抽象类，提供一组通用的绘制窗口API，可抽象理解为一个载体，各种View在这个载体上显示</p>
<p>PhoneWindow是window类的实现，类内部包含一个DecorView</p>
<p>DecorView是一个FragmeLayout的子类，该DecorView对象时所有应用窗口的根View<br>Activity的setContentView调用到PhoneView的setConteView，如果没有DecorView，那么就创建他，将View添加到DecorView的mContentParent中，回调Activity的onContentChanged方法通知Activity视图已经发生改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">  public void setContentView(int layoutResID) &#123;  </span><br><span class="line">  // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window  </span><br><span class="line">  // decor, when theme attributes and the like are crystalized. Do not check the feature  </span><br><span class="line">  // before this happens.  </span><br><span class="line">  if (mContentParent == null) &#123;  </span><br><span class="line">  installDecor();//创建DecorView  </span><br><span class="line">  &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;//所以Activity可以多次的setContetView-  </span><br><span class="line">  mContentParent.removeAllViews();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;  </span><br><span class="line">  final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,  </span><br><span class="line">  getContext());  </span><br><span class="line">  transitionTo(newScene);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">  &#125;  </span><br><span class="line">  mContentParent.requestApplyInsets();  </span><br><span class="line">  final Callback cb = getCallback();  </span><br><span class="line">  if (cb != null &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">  cb.onContentChanged();  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;  </span><br><span class="line">if (mDecor == null) &#123;  </span><br><span class="line">mDecor = generateDecor();  </span><br><span class="line">mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">mDecor.setIsRootNamespace(true);  </span><br><span class="line">if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;  </span><br><span class="line">mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">if (mContentParent == null) &#123;  </span><br><span class="line">mContentParent = generateLayout(mDecor);  </span><br><span class="line">  </span><br><span class="line">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.  </span><br><span class="line">mDecor.makeOptionalFitsSystemWindows();  </span><br><span class="line">  </span><br><span class="line">final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(  </span><br><span class="line">R.id.decor_content_parent);  </span><br><span class="line">  </span><br><span class="line">if (decorContentParent != null) &#123;  </span><br><span class="line">mDecorContentParent = decorContentParent;  </span><br><span class="line">mDecorContentParent.setWindowCallback(getCallback());  </span><br><span class="line">if (mDecorContentParent.getTitle() == null) &#123;  </span><br><span class="line">mDecorContentParent.setWindowTitle(mTitle);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">final int localFeatures = getLocalFeatures();  </span><br><span class="line">for (int i = 0; i &lt; FEATURE_MAX; i++) &#123;  </span><br><span class="line">if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123;  </span><br><span class="line">mDecorContentParent.initFeature(i);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mDecorContentParent.setUiOptions(mUiOptions);  </span><br><span class="line">  </span><br><span class="line">if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 ||  </span><br><span class="line">(mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123;  </span><br><span class="line">mDecorContentParent.setIcon(mIconRes);  </span><br><span class="line">&#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp;  </span><br><span class="line">mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123;  </span><br><span class="line">mDecorContentParent.setIcon(  </span><br><span class="line">getContext().getPackageManager().getDefaultActivityIcon());  </span><br><span class="line">mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;  </span><br><span class="line">&#125;  </span><br><span class="line">if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 ||  </span><br><span class="line">(mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123;  </span><br><span class="line">mDecorContentParent.setLogo(mLogoRes);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Invalidate if the panel menu hasn&apos;t been created before this.  </span><br><span class="line">// Panel menu invalidation is deferred avoiding application onCreateOptionsMenu  </span><br><span class="line">// being called in the middle of onCreate or similar.  </span><br><span class="line">// A pending invalidation will typically be resolved before the posted message  </span><br><span class="line">// would run normally in order to satisfy instance state restoration.  </span><br><span class="line">PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);  </span><br><span class="line">if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123;  </span><br><span class="line">invalidatePanelMenu(FEATURE_ACTION_BAR);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">mTitleView = (TextView)findViewById(R.id.title);  </span><br><span class="line">if (mTitleView != null) &#123;  </span><br><span class="line">mTitleView.setLayoutDirection(mDecor.getLayoutDirection());  </span><br><span class="line">if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;  </span><br><span class="line">View titleContainer = findViewById(  </span><br><span class="line">R.id.title_container);  </span><br><span class="line">if (titleContainer != null) &#123;  </span><br><span class="line">titleContainer.setVisibility(View.GONE);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">mTitleView.setVisibility(View.GONE);  </span><br><span class="line">&#125;  </span><br><span class="line">if (mContentParent instanceof FrameLayout) &#123;  </span><br><span class="line">((FrameLayout)mContentParent).setForeground(null);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">mTitleView.setText(mTitle);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123;  </span><br><span class="line">mDecor.setBackgroundFallback(mBackgroundFallbackResource);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Only inflate or create a new TransitionManager if the caller hasn&apos;t  </span><br><span class="line">// already set a custom one.  </span><br><span class="line">if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;  </span><br><span class="line">if (mTransitionManager == null) &#123;  </span><br><span class="line">final int transitionRes = getWindowStyle().getResourceId(  </span><br><span class="line">R.styleable.Window_windowContentTransitionManager,  </span><br><span class="line">0);  </span><br><span class="line">if (transitionRes != 0) &#123;  </span><br><span class="line">final TransitionInflater inflater = TransitionInflater.from(getContext());  </span><br><span class="line">mTransitionManager = inflater.inflateTransitionManager(transitionRes,  </span><br><span class="line">mContentParent);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">mTransitionManager = new TransitionManager();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mEnterTransition = getTransition(mEnterTransition, null,  </span><br><span class="line">R.styleable.Window_windowEnterTransition);  </span><br><span class="line">mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION,  </span><br><span class="line">R.styleable.Window_windowReturnTransition);  </span><br><span class="line">mExitTransition = getTransition(mExitTransition, null,  </span><br><span class="line">R.styleable.Window_windowExitTransition);  </span><br><span class="line">mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION,  </span><br><span class="line">R.styleable.Window_windowReenterTransition);  </span><br><span class="line">mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null,  </span><br><span class="line">R.styleable.Window_windowSharedElementEnterTransition);  </span><br><span class="line">mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition,  </span><br><span class="line">USE_DEFAULT_TRANSITION,  </span><br><span class="line">R.styleable.Window_windowSharedElementReturnTransition);  </span><br><span class="line">mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null,  </span><br><span class="line">R.styleable.Window_windowSharedElementExitTransition);  </span><br><span class="line">mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition,  </span><br><span class="line">USE_DEFAULT_TRANSITION,  </span><br><span class="line">R.styleable.Window_windowSharedElementReenterTransition);  </span><br><span class="line">if (mAllowEnterTransitionOverlap == null) &#123;  </span><br><span class="line">mAllowEnterTransitionOverlap = getWindowStyle().getBoolean(  </span><br><span class="line">R.styleable.Window_windowAllowEnterTransitionOverlap, true);  </span><br><span class="line">&#125;  </span><br><span class="line">if (mAllowReturnTransitionOverlap == null) &#123;  </span><br><span class="line">mAllowReturnTransitionOverlap = getWindowStyle().getBoolean(  </span><br><span class="line">R.styleable.Window_windowAllowReturnTransitionOverlap, true);  </span><br><span class="line">&#125;  </span><br><span class="line">if (mBackgroundFadeDurationMillis &lt; 0) &#123;  </span><br><span class="line">mBackgroundFadeDurationMillis = getWindowStyle().getInteger(  </span><br><span class="line">R.styleable.Window_windowTransitionBackgroundFadeDuration,  </span><br><span class="line">DEFAULT_BACKGROUND_FADE_DURATION_MS);  </span><br><span class="line">&#125;  </span><br><span class="line">if (mSharedElementsUseOverlay == null) &#123;  </span><br><span class="line">mSharedElementsUseOverlay = getWindowStyle().getBoolean(  </span><br><span class="line">R.styleable.Window_windowSharedElementsUseOverlay, true);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2WindowManager、WindowManagerGlobal、ViewRootImpl、WindowManagerService"><a href="#2-2WindowManager、WindowManagerGlobal、ViewRootImpl、WindowManagerService" class="headerlink" title="2.2WindowManager、WindowManagerGlobal、ViewRootImpl、WindowManagerService"></a>2.2WindowManager、WindowManagerGlobal、ViewRootImpl、WindowManagerService</h2><p><img src="http://img.blog.csdn.net/20161205120419701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<ol>
<li>WindowManagerImpl是客户端WindowManager管理接口的实现，WindowManagerImpl内部维护一个单例的WindowManagerGlobal对象，WindowManagerImpl通过该对象转发客户端的窗口管理请求。客户端在创建窗口时首先调用getWindowManager获得本地窗口管理对象，并调用其addView、removeView、UpdateViewLayout为窗口进行布局控制</li>
<li>ViewManagerImp是Viewmanager的实现，该类并没有直接实现Window的操作，而是由WindowmanagerGlobal进行操作。</li>
<li>WindowManagerGlobal对象内部维护一个ViewRootImpl实例数组和一个View视图对象数组，WindowmanagerGlobal的addView函数首先查看要添加的视图是否已经存在，若不存在则实例化一个ViewRootImpl对象，并把view和ViewRootImpl对象及布局参数保存到本地数组中，接着调用ViewRootImpl对象的setView函数；removeView通过调用ViewRootImpl的die方法进行，最终调用dispatchDetachedFromWindow进行移除;updateViewLayout首先更新View的LayoutParams并替换掉老的LayoutParams，接着更新ViewRootImpl的Layoutparams,通过调用scheduleTraversals对View重新布局</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();  </span><br><span class="line">  private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();  </span><br><span class="line">  private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =  </span><br><span class="line">  new ArrayList&lt;WindowManager.LayoutParams&gt;();  </span><br><span class="line">  private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,  </span><br><span class="line">Display display, Window parentWindow) &#123;  </span><br><span class="line">if (view == null) &#123;  </span><br><span class="line">throw new IllegalArgumentException(&quot;view must not be null&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">if (display == null) &#123;  </span><br><span class="line">throw new IllegalArgumentException(&quot;display must not be null&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">if (!(params instanceof WindowManager.LayoutParams)) &#123;  </span><br><span class="line">throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;  </span><br><span class="line">if (parentWindow != null) &#123;  </span><br><span class="line">parentWindow.adjustLayoutParamsForSubWindow(wparams);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">// If there&apos;s no parent, then hardware acceleration for this view is  </span><br><span class="line">// set from the application&apos;s hardware acceleration setting.  </span><br><span class="line">final Context context = view.getContext();  </span><br><span class="line">if (context != null  </span><br><span class="line">&amp;&amp; (context.getApplicationInfo().flags  </span><br><span class="line">&amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123;  </span><br><span class="line">wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ViewRootImpl root;  </span><br><span class="line">View panelParentView = null;  </span><br><span class="line">  </span><br><span class="line">synchronized (mLock) &#123;  </span><br><span class="line">// Start watching for system property changes.  </span><br><span class="line">if (mSystemPropertyUpdater == null) &#123;  </span><br><span class="line">mSystemPropertyUpdater = new Runnable() &#123;  </span><br><span class="line">@Override public void run() &#123;  </span><br><span class="line">synchronized (mLock) &#123;  </span><br><span class="line">for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123;  </span><br><span class="line">mRoots.get(i).loadSystemProperties();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">SystemProperties.addChangeCallback(mSystemPropertyUpdater);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int index = findViewLocked(view, false);  </span><br><span class="line">if (index &gt;= 0) &#123;  </span><br><span class="line">if (mDyingViews.contains(view)) &#123;  </span><br><span class="line">// Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.  </span><br><span class="line">mRoots.get(index).doDie();  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">throw new IllegalStateException(&quot;View &quot; + view  </span><br><span class="line">+ &quot; has already been added to the window manager.&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">// The previous removeView() had not completed executing. Now it has.  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// If this is a panel window, then find the window it is being  </span><br><span class="line">// attached to for future reference.  </span><br><span class="line">if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;  </span><br><span class="line">wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;  </span><br><span class="line">final int count = mViews.size();  </span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;  </span><br><span class="line">if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;  </span><br><span class="line">panelParentView = mViews.get(i);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">root = new ViewRootImpl(view.getContext(), display);  </span><br><span class="line">  </span><br><span class="line">view.setLayoutParams(wparams);  </span><br><span class="line">  </span><br><span class="line">mViews.add(view);  </span><br><span class="line">mRoots.add(root);  </span><br><span class="line">mParams.add(wparams);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// do this last because it fires off messages to start doing things  </span><br><span class="line">try &#123;  </span><br><span class="line">root.setView(view, wparams, panelParentView);  </span><br><span class="line">&#125; catch (RuntimeException e) &#123;  </span><br><span class="line">// BadTokenException or InvalidDisplayException, clean up.  </span><br><span class="line">synchronized (mLock) &#123;  </span><br><span class="line">final int index = findViewLocked(view, false);  </span><br><span class="line">if (index &gt;= 0) &#123;  </span><br><span class="line">removeViewLocked(index, true);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">throw e;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;  </span><br><span class="line">if (view == null) &#123;  </span><br><span class="line">throw new IllegalArgumentException(&quot;view must not be null&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">if (!(params instanceof WindowManager.LayoutParams)) &#123;  </span><br><span class="line">throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;  </span><br><span class="line">  </span><br><span class="line">view.setLayoutParams(wparams);  </span><br><span class="line">  </span><br><span class="line">synchronized (mLock) &#123;  </span><br><span class="line">int index = findViewLocked(view, true);  </span><br><span class="line">ViewRootImpl root = mRoots.get(index);  </span><br><span class="line">mParams.remove(index);  </span><br><span class="line">mParams.add(index, wparams);  </span><br><span class="line">root.setLayoutParams(wparams, false);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">[java] view plain copy</span><br><span class="line">public void removeView(View view, boolean immediate) &#123;  </span><br><span class="line">  if (view == null) &#123;  </span><br><span class="line">  throw new IllegalArgumentException(&quot;view must not be null&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  synchronized (mLock) &#123;  </span><br><span class="line">  int index = findViewLocked(view, true);  </span><br><span class="line">  View curView = mRoots.get(index).getView();  </span><br><span class="line">  removeViewLocked(index, immediate);  </span><br><span class="line">  if (curView == view) &#123;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  throw new IllegalStateException(&quot;Calling with view &quot; + view  </span><br><span class="line">  + &quot; but the ViewAncestor is attached to &quot; + curView);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  private void removeViewLocked(int index, boolean immediate) &#123;  </span><br><span class="line">  ViewRootImpl root = mRoots.get(index);  </span><br><span class="line">  View view = root.getView();  </span><br><span class="line">  </span><br><span class="line">  if (view != null) &#123;  </span><br><span class="line">  InputMethodManager imm = InputMethodManager.getInstance();  </span><br><span class="line">  if (imm != null) &#123;  </span><br><span class="line">  imm.windowDismissed(mViews.get(index).getWindowToken());  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  boolean deferred = root.die(immediate);  </span><br><span class="line">  if (view != null) &#123;  </span><br><span class="line">  view.assignParent(null);  </span><br><span class="line">  if (deferred) &#123;  </span><br><span class="line">  mDyingViews.add(view);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>ViewRootImpl是视图处理类，是客户端视图的处理类，客户端的视图通过该类与窗口管理服务交互，因此ViewRootImpl是一个中介类。ViewRootImpl内部包含一个从IWindow.Stub派生的内部类（ViewRootImpl.W），窗口管理服务通过该对象可以与客户端反向通讯。<br>setView内部通过requestLayout来完成异步刷新请求，scheduleTraversals实际是View绘制的入口，通过调用performTraversals对View进行measure、layout、draw，最后通过pokeDrawLockIfNeeded进行IPC。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"> public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;  </span><br><span class="line"> synchronized (this) &#123;  </span><br><span class="line"> if (mView == null) &#123;  </span><br><span class="line"> mView = view;  </span><br><span class="line">  </span><br><span class="line"> mAttachInfo.mDisplayState = mDisplay.getState();  </span><br><span class="line"> mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);  </span><br><span class="line">  </span><br><span class="line"> mViewLayoutDirectionInitial = mView.getRawLayoutDirection();  </span><br><span class="line"> mFallbackEventHandler.setView(view);  </span><br><span class="line"> mWindowAttributes.copyFrom(attrs);  </span><br><span class="line"> if (mWindowAttributes.packageName == null) &#123;  </span><br><span class="line"> mWindowAttributes.packageName = mBasePackageName;  </span><br><span class="line"> &#125;  </span><br><span class="line"> attrs = mWindowAttributes;  </span><br><span class="line"> // Keep track of the actual window flags supplied by the client.  </span><br><span class="line"> mClientWindowLayoutFlags = attrs.flags;  </span><br><span class="line">  </span><br><span class="line"> setAccessibilityFocus(null, null);  </span><br><span class="line">  </span><br><span class="line"> if (view instanceof RootViewSurfaceTaker) &#123;  </span><br><span class="line"> mSurfaceHolderCallback =  </span><br><span class="line"> ((RootViewSurfaceTaker)view).willYouTakeTheSurface();  </span><br><span class="line"> if (mSurfaceHolderCallback != null) &#123;  </span><br><span class="line"> mSurfaceHolder = new TakenSurfaceHolder();  </span><br><span class="line"> mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> // Compute surface insets required to draw at specified Z value.  </span><br><span class="line"> // TODO: Use real shadow insets for a constant max Z.  </span><br><span class="line"> if (!attrs.hasManualSurfaceInsets) &#123;  </span><br><span class="line"> final int surfaceInset = (int) Math.ceil(view.getZ() * 2);  </span><br><span class="line"> attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();  </span><br><span class="line"> mTranslator = compatibilityInfo.getTranslator();  </span><br><span class="line">  </span><br><span class="line"> // If the application owns the surface, don&apos;t enable hardware acceleration  </span><br><span class="line"> if (mSurfaceHolder == null) &#123;  </span><br><span class="line"> enableHardwareAcceleration(attrs);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> boolean restore = false;  </span><br><span class="line"> if (mTranslator != null) &#123;  </span><br><span class="line"> mSurface.setCompatibilityTranslator(mTranslator);  </span><br><span class="line"> restore = true;  </span><br><span class="line"> attrs.backup();  </span><br><span class="line"> mTranslator.translateWindowLayout(attrs);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (DEBUG_LAYOUT) Log.d(TAG, &quot;WindowLayout in setView:&quot; + attrs);  </span><br><span class="line">  </span><br><span class="line"> if (!compatibilityInfo.supportsScreen()) &#123;  </span><br><span class="line"> attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;  </span><br><span class="line"> mLastInCompatMode = true;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> mSoftInputMode = attrs.softInputMode;  </span><br><span class="line"> mWindowAttributesChanged = true;  </span><br><span class="line"> mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;  </span><br><span class="line"> mAttachInfo.mRootView = view;  </span><br><span class="line"> mAttachInfo.mScalingRequired = mTranslator != null;  </span><br><span class="line"> mAttachInfo.mApplicationScale =  </span><br><span class="line"> mTranslator == null ? 1.0f : mTranslator.applicationScale;  </span><br><span class="line"> if (panelParentView != null) &#123;  </span><br><span class="line"> mAttachInfo.mPanelParentWindowToken  </span><br><span class="line"> = panelParentView.getApplicationWindowToken();  </span><br><span class="line"> &#125;  </span><br><span class="line"> mAdded = true;  </span><br><span class="line"> int res; /* = WindowManagerImpl.ADD_OKAY; */  </span><br><span class="line">  </span><br><span class="line"> // Schedule the first layout -before- adding to the window  </span><br><span class="line"> // manager, to make sure we do the relayout before receiving  </span><br><span class="line"> // any other events from the system.  </span><br><span class="line"> requestLayout();  </span><br><span class="line"> if ((mWindowAttributes.inputFeatures  </span><br><span class="line"> &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;  </span><br><span class="line"> mInputChannel = new InputChannel();  </span><br><span class="line"> &#125;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> mOrigWindowType = mWindowAttributes.type;  </span><br><span class="line"> mAttachInfo.mRecomputeGlobalAttributes = true;  </span><br><span class="line"> collectViewAttributes();  </span><br><span class="line"> res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,  </span><br><span class="line"> getHostVisibility(), mDisplay.getDisplayId(),  </span><br><span class="line"> mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,  </span><br><span class="line"> mAttachInfo.mOutsets, mInputChannel);  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> mAdded = false;  </span><br><span class="line"> mView = null;  </span><br><span class="line"> mAttachInfo.mRootView = null;  </span><br><span class="line"> mInputChannel = null;  </span><br><span class="line"> mFallbackEventHandler.setView(null);  </span><br><span class="line"> unscheduleTraversals();  </span><br><span class="line"> setAccessibilityFocus(null, null);  </span><br><span class="line"> throw new RuntimeException(&quot;Adding window failed&quot;, e);  </span><br><span class="line"> &#125; finally &#123;  </span><br><span class="line"> if (restore) &#123;  </span><br><span class="line"> attrs.restore();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (mTranslator != null) &#123;  </span><br><span class="line"> mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);  </span><br><span class="line"> &#125;  </span><br><span class="line"> mPendingOverscanInsets.set(0, 0, 0, 0);  </span><br><span class="line"> mPendingContentInsets.set(mAttachInfo.mContentInsets);  </span><br><span class="line"> mPendingStableInsets.set(mAttachInfo.mStableInsets);  </span><br><span class="line"> mPendingVisibleInsets.set(0, 0, 0, 0);  </span><br><span class="line"> if (DEBUG_LAYOUT) Log.v(TAG, &quot;Added window &quot; + mWindow);  </span><br><span class="line"> if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;  </span><br><span class="line"> mAttachInfo.mRootView = null;  </span><br><span class="line"> mAdded = false;  </span><br><span class="line"> mFallbackEventHandler.setView(null);  </span><br><span class="line"> unscheduleTraversals();  </span><br><span class="line"> setAccessibilityFocus(null, null);  </span><br><span class="line"> switch (res) &#123;  </span><br><span class="line"> case WindowManagerGlobal.ADD_BAD_APP_TOKEN:  </span><br><span class="line"> case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window -- token &quot; + attrs.token  </span><br><span class="line"> + &quot; is not valid; is your activity running?&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_NOT_APP_TOKEN:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window -- token &quot; + attrs.token  </span><br><span class="line"> + &quot; is not for an application&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_APP_EXITING:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window -- app for token &quot; + attrs.token  </span><br><span class="line"> + &quot; is exiting&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_DUPLICATE_ADD:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window -- window &quot; + mWindow  </span><br><span class="line"> + &quot; has already been added&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:  </span><br><span class="line"> // Silently ignore -- we would have just removed it  </span><br><span class="line"> // right away, anyway.  </span><br><span class="line"> return;  </span><br><span class="line"> case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window &quot; + mWindow +  </span><br><span class="line"> &quot; -- another window of this type already exists&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_PERMISSION_DENIED:  </span><br><span class="line"> throw new WindowManager.BadTokenException(  </span><br><span class="line"> &quot;Unable to add window &quot; + mWindow +  </span><br><span class="line"> &quot; -- permission denied for this window type&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_INVALID_DISPLAY:  </span><br><span class="line"> throw new WindowManager.InvalidDisplayException(  </span><br><span class="line"> &quot;Unable to add window &quot; + mWindow +  </span><br><span class="line"> &quot; -- the specified display can not be found&quot;);  </span><br><span class="line"> case WindowManagerGlobal.ADD_INVALID_TYPE:  </span><br><span class="line"> throw new WindowManager.InvalidDisplayException(  </span><br><span class="line"> &quot;Unable to add window &quot; + mWindow  </span><br><span class="line"> + &quot; -- the specified window type is not valid&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to add window -- unknown error code &quot; + res);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (view instanceof RootViewSurfaceTaker) &#123;  </span><br><span class="line"> mInputQueueCallback =  </span><br><span class="line"> ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (mInputChannel != null) &#123;  </span><br><span class="line"> if (mInputQueueCallback != null) &#123;  </span><br><span class="line"> mInputQueue = new InputQueue();  </span><br><span class="line"> mInputQueueCallback.onInputQueueCreated(mInputQueue);  </span><br><span class="line"> &#125;  </span><br><span class="line"> mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,  </span><br><span class="line"> Looper.myLooper());  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> view.assignParent(this);  </span><br><span class="line"> mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;  </span><br><span class="line"> mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;  </span><br><span class="line">  </span><br><span class="line"> if (mAccessibilityManager.isEnabled()) &#123;  </span><br><span class="line"> mAccessibilityInteractionConnectionManager.ensureConnection();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;  </span><br><span class="line"> view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> // Set up the input pipeline.  </span><br><span class="line"> CharSequence counterSuffix = attrs.getTitle();  </span><br><span class="line"> mSyntheticInputStage = new SyntheticInputStage();  </span><br><span class="line"> InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);  </span><br><span class="line"> InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,  </span><br><span class="line"> &quot;aq:native-post-ime:&quot; + counterSuffix);  </span><br><span class="line"> InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);  </span><br><span class="line"> InputStage imeStage = new ImeInputStage(earlyPostImeStage,  </span><br><span class="line"> &quot;aq:ime:&quot; + counterSuffix);  </span><br><span class="line"> InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);  </span><br><span class="line"> InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,  </span><br><span class="line"> &quot;aq:native-pre-ime:&quot; + counterSuffix);  </span><br><span class="line">  </span><br><span class="line"> mFirstInputStage = nativePreImeStage;  </span><br><span class="line"> mFirstPostImeInputStage = earlyPostImeStage;  </span><br><span class="line"> mPendingInputEventQueueLengthCounterName = &quot;aq:pending:&quot; + counterSuffix;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">      </span><br><span class="line">@Override  </span><br><span class="line"> public void requestLayout() &#123;  </span><br><span class="line"> if (!mHandlingLayoutInLayoutRequest) &#123;  </span><br><span class="line"> checkThread();  </span><br><span class="line"> mLayoutRequested = true;  </span><br><span class="line"> scheduleTraversals();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">void scheduleTraversals() &#123;  </span><br><span class="line"> if (!mTraversalScheduled) &#123;  </span><br><span class="line"> mTraversalScheduled = true;  </span><br><span class="line"> mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();  </span><br><span class="line"> mChoreographer.postCallback(  </span><br><span class="line"> Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);  </span><br><span class="line"> if (!mUnbufferedInputDispatch) &#123;  </span><br><span class="line"> scheduleConsumeBatchedInput();  </span><br><span class="line"> &#125;  </span><br><span class="line"> notifyRendererOfFramePending();  </span><br><span class="line"> pokeDrawLockIfNeeded();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在die方法内部只是简单做了判断，如果是异步删除，那个发送MSG_DIE的消息，ViewRootImpl中的Handle会处理并调用doDie，如果为同步直接调用doDie,doDie内部会调用dispatchDetachedFromWIndow，进行IPC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">* @param immediate True, do now if not in traversal. False, put on queue and do later. </span><br><span class="line">* @return True, request has been queued. False, request has been completed. </span><br><span class="line">*/  </span><br><span class="line">boolean die(boolean immediate) &#123;  </span><br><span class="line">// Make sure we do execute immediately if we are in the middle of a traversal or the damage  </span><br><span class="line">// done by dispatchDetachedFromWindow will cause havoc on return.  </span><br><span class="line">if (immediate &amp;&amp; !mIsInTraversal) &#123;  </span><br><span class="line">doDie();  </span><br><span class="line">return false;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (!mIsDrawing) &#123;  </span><br><span class="line">destroyHardwareRenderer();  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +  </span><br><span class="line">&quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle());  </span><br><span class="line">&#125;  </span><br><span class="line">mHandler.sendEmptyMessage(MSG_DIE);  </span><br><span class="line">return true;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void doDie() &#123;  </span><br><span class="line">checkThread();  </span><br><span class="line">if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);  </span><br><span class="line">synchronized (this) &#123;  </span><br><span class="line">if (mRemoved) &#123;  </span><br><span class="line">return;  </span><br><span class="line">&#125;  </span><br><span class="line">mRemoved = true;  </span><br><span class="line">if (mAdded) &#123;  </span><br><span class="line">dispatchDetachedFromWindow();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (mAdded &amp;&amp; !mFirst) &#123;  </span><br><span class="line">destroyHardwareRenderer();  </span><br><span class="line">  </span><br><span class="line">if (mView != null) &#123;  </span><br><span class="line">int viewVisibility = mView.getVisibility();  </span><br><span class="line">boolean viewVisibilityChanged = mViewVisibility != viewVisibility;  </span><br><span class="line">if (mWindowAttributesChanged || viewVisibilityChanged) &#123;  </span><br><span class="line">// If layout params have been changed, first give them  </span><br><span class="line">// to the window manager to make sure it has the correct  </span><br><span class="line">// animation info.  </span><br><span class="line">try &#123;  </span><br><span class="line">if ((relayoutWindow(mWindowAttributes, viewVisibility, false)  </span><br><span class="line">&amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;  </span><br><span class="line">mWindowSession.finishDrawing(mWindow);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; catch (RemoteException e) &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mSurface.release();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mAdded = false;  </span><br><span class="line">&#125;  </span><br><span class="line">WindowManagerGlobal.getInstance().doRemoveView(this);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void dispatchDetachedFromWindow() &#123;  </span><br><span class="line">if (mView != null &amp;&amp; mView.mAttachInfo != null) &#123;  </span><br><span class="line">mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);  </span><br><span class="line">mView.dispatchDetachedFromWindow();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mAccessibilityInteractionConnectionManager.ensureNoConnection();  </span><br><span class="line">mAccessibilityManager.removeAccessibilityStateChangeListener(  </span><br><span class="line">mAccessibilityInteractionConnectionManager);  </span><br><span class="line">mAccessibilityManager.removeHighTextContrastStateChangeListener(  </span><br><span class="line">mHighContrastTextManager);  </span><br><span class="line">removeSendWindowContentChangedCallback();  </span><br><span class="line">  </span><br><span class="line">destroyHardwareRenderer();  </span><br><span class="line">  </span><br><span class="line">setAccessibilityFocus(null, null);  </span><br><span class="line">  </span><br><span class="line">mView.assignParent(null);  </span><br><span class="line">mView = null;  </span><br><span class="line">mAttachInfo.mRootView = null;  </span><br><span class="line">  </span><br><span class="line">mSurface.release();  </span><br><span class="line">  </span><br><span class="line">if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) &#123;  </span><br><span class="line">mInputQueueCallback.onInputQueueDestroyed(mInputQueue);  </span><br><span class="line">mInputQueue.dispose();  </span><br><span class="line">mInputQueueCallback = null;  </span><br><span class="line">mInputQueue = null;  </span><br><span class="line">&#125;  </span><br><span class="line">if (mInputEventReceiver != null) &#123;  </span><br><span class="line">mInputEventReceiver.dispose();  </span><br><span class="line">mInputEventReceiver = null;  </span><br><span class="line">&#125;  </span><br><span class="line">try &#123;  </span><br><span class="line">mWindowSession.remove(mWindow);  </span><br><span class="line">&#125; catch (RemoteException e) &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Dispose the input channel after removing the window so the Window Manager  </span><br><span class="line">// doesn&apos;t interpret the input channel being closed as an abnormal termination.  </span><br><span class="line">if (mInputChannel != null) &#123;  </span><br><span class="line">mInputChannel.dispose();  </span><br><span class="line">mInputChannel = null;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">mDisplayManager.unregisterDisplayListener(mDisplayListener);  </span><br><span class="line">  </span><br><span class="line">unscheduleTraversals();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void unscheduleTraversals() &#123;  </span><br><span class="line">if (mTraversalScheduled) &#123;  </span><br><span class="line">mTraversalScheduled = false;  </span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);  </span><br><span class="line">mChoreographer.removeCallbacks(  </span><br><span class="line">Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>Session对象也是一个服务端的桩对象，用来为客户端提供交互接口（IWindowSession），包括窗口的创建、销毁、布局等接口。每个与窗口管理服务交互的进程通常都需要打开一个Session对象来实现交互，用来保证一个Session会话期间窗口状态的一致。Session对象在一个进程新建第一个视图时使用窗口管理服务的的openSession接口函数创建，第一个视图新建期间也创建一个SurfaceSession对象用来实现视图的绘制操作。SurfaceSession对象用来与SurfaceFliger服务建立连接，实现视图及包含的子视图在显示硬件上的实际输出工作。</li>
<li>WindowManagerService服务是一个系统服务类，是整个窗口管理机制实现的核心。<h1 id="3-Window的创建"><a href="#3-Window的创建" class="headerlink" title="3.Window的创建"></a>3.Window的创建</h1>View是Android中的视图的呈现方式，但是View不能单独存在，必须依赖于Window这个抽象的概念上，因此有视图的地方就有Window。<h2 id="3-1应用Window-Activity的创建"><a href="#3-1应用Window-Activity的创建" class="headerlink" title="3.1应用Window-Activity的创建"></a>3.1应用Window-Activity的创建</h2></li>
<li><p>ActivityThread的performLaunchActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;  </span><br><span class="line"> // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);  </span><br><span class="line">  </span><br><span class="line"> ActivityInfo aInfo = r.activityInfo;  </span><br><span class="line"> if (r.packageInfo == null) &#123;  </span><br><span class="line"> r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,  </span><br><span class="line"> Context.CONTEXT_INCLUDE_CODE);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> ComponentName component = r.intent.getComponent();  </span><br><span class="line"> if (component == null) &#123;  </span><br><span class="line"> component = r.intent.resolveActivity(  </span><br><span class="line"> mInitialApplication.getPackageManager());  </span><br><span class="line"> r.intent.setComponent(component);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (r.activityInfo.targetActivity != null) &#123;  </span><br><span class="line"> component = new ComponentName(r.activityInfo.packageName,  </span><br><span class="line"> r.activityInfo.targetActivity);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Activity activity = null;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> java.lang.ClassLoader cl = r.packageInfo.getClassLoader();  </span><br><span class="line"> activity = mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line"> StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line"> r.intent.setExtrasClassLoader(cl);  </span><br><span class="line"> r.intent.prepareToEnterProcess();  </span><br><span class="line"> if (r.state != null) &#123;  </span><br><span class="line"> r.state.setClassLoader(cl);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to instantiate activity &quot; + component  </span><br><span class="line"> + &quot;: &quot; + e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> try &#123;  </span><br><span class="line"> Application app = r.packageInfo.makeApplication(false, mInstrumentation);  </span><br><span class="line">  </span><br><span class="line"> if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);  </span><br><span class="line"> if (localLOGV) Slog.v(  </span><br><span class="line"> TAG, r + &quot;: app=&quot; + app  </span><br><span class="line"> + &quot;, appName=&quot; + app.getPackageName()  </span><br><span class="line"> + &quot;, pkg=&quot; + r.packageInfo.getPackageName()  </span><br><span class="line"> + &quot;, comp=&quot; + r.intent.getComponent().toShortString()  </span><br><span class="line"> + &quot;, dir=&quot; + r.packageInfo.getAppDir());  </span><br><span class="line">  </span><br><span class="line"> if (activity != null) &#123;  </span><br><span class="line"> Context appContext = createBaseContextForActivity(r, activity);  </span><br><span class="line"> CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());  </span><br><span class="line"> Configuration config = new Configuration(mCompatConfiguration);  </span><br><span class="line"> if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;  </span><br><span class="line"> + r.activityInfo.name + &quot; with config &quot; + config);  </span><br><span class="line"> activity.attach(appContext, this, getInstrumentation(), r.token,  </span><br><span class="line"> r.ident, app, r.intent, r.activityInfo, title, r.parent,  </span><br><span class="line"> r.embeddedID, r.lastNonConfigurationInstances, config,  </span><br><span class="line"> r.referrer, r.voiceInteractor);  </span><br><span class="line">  </span><br><span class="line"> if (customIntent != null) &#123;  </span><br><span class="line"> activity.mIntent = customIntent;  </span><br><span class="line"> &#125;  </span><br><span class="line"> r.lastNonConfigurationInstances = null;  </span><br><span class="line"> activity.mStartedActivity = false;  </span><br><span class="line"> int theme = r.activityInfo.getThemeResource();  </span><br><span class="line"> if (theme != 0) &#123;  </span><br><span class="line"> activity.setTheme(theme);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> activity.mCalled = false;  </span><br><span class="line"> if (r.isPersistable()) &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnCreate(activity, r.state);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (!activity.mCalled) &#123;  </span><br><span class="line"> throw new SuperNotCalledException(  </span><br><span class="line"> &quot;Activity &quot; + r.intent.getComponent().toShortString() +  </span><br><span class="line"> &quot; did not call through to super.onCreate()&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> r.activity = activity;  </span><br><span class="line"> r.stopped = true;  </span><br><span class="line"> if (!r.activity.mFinished) &#123;  </span><br><span class="line"> activity.performStart();  </span><br><span class="line"> r.stopped = false;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (!r.activity.mFinished) &#123;  </span><br><span class="line"> if (r.isPersistable()) &#123;  </span><br><span class="line"> if (r.state != null || r.persistentState != null) &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,  </span><br><span class="line"> r.persistentState);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125; else if (r.state != null) &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (!r.activity.mFinished) &#123;  </span><br><span class="line"> activity.mCalled = false;  </span><br><span class="line"> if (r.isPersistable()) &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnPostCreate(activity, r.state,  </span><br><span class="line"> r.persistentState);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mInstrumentation.callActivityOnPostCreate(activity, r.state);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (!activity.mCalled) &#123;  </span><br><span class="line"> throw new SuperNotCalledException(  </span><br><span class="line"> &quot;Activity &quot; + r.intent.getComponent().toShortString() +  </span><br><span class="line"> &quot; did not call through to super.onPostCreate()&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> r.paused = true;  </span><br><span class="line">  </span><br><span class="line"> mActivities.put(r.token, r);  </span><br><span class="line">  </span><br><span class="line"> &#125; catch (SuperNotCalledException e) &#123;  </span><br><span class="line"> throw e;  </span><br><span class="line">  </span><br><span class="line"> &#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to start activity &quot; + component  </span><br><span class="line"> + &quot;: &quot; + e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> return activity;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Activity的attach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,  </span><br><span class="line"> Instrumentation instr, IBinder token, int ident,  </span><br><span class="line"> Application application, Intent intent, ActivityInfo info,  </span><br><span class="line"> CharSequence title, Activity parent, String id,  </span><br><span class="line"> NonConfigurationInstances lastNonConfigurationInstances,  </span><br><span class="line"> Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;  </span><br><span class="line"> attachBaseContext(context);  </span><br><span class="line">  </span><br><span class="line"> mFragments.attachHost(null /*parent*/);  </span><br><span class="line">  </span><br><span class="line"> mWindow = new PhoneWindow(this);  </span><br><span class="line"> mWindow.setCallback(this);  </span><br><span class="line"> mWindow.setOnWindowDismissedCallback(this);  </span><br><span class="line"> mWindow.getLayoutInflater().setPrivateFactory(this);  </span><br><span class="line"> if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;  </span><br><span class="line"> mWindow.setSoftInputMode(info.softInputMode);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (info.uiOptions != 0) &#123;  </span><br><span class="line"> mWindow.setUiOptions(info.uiOptions);  </span><br><span class="line"> &#125;  </span><br><span class="line"> mUiThread = Thread.currentThread();  </span><br><span class="line">  </span><br><span class="line"> mMainThread = aThread;  </span><br><span class="line"> mInstrumentation = instr;  </span><br><span class="line"> mToken = token;  </span><br><span class="line"> mIdent = ident;  </span><br><span class="line"> mApplication = application;  </span><br><span class="line"> mIntent = intent;  </span><br><span class="line"> mReferrer = referrer;  </span><br><span class="line"> mComponent = intent.getComponent();  </span><br><span class="line"> mActivityInfo = info;  </span><br><span class="line"> mTitle = title;  </span><br><span class="line"> mParent = parent;  </span><br><span class="line"> mEmbeddedID = id;  </span><br><span class="line"> mLastNonConfigurationInstances = lastNonConfigurationInstances;  </span><br><span class="line"> if (voiceInteractor != null) &#123;  </span><br><span class="line"> if (lastNonConfigurationInstances != null) &#123;  </span><br><span class="line"> mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,  </span><br><span class="line"> Looper.myLooper());  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> mWindow.setWindowManager(  </span><br><span class="line"> (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),  </span><br><span class="line"> mToken, mComponent.flattenToString(),  </span><br><span class="line"> (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);  </span><br><span class="line"> if (mParent != null) &#123;  </span><br><span class="line"> mWindow.setContainer(mParent.getWindow());  </span><br><span class="line"> &#125;  </span><br><span class="line"> mWindowManager = mWindow.getWindowManager();  </span><br><span class="line"> mCurrentConfig = config;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Window创建完成后，通过setContentView将视图附加在Window上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;  </span><br><span class="line"> getWindow().setContentView(layoutResID);  </span><br><span class="line"> initWindowDecorActionBar();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然在attach方法中Window就已经被创建，但这个时候还未被Windowmanager识别。在ActivityThread的handleResumeActvity中，调用了Activity的performResume方法，接着调用Activity的makeVisible方法。此时，DecorView才真正的被添加和显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,  </span><br><span class="line"> boolean clearHide, boolean isForward, boolean reallyResume) &#123;  </span><br><span class="line"> // If we are getting ready to gc after going to the background, well  </span><br><span class="line"> // we are back active so skip it.  </span><br><span class="line"> unscheduleGcIdler();  </span><br><span class="line"> mSomeActivitiesChanged = true;  </span><br><span class="line">  </span><br><span class="line"> // TODO Push resumeArgs into the activity for consideration  </span><br><span class="line"> ActivityClientRecord r = performResumeActivity(token, clearHide);  </span><br><span class="line">  </span><br><span class="line"> if (r != null) &#123;  </span><br><span class="line"> final Activity a = r.activity;  </span><br><span class="line">  </span><br><span class="line"> if (localLOGV) Slog.v(  </span><br><span class="line"> TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +  </span><br><span class="line"> a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow  </span><br><span class="line"> + &quot;, finished: &quot; + a.mFinished);  </span><br><span class="line">  </span><br><span class="line"> final int forwardBit = isForward ?  </span><br><span class="line"> WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;  </span><br><span class="line">  </span><br><span class="line"> // If the window hasn&apos;t yet been added to the window manager,  </span><br><span class="line"> // and this guy didn&apos;t finish itself or start another activity,  </span><br><span class="line"> // then go ahead and add the window.  </span><br><span class="line"> boolean willBeVisible = !a.mStartedActivity;  </span><br><span class="line"> if (!willBeVisible) &#123;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(  </span><br><span class="line"> a.getActivityToken());  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;  </span><br><span class="line"> r.window = r.activity.getWindow();  </span><br><span class="line"> View decor = r.window.getDecorView();  </span><br><span class="line"> decor.setVisibility(View.INVISIBLE);  </span><br><span class="line"> ViewManager wm = a.getWindowManager();  </span><br><span class="line"> WindowManager.LayoutParams l = r.window.getAttributes();  </span><br><span class="line"> a.mDecor = decor;  </span><br><span class="line"> l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;  </span><br><span class="line"> l.softInputMode |= forwardBit;  </span><br><span class="line"> if (a.mVisibleFromClient) &#123;  </span><br><span class="line"> a.mWindowAdded = true;  </span><br><span class="line"> wm.addView(decor, l);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> // If the window has already been added, but during resume  </span><br><span class="line"> // we started another activity, then don&apos;t yet make the  </span><br><span class="line"> // window visible.  </span><br><span class="line"> &#125; else if (!willBeVisible) &#123;  </span><br><span class="line"> if (localLOGV) Slog.v(  </span><br><span class="line"> TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);  </span><br><span class="line"> r.hideForNow = true;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> // Get rid of anything left hanging around.  </span><br><span class="line"> cleanUpPendingRemoveWindows(r);  </span><br><span class="line">  </span><br><span class="line"> // The window is now visible if it has been added, we are not  </span><br><span class="line"> // simply finishing, and we are not starting another activity.  </span><br><span class="line"> if (!r.activity.mFinished &amp;&amp; willBeVisible  </span><br><span class="line"> &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;  </span><br><span class="line"> if (r.newConfig != null) &#123;  </span><br><span class="line"> r.tmpConfig.setTo(r.newConfig);  </span><br><span class="line"> if (r.overrideConfig != null) &#123;  </span><br><span class="line"> r.tmpConfig.updateFrom(r.overrideConfig);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;  </span><br><span class="line"> + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);  </span><br><span class="line"> performConfigurationChanged(r.activity, r.tmpConfig);  </span><br><span class="line"> freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));  </span><br><span class="line"> r.newConfig = null;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;  </span><br><span class="line"> + isForward);  </span><br><span class="line"> WindowManager.LayoutParams l = r.window.getAttributes();  </span><br><span class="line"> if ((l.softInputMode  </span><br><span class="line"> &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)  </span><br><span class="line"> != forwardBit) &#123;  </span><br><span class="line"> l.softInputMode = (l.softInputMode  </span><br><span class="line"> &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))  </span><br><span class="line"> | forwardBit;  </span><br><span class="line"> if (r.activity.mVisibleFromClient) &#123;  </span><br><span class="line"> ViewManager wm = a.getWindowManager();  </span><br><span class="line"> View decor = r.window.getDecorView();  </span><br><span class="line"> wm.updateViewLayout(decor, l);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> r.activity.mVisibleFromServer = true;  </span><br><span class="line"> mNumVisibleActivities++;  </span><br><span class="line"> if (r.activity.mVisibleFromClient) &#123;  </span><br><span class="line"> r.activity.makeVisible();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (!r.onlyLocalRequest) &#123;  </span><br><span class="line"> r.nextIdle = mNewActivities;  </span><br><span class="line"> mNewActivities = r;  </span><br><span class="line"> if (localLOGV) Slog.v(  </span><br><span class="line"> TAG, &quot;Scheduling idle handler for &quot; + r);  </span><br><span class="line"> Looper.myQueue().addIdleHandler(new Idler());  </span><br><span class="line"> &#125;  </span><br><span class="line"> r.onlyLocalRequest = false;  </span><br><span class="line">  </span><br><span class="line"> // Tell the activity manager we have resumed.  </span><br><span class="line"> if (reallyResume) &#123;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> ActivityManagerNative.getDefault().activityResumed(token);  </span><br><span class="line"> &#125; catch (RemoteException ex) &#123;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> // If an exception was thrown when trying to resume, then  </span><br><span class="line"> // just end this activity.  </span><br><span class="line"> try &#123;  </span><br><span class="line"> ActivityManagerNative.getDefault()  </span><br><span class="line"> .finishActivity(token, Activity.RESULT_CANCELED, null, false);  </span><br><span class="line"> &#125; catch (RemoteException ex) &#123;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> void makeVisible() &#123;  </span><br><span class="line"> if (!mWindowAdded) &#123;  </span><br><span class="line"> ViewManager wm = getWindowManager();  </span><br><span class="line"> wm.addView(mDecor, getWindow().getAttributes());  </span><br><span class="line"> mWindowAdded = true;  </span><br><span class="line"> &#125;  </span><br><span class="line"> mDecor.setVisibility(View.VISIBLE);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-2-子Window-Dialog的创建"><a href="#3-2-子Window-Dialog的创建" class="headerlink" title="3.2 子Window-Dialog的创建"></a>3.2 子Window-Dialog的创建</h2><ol>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;  </span><br><span class="line">  if (createContextThemeWrapper) &#123;  </span><br><span class="line">  if (themeResId == 0) &#123;  </span><br><span class="line">  final TypedValue outValue = new TypedValue();  </span><br><span class="line">  context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true);  </span><br><span class="line">  themeResId = outValue.resourceId;  </span><br><span class="line">  &#125;  </span><br><span class="line">  mContext = new ContextThemeWrapper(context, themeResId);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  mContext = context;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);  </span><br><span class="line">  </span><br><span class="line">  final Window w = new PhoneWindow(mContext);  </span><br><span class="line">  mWindow = w;  </span><br><span class="line">  w.setCallback(this);  </span><br><span class="line">  w.setOnWindowDismissedCallback(this);  </span><br><span class="line">  w.setWindowManager(mWindowManager, null, null);  </span><br><span class="line">  w.setGravity(Gravity.CENTER);  </span><br><span class="line">  </span><br><span class="line">  mListenersHandler = new ListenersHandler(this);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Set the screen content to an explicit view. This view is placed </span><br><span class="line"> * directly into the screen&apos;s view hierarchy. It can itself be a complex </span><br><span class="line"> * view hierarchy. </span><br><span class="line"> * </span><br><span class="line"> * @param view The desired content to display. </span><br><span class="line"> */  </span><br><span class="line"> public void setContentView(View view) &#123;  </span><br><span class="line"> mWindow.setContentView(view);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">  * Start the dialog and display it on screen. The window is placed in the </span><br><span class="line">  * application layer and opaque. Note that you should not override this </span><br><span class="line">  * method to do initialization when the dialog is shown, instead implement </span><br><span class="line">  * that in &#123;@link #onStart&#125;. </span><br><span class="line">  */  </span><br><span class="line">  public void show() &#123;  </span><br><span class="line">  if (mShowing) &#123;  </span><br><span class="line">  if (mDecor != null) &#123;  </span><br><span class="line">  if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;  </span><br><span class="line">  mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);  </span><br><span class="line">  &#125;  </span><br><span class="line">  mDecor.setVisibility(View.VISIBLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  mCanceled = false;  </span><br><span class="line">  </span><br><span class="line">  if (!mCreated) &#123;  </span><br><span class="line">  dispatchOnCreate(null);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  onStart();  </span><br><span class="line">  mDecor = mWindow.getDecorView();  </span><br><span class="line">  </span><br><span class="line">  if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;  </span><br><span class="line">  final ApplicationInfo info = mContext.getApplicationInfo();  </span><br><span class="line">  mWindow.setDefaultIcon(info.icon);  </span><br><span class="line">  mWindow.setDefaultLogo(info.logo);  </span><br><span class="line">  mActionBar = new WindowDecorActionBar(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  WindowManager.LayoutParams l = mWindow.getAttributes();  </span><br><span class="line">  if ((l.softInputMode  </span><br><span class="line">  &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) &#123;  </span><br><span class="line">  WindowManager.LayoutParams nl = new WindowManager.LayoutParams();  </span><br><span class="line">  nl.copyFrom(l);  </span><br><span class="line">  nl.softInputMode |=  </span><br><span class="line">  WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;  </span><br><span class="line">  l = nl;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  try &#123;  </span><br><span class="line">  mWindowManager.addView(mDecor, l);  </span><br><span class="line">  mShowing = true;  </span><br><span class="line">  </span><br><span class="line">  sendShowMessage();  </span><br><span class="line">  &#125; finally &#123;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void dismissDialog() &#123;  </span><br><span class="line">  if (mDecor == null || !mShowing) &#123;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  if (mWindow.isDestroyed()) &#123;  </span><br><span class="line">  Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog&apos;s window was already destroyed!&quot;);  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  try &#123;  </span><br><span class="line">  mWindowManager.removeViewImmediate(mDecor);  </span><br><span class="line">  &#125; finally &#123;  </span><br><span class="line">  if (mActionMode != null) &#123;  </span><br><span class="line">  mActionMode.finish();  </span><br><span class="line">  &#125;  </span><br><span class="line">  mDecor = null;  </span><br><span class="line">  mWindow.closeAllPanels();  </span><br><span class="line">  onStop();  </span><br><span class="line">  mShowing = false;  </span><br><span class="line">  </span><br><span class="line">  sendDismissMessage();  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-3-系统Window-Toast的创建"><a href="#3-3-系统Window-Toast的创建" class="headerlink" title="3.3 系统Window-Toast的创建"></a>3.3 系统Window-Toast的创建</h2><p>Toast属于系统Window，内部的视图有2种指定方式，一种是系统默认样式，另外一种是通过setView方法来指定一个自定义的View。由于Toast具有定时取消的功能，所以系统采用了Handler。Toast的显示及隐藏都是通过NotificationmanagerService进行控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Show the view for the specified duration. </span><br><span class="line"> */  </span><br><span class="line"> public void show() &#123;  </span><br><span class="line"> if (mNextView == null) &#123;  </span><br><span class="line"> throw new RuntimeException(&quot;setView must have been called&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> INotificationManager service = getService();  </span><br><span class="line"> String pkg = mContext.getOpPackageName();  </span><br><span class="line"> TN tn = mTN;  </span><br><span class="line"> tn.mNextView = mNextView;  </span><br><span class="line">  </span><br><span class="line"> try &#123;  </span><br><span class="line"> service.enqueueToast(pkg, tn, mDuration);  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> // Empty  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * Close the view if it&apos;s showing, or don&apos;t show it if it isn&apos;t showing yet. </span><br><span class="line"> * You do not normally have to call this. Normally view will disappear on its own </span><br><span class="line"> * after the appropriate duration. </span><br><span class="line"> */  </span><br><span class="line"> public void cancel() &#123;  </span><br><span class="line"> mTN.hide();  </span><br><span class="line">  </span><br><span class="line"> try &#123;  </span><br><span class="line"> getService().cancelToast(mContext.getPackageName(), mTN);  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> // Empty  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 主要在TN中进行Window操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">private static class TN extends ITransientNotification.Stub &#123;  </span><br><span class="line"> final Runnable mShow = new Runnable() &#123;  </span><br><span class="line"> @Override  </span><br><span class="line"> public void run() &#123;  </span><br><span class="line"> handleShow();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">  </span><br><span class="line"> final Runnable mHide = new Runnable() &#123;  </span><br><span class="line"> @Override  </span><br><span class="line"> public void run() &#123;  </span><br><span class="line"> handleHide();  </span><br><span class="line"> // Don&apos;t do this in handleHide() because it is also invoked by handleShow()  </span><br><span class="line"> mNextView = null;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">  </span><br><span class="line"> private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams();  </span><br><span class="line"> final Handler mHandler = new Handler();  </span><br><span class="line">  </span><br><span class="line"> int mGravity;  </span><br><span class="line"> int mX, mY;  </span><br><span class="line"> float mHorizontalMargin;  </span><br><span class="line"> float mVerticalMargin;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> View mView;  </span><br><span class="line"> View mNextView;  </span><br><span class="line">  </span><br><span class="line"> WindowManager mWM;  </span><br><span class="line">  </span><br><span class="line"> TN() &#123;  </span><br><span class="line"> // XXX This should be changed to use a Dialog, with a Theme.Toast  </span><br><span class="line"> // defined that sets up the layout params appropriately.  </span><br><span class="line"> final WindowManager.LayoutParams params = mParams;  </span><br><span class="line"> params.height = WindowManager.LayoutParams.WRAP_CONTENT;  </span><br><span class="line"> params.width = WindowManager.LayoutParams.WRAP_CONTENT;  </span><br><span class="line"> params.format = PixelFormat.TRANSLUCENT;  </span><br><span class="line"> params.windowAnimations = com.android.internal.R.style.Animation_Toast;  </span><br><span class="line"> params.type = WindowManager.LayoutParams.TYPE_TOAST;  </span><br><span class="line"> params.setTitle(&quot;Toast&quot;);  </span><br><span class="line"> params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON  </span><br><span class="line"> | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE  </span><br><span class="line"> | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * schedule handleShow into the right thread </span><br><span class="line"> */  </span><br><span class="line"> @Override  </span><br><span class="line"> public void show() &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);  </span><br><span class="line"> mHandler.post(mShow);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * schedule handleHide into the right thread </span><br><span class="line"> */  </span><br><span class="line"> @Override  </span><br><span class="line"> public void hide() &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);  </span><br><span class="line"> mHandler.post(mHide);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public void handleShow() &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView  </span><br><span class="line"> + &quot; mNextView=&quot; + mNextView);  </span><br><span class="line"> if (mView != mNextView) &#123;  </span><br><span class="line"> // remove the old view if necessary  </span><br><span class="line"> handleHide();  </span><br><span class="line"> mView = mNextView;  </span><br><span class="line"> Context context = mView.getContext().getApplicationContext();  </span><br><span class="line"> String packageName = mView.getContext().getOpPackageName();  </span><br><span class="line"> if (context == null) &#123;  </span><br><span class="line"> context = mView.getContext();  </span><br><span class="line"> &#125;  </span><br><span class="line"> mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);  </span><br><span class="line"> // We can resolve the Gravity here by using the Locale for getting  </span><br><span class="line"> // the layout direction  </span><br><span class="line"> final Configuration config = mView.getContext().getResources().getConfiguration();  </span><br><span class="line"> final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());  </span><br><span class="line"> mParams.gravity = gravity;  </span><br><span class="line"> if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;  </span><br><span class="line"> mParams.horizontalWeight = 1.0f;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;  </span><br><span class="line"> mParams.verticalWeight = 1.0f;  </span><br><span class="line"> &#125;  </span><br><span class="line"> mParams.x = mX;  </span><br><span class="line"> mParams.y = mY;  </span><br><span class="line"> mParams.verticalMargin = mVerticalMargin;  </span><br><span class="line"> mParams.horizontalMargin = mHorizontalMargin;  </span><br><span class="line"> mParams.packageName = packageName;  </span><br><span class="line"> if (mView.getParent() != null) &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);  </span><br><span class="line"> mWM.removeView(mView);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);  </span><br><span class="line"> mWM.addView(mView, mParams);  </span><br><span class="line"> trySendAccessibilityEvent();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> private void trySendAccessibilityEvent() &#123;  </span><br><span class="line"> AccessibilityManager accessibilityManager =  </span><br><span class="line"> AccessibilityManager.getInstance(mView.getContext());  </span><br><span class="line"> if (!accessibilityManager.isEnabled()) &#123;  </span><br><span class="line"> return;  </span><br><span class="line"> &#125;  </span><br><span class="line"> // treat toasts as notifications since they are used to  </span><br><span class="line"> // announce a transient piece of information to the user  </span><br><span class="line"> AccessibilityEvent event = AccessibilityEvent.obtain(  </span><br><span class="line"> AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);  </span><br><span class="line"> event.setClassName(getClass().getName());  </span><br><span class="line"> event.setPackageName(mView.getContext().getPackageName());  </span><br><span class="line"> mView.dispatchPopulateAccessibilityEvent(event);  </span><br><span class="line"> accessibilityManager.sendAccessibilityEvent(event);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public void handleHide() &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView);  </span><br><span class="line"> if (mView != null) &#123;  </span><br><span class="line"> // note: checking parent() just to make sure the view has  </span><br><span class="line"> // been added... i have seen cases where we get here when  </span><br><span class="line"> // the view isn&apos;t yet added, so let&apos;s try not to crash.  </span><br><span class="line"> if (mView.getParent() != null) &#123;  </span><br><span class="line"> if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);  </span><br><span class="line"> mWM.removeView(mView);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> mView = null;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/11/24/顺序存储与链式存储的集合-HashMap、HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/顺序存储与链式存储的集合-HashMap、HashTable/" itemprop="url">
                  顺序存储与链式存储的集合-HashMap、HashTable
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-24T18:27:50+08:00">
                2016-11-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/24/顺序存储与链式存储的集合-HashMap、HashTable/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/顺序存储与链式存储的集合-HashMap、HashTable/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HashMap，日常最常用的数据结构之一。它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面将通过源码分析存储结构、初始化、插入、查询、移除等来深入分析Hashmap的实现原理。</p>
<ul>
<li><p>equal hashcode ==的区别<br>为了分析HashMap，我们首先应该理解hashCode及equal的区别，如下：</p>
<p>== | 内存地址比较<br>—|—<br>equal |     Object默认内存地址比较，一般需要复写<br>hashcode | 主要用于集合的散列表，Object默认为内存地址，一般不用设置，除非作用于散列集合。</p>
</li>
</ul>
<ul>
<li>hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。当equals方法被重写时，通常有必要重写 hashCode 方法。</li>
</ul>
<ul>
<li>但hashCode相等，不一定equals（）</li>
</ul>
<h1 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h1><p>HashMapde的存储结构是采用顺序存储结构及链式存储结构。顺序存储结构存储着每个链表的头结点。每个Key根据计算bucketindex来确定数组下标。bucketindex=hash&amp;（length-1）。当bucketindex相同时，插入链表头部。</p>
<p><img src="http://img.blog.csdn.net/20161124182807137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// Entry是单向链表。  </span><br><span class="line">// 它是 “HashMap链式存储法”对应的链表。  </span><br><span class="line">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </span><br><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">final K key;  </span><br><span class="line">V value;  </span><br><span class="line">// 指向下一个节点  </span><br><span class="line">Entry&lt;K,V&gt; next;  </span><br><span class="line">final int hash;  </span><br><span class="line"></span><br><span class="line">// 构造函数。  </span><br><span class="line">// 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;  </span><br><span class="line">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </span><br><span class="line">value = v;  </span><br><span class="line">next = n;  </span><br><span class="line">key = k;  </span><br><span class="line">hash = h;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public final K getKey() &#123;  </span><br><span class="line">return key;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public final V getValue() &#123;  </span><br><span class="line">return value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public final V setValue(V newValue) &#123;  </span><br><span class="line">V oldValue = value;  </span><br><span class="line">value = newValue;  </span><br><span class="line">return oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 判断两个Entry是否相等  </span><br><span class="line">// 若两个Entry的“key”和“value”都相等，则返回true。  </span><br><span class="line">// 否则，返回false  </span><br><span class="line">public final boolean equals(Object o) &#123;  </span><br><span class="line">if (!(o instanceof Map.Entry))  </span><br><span class="line">return false;  </span><br><span class="line">Map.Entry e = (Map.Entry)o;  </span><br><span class="line">Object k1 = getKey();  </span><br><span class="line">Object k2 = e.getKey();  </span><br><span class="line">if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;  </span><br><span class="line">Object v1 = getValue();  </span><br><span class="line">Object v2 = e.getValue();  </span><br><span class="line">if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))  </span><br><span class="line">return true;  </span><br><span class="line">&#125;  </span><br><span class="line">return false;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 实现hashCode()  </span><br><span class="line">public final int hashCode() &#123;  </span><br><span class="line">return (key==null ? 0 : key.hashCode()) ^  </span><br><span class="line">(value==null ? 0 : value.hashCode());  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public final String toString() &#123;  </span><br><span class="line">return getKey() + &quot;=&quot; + getValue();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 当向HashMap中添加元素时，绘调用recordAccess()。  </span><br><span class="line">// 这里不做任何处理  </span><br><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 当从HashMap中删除元素时，绘调用recordRemoval()。  </span><br><span class="line">// 这里不做任何处理  </span><br><span class="line">void recordRemoval(HashMap&lt;K,V&gt; m) &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-初始化（加载因子）"><a href="#2-初始化（加载因子）" class="headerlink" title="2.初始化（加载因子）"></a>2.初始化（加载因子）</h1><p> HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，会调用方法将容量翻倍。所以这是时间和空间的矛盾，最后根据自己的业务来设定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。      </span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16;      </span><br><span class="line">     </span><br><span class="line">    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）      </span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;      </span><br><span class="line">     </span><br><span class="line">    // 默认加载因子为0.75     </span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;      </span><br><span class="line">   // 指定“容量大小”和“加载因子”的构造函数      </span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;      </span><br><span class="line">        if (initialCapacity &lt; 0)      </span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +      </span><br><span class="line">                                               initialCapacity);      </span><br><span class="line">        // HashMap的最大容量只能是MAXIMUM_CAPACITY      </span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)      </span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;      </span><br><span class="line">        //加载因此不能小于0    </span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))      </span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +      </span><br><span class="line">                                               loadFactor);      </span><br><span class="line">     </span><br><span class="line">        // 找出“大于initialCapacity”的最小的2的幂      </span><br><span class="line">        int capacity = 1;      </span><br><span class="line">        while (capacity &lt; initialCapacity)      </span><br><span class="line">            capacity &lt;&lt;= 1;      </span><br><span class="line">     </span><br><span class="line">        // 设置“加载因子”      </span><br><span class="line">        this.loadFactor = loadFactor;      </span><br><span class="line">        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。      </span><br><span class="line">        threshold = (int)(capacity * loadFactor);      </span><br><span class="line">        // 创建Entry数组，用来保存数据      </span><br><span class="line">        table = new Entry[capacity];      </span><br><span class="line">        init();      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-bucketindex"><a href="#3-bucketindex" class="headerlink" title="3.bucketindex"></a>3.bucketindex</h1><p>HashMap中的数据结构是数组+单链表的组合，我们希望的是元素存放的更均匀，最理想的效果是，Entry数组中每个位置都只有一个元素，这样，查询的时候效率最高，不需要遍历单链表，也不需要通过equals去比较K，而且空间利用率最大。所以可以采用%的方式，既哈希值%容量=bucketIndex。而源码的实现采用 h &amp; (length-1)，具有更高的效率。这里注意，为什么HashMap的默认容量要求2N次方。<br>当容量一定是2^n时，h &amp; (length - 1) == h % length</p>
<h1 id="4-put"><a href="#4-put" class="headerlink" title="4.put"></a>4.put</h1><p>HashMap添加元素主要先根据key的hash计算出bucketindex，如果该buckeindex下标的链表存在，则遍历进行替换，否则往数组添加新的链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 将“key-value”添加到HashMap中      </span><br><span class="line">   public V put(K key, V value) &#123;      </span><br><span class="line">       // 若“key为null”，则将该键值对添加到table[0]中。      </span><br><span class="line">       if (key == null)      </span><br><span class="line">           return putForNullKey(value);      </span><br><span class="line">       // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。      </span><br><span class="line">       int hash = hash(key.hashCode());      </span><br><span class="line">       int i = indexFor(hash, table.length);      </span><br><span class="line">       for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;      </span><br><span class="line">           Object k;      </span><br><span class="line">           // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！      </span><br><span class="line">           if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;      </span><br><span class="line">               V oldValue = e.value;      </span><br><span class="line">               e.value = value;      </span><br><span class="line">               e.recordAccess(this);      </span><br><span class="line">               return oldValue;      </span><br><span class="line">           &#125;      </span><br><span class="line">       &#125;      </span><br><span class="line">    </span><br><span class="line">       // 若“该key”对应的键值对不存在，则将“key-value”添加到table中      </span><br><span class="line">       modCount++;    </span><br><span class="line">       //将key-value添加到table[i]处    </span><br><span class="line">       addEntry(hash, key, value, i);      </span><br><span class="line">       return null;      </span><br><span class="line">   &#125;      </span><br><span class="line">  </span><br><span class="line">// 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率     </span><br><span class="line">   // h &amp; (length-1)保证返回值的小于length      </span><br><span class="line">   static int indexFor(int h, int length) &#123;      </span><br><span class="line">       return h &amp; (length-1);      </span><br><span class="line">   &#125;      </span><br><span class="line">  </span><br><span class="line"> // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。      </span><br><span class="line">   void addEntry(int hash, K key, V value, int bucketIndex) &#123;      </span><br><span class="line">       // 保存“bucketIndex”位置的值到“e”中      </span><br><span class="line">       Entry&lt;K,V&gt; e = table[bucketIndex];      </span><br><span class="line">       // 设置“bucketIndex”位置的元素为“新Entry”，      </span><br><span class="line">       // 设置“e”为“新Entry的下一个节点”      </span><br><span class="line">       table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);      </span><br><span class="line">       // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小      </span><br><span class="line">       if (size++ &gt;= threshold)      </span><br><span class="line">           resize(2 * table.length);      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-get"><a href="#5-get" class="headerlink" title="5.get"></a>5.get</h1><p>HashMap根据key获取元素主要就是通过bucketindex找到链表，进行查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 获取key对应的value      </span><br><span class="line">   public V get(Object key) &#123;      </span><br><span class="line">       if (key == null)      </span><br><span class="line">           return getForNullKey();      </span><br><span class="line">       // 获取key的hash值      </span><br><span class="line">       int hash = hash(key.hashCode());      </span><br><span class="line">       // 在“该hash值对应的链表”上查找“键值等于key”的元素      </span><br><span class="line">       for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];      </span><br><span class="line">            e != null;      </span><br><span class="line">            e = e.next) &#123;      </span><br><span class="line">           Object k;      </span><br><span class="line">           //判断key是否相同    </span><br><span class="line">           if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))      </span><br><span class="line">               return e.value;      </span><br><span class="line">       &#125;    </span><br><span class="line">       //没找到则返回null    </span><br><span class="line">       return null;      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-remove"><a href="#6-remove" class="headerlink" title="6.remove"></a>6.remove</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 删除“键为key”的元素      </span><br><span class="line">  final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;      </span><br><span class="line">      // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算      </span><br><span class="line">      int hash = (key == null) ? 0 : hash(key.hashCode());      </span><br><span class="line">      int i = indexFor(hash, table.length);      </span><br><span class="line">      Entry&lt;K,V&gt; prev = table[i];      </span><br><span class="line">      Entry&lt;K,V&gt; e = prev;      </span><br><span class="line">   </span><br><span class="line">      // 删除链表中“键为key”的元素      </span><br><span class="line">      // 本质是“删除单向链表中的节点”      </span><br><span class="line">      while (e != null) &#123;      </span><br><span class="line">          Entry&lt;K,V&gt; next = e.next;      </span><br><span class="line">          Object k;      </span><br><span class="line">          if (e.hash == hash &amp;&amp;      </span><br><span class="line">              ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;      </span><br><span class="line">              modCount++;      </span><br><span class="line">              size--;      </span><br><span class="line">              if (prev == e)      </span><br><span class="line">                  table[i] = next;      </span><br><span class="line">              else     </span><br><span class="line">                  prev.next = next;      </span><br><span class="line">              e.recordRemoval(this);      </span><br><span class="line">              return e;      </span><br><span class="line">          &#125;      </span><br><span class="line">          prev = e;      </span><br><span class="line">          e = next;      </span><br><span class="line">      &#125;      </span><br><span class="line">   </span><br><span class="line">      return e;      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-HashTable"><a href="#7-HashTable" class="headerlink" title="7.HashTable"></a>7.HashTable</h1><p>（1）HashTable的实现原理基本与HashMap一致，除了细微的方法实现不一致外，所以不进行原理分析。</p>
<p>（2）HashTable为线程安全，HashMap为非线程安全</p>
<p>（3）HashMap可以接受为null的key和value，而Hashtable则不行</p>
<p>（4）HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常</p>
<p>（5）Java 5提供了ConcurrentHashMap（局部锁机制），它是HashTable的替代，比HashTable的扩展性、性能更好</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h1><p>（1）HashMap是顺序结构及链表结构的组合</p>
<p>（2）最后根据业务设置容量及加载因子可以提高插入及查找效率，同时可以避免增容带来的效率问题</p>
<p>（3）HashMap为非线程安全</p>
<p>（4）HashMap的精髓为bucketindex（使元链表均匀分布在数组），可以提供空间的利用率及元素的插入及查找效率。</p>
<p>（5）由于hash相等，equal不一定相等。有可能导致撞库的问题，由于HashMap具有链表的功能。可以避免撞库问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/11/14/线性存储结构-LinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/线性存储结构-LinkedList/" itemprop="url">
                  线性存储结构-LinkedList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-14T16:46:47+08:00">
                2016-11-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/14/线性存储结构-LinkedList/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/线性存储结构-LinkedList/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LinkedList内部采用链表的形式构建，是一个双向链表。除了继承List外，还继承了Deque接口，可以当做堆栈结构使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static final class Link&lt;ET&gt; &#123;  </span><br><span class="line"> ET data; //数据  </span><br><span class="line"> </span><br><span class="line"> Link&lt;ET&gt; previous, next; //前节点、后节点  </span><br><span class="line"> </span><br><span class="line"> Link(ET o, Link&lt;ET&gt; p, Link&lt;ET&gt; n) &#123;  </span><br><span class="line"> data = o;  </span><br><span class="line"> previous = p;  </span><br><span class="line"> next = n;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>新增，这里由于是双向链表，根据位置判断是采用头遍历还是尾遍历开始。然后找出当前location节点的数据进行头尾节点的关系绑定。时间复杂度为o(n/2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line"> public void add(int location, E object) &#123;  </span><br><span class="line"> if (location &gt;= 0 &amp;&amp; location &lt;= size) &#123;  </span><br><span class="line"> Link&lt;E&gt; link = voidLink;  </span><br><span class="line"> if (location &lt; (size / 2)) &#123;  </span><br><span class="line"> for (int i = 0; i &lt;= location; i++) &#123;  </span><br><span class="line"> link = link.next;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> for (int i = size; i &gt; location; i--) &#123;  </span><br><span class="line"> link = link.previous;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> Link&lt;E&gt; previous = link.previous;  </span><br><span class="line"> Link&lt;E&gt; newLink = new Link&lt;E&gt;(object, previous, link);  </span><br><span class="line"> previous.next = newLink;  </span><br><span class="line"> link.previous = newLink;  </span><br><span class="line"> size++;  </span><br><span class="line"> modCount++;  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> throw new IndexOutOfBoundsException();  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>删除与新增一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public E remove(int location) &#123;  </span><br><span class="line">if (location &gt;= 0 &amp;&amp; location &lt; size) &#123;  </span><br><span class="line">Link&lt;E&gt; link = voidLink;  </span><br><span class="line">if (location &lt; (size / 2)) &#123;  </span><br><span class="line">for (int i = 0; i &lt;= location; i++) &#123;  </span><br><span class="line">link = link.next;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">for (int i = size; i &gt; location; i--) &#123;  </span><br><span class="line">link = link.previous;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">Link&lt;E&gt; previous = link.previous;  </span><br><span class="line">Link&lt;E&gt; next = link.next;  </span><br><span class="line">previous.next = next;  </span><br><span class="line">next.previous = previous;  </span><br><span class="line">size--;  </span><br><span class="line">modCount++;  </span><br><span class="line">return link.data;  </span><br><span class="line">&#125;  </span><br><span class="line">throw new IndexOutOfBoundsException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public E get(int location) &#123;  </span><br><span class="line">if (location &gt;= 0 &amp;&amp; location &lt; size) &#123;  </span><br><span class="line">Link&lt;E&gt; link = voidLink;  </span><br><span class="line">if (location &lt; (size / 2)) &#123;  </span><br><span class="line">for (int i = 0; i &lt;= location; i++) &#123;  </span><br><span class="line">link = link.next;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">for (int i = size; i &gt; location; i--) &#123;  </span><br><span class="line">link = link.previous;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">return link.data;  </span><br><span class="line">&#125;  </span><br><span class="line">throw new IndexOutOfBoundsException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下，LinkedList采用的是双向链表的存储结构，虽然对元素的操作需要多一个o（n/2）查询的过程，但是对于顺序存储结构，在删除插入的效率上还是有优势，但是在元素的获取上，则比顺序结构采用下标的形式效率低。同时除了List的实现，LinkedList还实现了堆栈的结构管理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/11/14/线性存储结构-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/线性存储结构-Stack/" itemprop="url">
                  线性存储结构-Stack
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-14T16:43:51+08:00">
                2016-11-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/14/线性存储结构-Stack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/线性存储结构-Stack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Stack继承于Vector，是一个模拟堆栈结构的集合类。当然也属于顺序存储结构。<br>构造方法 ： public Stack() 创建一个空 Stack。<br>方法：  </p>
<ol>
<li>public push  （item ）  把项 压入栈顶。其作用与 addElement (item ) 相同。<br>参数 item 压入栈顶的项 。 返回： item 参数 ；</li>
<li>public pop () 移除栈顶对象，并作为函数的值 返回该对象。<br>返回：栈顶对象（Vector 对象的中的最后一项）。<br>抛出异常 ： EmptyStackException 如果堆栈式空的 。。。</li>
<li>public peek() 查看栈顶对象而不移除它。。<br>返回：栈顶对象（Vector 对象的中的最后一项）。<br>抛出异常 ： EmptyStackException 如果堆栈式空的 。。。</li>
<li>public boolean empty （测试堆栈是否为空。）  当且仅当堆栈中不含任何项时 返回 true，否则 返回 false.</li>
<li>public int search  (object o)  返回对象在堆栈中位置， 以 1 为基数， 如果对象 ｏ是栈中的一项，该方法返回距离　栈顶最近的出现位置到栈顶的距离；　栈中最上端项的距离为　１　。　使用equals 方法比较 o 与 堆栈中的项。。。<br>参数： o 目标对象；</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">81</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
