<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="优秀是一种习惯，坚持是一种品质。">
<meta property="og:type" content="website">
<meta property="og:title" content="黄俊彬个人博客">
<meta property="og:url" content="https://junbin1011.github.io/page/7/index.html">
<meta property="og:site_name" content="黄俊彬个人博客">
<meta property="og:description" content="优秀是一种习惯，坚持是一种品质。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄俊彬个人博客">
<meta name="twitter:description" content="优秀是一种习惯，坚持是一种品质。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/7/"/>





  <title> 黄俊彬个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄俊彬个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">优秀是一种习惯，坚持是一种品质。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/24/排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/24/排序算法总结/" itemprop="url">
                  排序算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-24T15:19:06+08:00">
                2016-12-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/24/排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/24/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-排序算法分类"><a href="#1-排序算法分类" class="headerlink" title="1.排序算法分类"></a>1.排序算法分类</h1><p>基础的排序算法包含冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序及快速排序。<br>根据实现类型可分为插入排序类、选择排序类、交换排序类及归并排序类。</p>
<p><img src="http://img.blog.csdn.net/20161224151916566?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h1 id="2-排序算法的综合分析"><a href="#2-排序算法的综合分析" class="headerlink" title="2.排序算法的综合分析"></a>2.排序算法的综合分析</h1><p>各算法的排序方式、平均情况、最好最坏情况、所需的辅助空间及稳定性如下：<br><img src="http://img.blog.csdn.net/20161224151927488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>事实上，排序算法没有十全十美，本来想写一套模拟测试的数据来验证孰优孰略。但是突然发现可比性不高，需要根据排序源的情况，选择合适的排序算法。<br>从平均情况来看，显然最后3种改进的算法要优于希尔排序及其他3种简单的排序算法<br>从最坏情况来看，堆排序与归并排序又强过快速排序及其他简单排序<br>从辅助空间来看，简单排序算法及堆排序算法最优<br>从稳定性来看，改进的排序算法只有归并排序最稳定<br>选择怎样的排序算法需要根据各项指标来综合考虑，从待排序的个数上来说，待排序的个数n越小，采用简单排序的方法越合适，反之n越大，采用改进排序方法越合适，例如当关键字本身信息量很大，暂用存储空间大，移动比较花费时间，此时简单排序算法比较有优势。当然如果需要考虑算法的稳定性，显然改进的算法中只有归并排序合适。当然如果一定要说那个排序算法比较好，从综合的情况来说，改进的排序算法显然更优。</p>
<h1 id="3-JDK1-7中的排序算法"><a href="#3-JDK1-7中的排序算法" class="headerlink" title="3.JDK1.7中的排序算法"></a>3.JDK1.7中的排序算法</h1><p>java的程序员都知道我们对排序经常使用Collections.sort()或者Arrays.sort(),当然Collections.sort(）最后也是调用了Arrays.sort(),如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;  </div><div class="line"> Object[] a = list.toArray();  </div><div class="line"> Arrays.sort(a);  </div><div class="line"> ListIterator&lt;T&gt; i = list.listIterator();  </div><div class="line"> for (int j=0; j&lt;a.length; j++) &#123;  </div><div class="line"> i.next();  </div><div class="line"> i.set((T)a[j]);  </div><div class="line"> &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>那个Arrays.sort()，到底使用什么排序的算法呢？<br>分析源码得知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static void sort(int[] a) &#123;  </div><div class="line">  DualPivotQuicksort.sort(a);  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>DualPivotQuicksort是一种在快速排序（单轴）上优化的排序算法，是一种双轴快排。该算法的实现印证了第2点中的描述，算法的选择根据了数据源的情况进行实现。DualPivotQuicksort的实现包含组合了 TimSort（ 是一个归并排序做了大量优化的版本）、插入排序、单轴快速排序等。</p>
<p>有兴趣的深入了解DualPivotQuicksort的具体实现参考：<br><a href="http://www.tuicool.com/articles/BfY7Nz" target="_blank" rel="external">http://www.tuicool.com/articles/BfY7Nz</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/24/排序算法-快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/24/排序算法-快速排序/" itemprop="url">
                  排序算法-快速排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-24T11:26:51+08:00">
                2016-12-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/24/排序算法-快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/24/排序算法-快速排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>快速排序（Quick Sort）</strong><br>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小， 则可分别对这部分记录继续进行排序，以达到整个序列有序的目的</p>
<p>最好情况o(logn)</p>
<p>最坏情况o(n²)</p>
<p>排序稳定，但需要额外的辅助空间</p>
<p><img src="http://img.blog.csdn.net/20161224113321667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void quickSort(int[] array, int low, int high) &#123;  </div><div class="line">  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           if (low &gt;= high)  </div><div class="line">               return;  </div><div class="line">           // 找出中间索引  </div><div class="line">           int pivot = partition(array, low, high);  </div><div class="line">           System.out.println(&quot;low right:&quot; + low + &quot;  &quot; + high);  </div><div class="line">           System.out.println(pivot + &quot;array result:&quot; + Arrays.toString(array));  </div><div class="line">           // 对低子表递归排序  </div><div class="line">           quickSort(array, low, pivot - 1);  </div><div class="line">           // 对高子表递归排序  </div><div class="line">           quickSort(array, pivot + 1, high);  </div><div class="line">  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line">     * 交换顺序表中子表的记录，使枢轴记录到位，并返回其所在位置 </div><div class="line">     * 此时在他之前（后）的记录均不打（小）于它 </div><div class="line">     */  </div><div class="line">    static int partition(int[] array, int low, int height) &#123;  </div><div class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">            int pivotkey;  </div><div class="line">            pivotkey = array[low];  </div><div class="line">            while (low &lt; height) &#123;  </div><div class="line">                while (low &lt; height &amp;&amp; array[height] &gt;= pivotkey) &#123;  </div><div class="line">                    height--;  </div><div class="line">                &#125;  </div><div class="line">                swap(array, low, height);//将比根轴记录小的记录交换到低端  </div><div class="line">                while (low &lt; height &amp;&amp; array[low] &lt;= pivotkey) &#123;  </div><div class="line">                    low++;  </div><div class="line">                &#125;  </div><div class="line">                swap(array, low, height);//将比轴记录大的记录交换到高端  </div><div class="line">            &#125;  </div><div class="line">            return low;  </div><div class="line">        &#125;  </div><div class="line">        return 0;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line">    * 将数组的2个位置交换 </div><div class="line">    */  </div><div class="line">   static void swap(int[] array, int i, int j) &#123;  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">               int temp = array[i];  </div><div class="line">               array[i] = array[j];  </div><div class="line">               array[j] = temp;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>快速排序优化</p>
<p>递归对性能有一定的影响。栈的大小事很有限的，每次递归调用都会消耗一定的栈空间， 函数的参数越多，每次递归消耗的空间也越多。实现尾递归优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void quickSort2(int[] array, int low, int high) &#123;  </div><div class="line">  </div><div class="line">     if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">         int pivot;  </div><div class="line">         while (low &lt; high) &#123;  </div><div class="line">             // 找出中间索引  </div><div class="line">             pivot = partition2(array, low, high);  </div><div class="line">             System.out.println(&quot;low right:&quot; + low + &quot;  &quot; + high);  </div><div class="line">             System.out.println(pivot + &quot;array result:&quot; + Arrays.toString(array));  </div><div class="line">             // 对低子表递归排序  </div><div class="line">             quickSort2(array, low, pivot - 1);  </div><div class="line">             // 尾递归  </div><div class="line">             low = pivot + 1;  </div><div class="line">  </div><div class="line">         &#125;  </div><div class="line">  </div><div class="line">     &#125;  </div><div class="line">  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>优化选取枢轴（三数取中）<br>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static int partition2(int[] array, int low, int height) &#123;  </div><div class="line">      if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">          int pivotkey;  </div><div class="line">          int m=low+(height-low)/2;//计算数组中间的元素下标  </div><div class="line">          if(array[low]&gt;array[height])&#123;  </div><div class="line">              swap(array,low,height);//保证左端最小  </div><div class="line">          &#125;  </div><div class="line">          if(array[m]&gt;array[height])&#123;  </div><div class="line">              swap(array,m,height);//保证中间最小  </div><div class="line">          &#125;  </div><div class="line">          if(array[m]&gt;array[low])&#123;  </div><div class="line">              swap(array,m,low);//保证中间最小  </div><div class="line">          &#125;  </div><div class="line">          pivotkey = array[low];  </div><div class="line">          while (low &lt; height) &#123;  </div><div class="line">              while (low &lt; height &amp;&amp; array[height] &gt;= pivotkey) &#123;  </div><div class="line">                  height--;  </div><div class="line">              &#125;  </div><div class="line">              swap(array, low, height);//将比根轴记录小的记录交换到低端  </div><div class="line">              while (low &lt; height &amp;&amp; array[low] &lt;= pivotkey) &#123;  </div><div class="line">                  low++;  </div><div class="line">              &#125;  </div><div class="line">              swap(array, low, height);//将比轴记录大的记录交换到高端  </div><div class="line">          &#125;  </div><div class="line">          return low;  </div><div class="line">      &#125;  </div><div class="line">      return 0;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/16/排序算法-归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/16/排序算法-归并排序/" itemprop="url">
                  排序算法-归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-16T17:36:41+08:00">
                2016-12-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/16/排序算法-归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/16/排序算法-归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>归并排序（Merging Sort）</strong><br>利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列然后反复进行两两归并，直到得到一个长度为n的有序序列为止。</p>
<p>时间复杂度</p>
<p>最好情况o(nlogn)</p>
<p>最坏情况o(nlogn)</p>
<p>排序稳定，但需要额外的辅助空间</p>
<h2 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1.递归实现"></a>1.递归实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void partSort(int[] array, int left, int right) &#123;  </div><div class="line">  </div><div class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">            if (left &gt;= right)  </div><div class="line">                return;  </div><div class="line">            // 找出中间索引  </div><div class="line">            int center = (left + right) / 2;  </div><div class="line">            // 对左边数组进行递归  </div><div class="line">            partSort(array, left, center);  </div><div class="line">            // 对右边数组进行递归  </div><div class="line">            partSort(array, center + 1, right);  </div><div class="line">            //合并  </div><div class="line">            megre(array, left, center, right);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">/** </div><div class="line"> * 将左右两边有序的数据进行合并 </div><div class="line"> */  </div><div class="line">static void megre(int[] array, int left, int center, int right) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        // 临时数组  </div><div class="line">        int[] tmpArray = new int[array.length];  </div><div class="line">        // 右数组第一个元素索引  </div><div class="line">        int mid = center + 1;  </div><div class="line">        // tag 记录临时数组的索引  </div><div class="line">        int tag = left;  </div><div class="line">        // 缓存左数组第一个元素的索引  </div><div class="line">        int tmp = left;  </div><div class="line">        while (left &lt;= center &amp;&amp; mid &lt;= right) &#123;  </div><div class="line">            // 从两个数组中取出最小的放入临时数组  </div><div class="line">            if (array[left] &lt;= array[mid]) &#123;  </div><div class="line">                tmpArray[tag++] = array[left++];  </div><div class="line">            &#125; else &#123;  </div><div class="line">                tmpArray[tag++] = array[mid++];  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）  </div><div class="line">        while (mid &lt;= right) &#123;  </div><div class="line">            tmpArray[tag++] = array[mid++];  </div><div class="line">        &#125;  </div><div class="line">        while (left &lt;= center) &#123;  </div><div class="line">            tmpArray[tag++] = array[left++];  </div><div class="line">        &#125;  </div><div class="line">        // 将临时数组中的内容拷贝回原数组中  </div><div class="line">        // （原left-right范围的内容被复制回原数组）  </div><div class="line">        while (tmp &lt;= right) &#123;  </div><div class="line">            array[tmp] = tmpArray[tmp++];  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2.非递归实现"></a>2.非递归实现</h2><p>非递归思想: 将数组中的相邻元素两两配对。用merge函数将他们排序，构成n/2组长度为2的排序好的子数组段，然后再将他们排序成长度为4的子数组段，如此继续下去，直至整个数组排好序。性能由于递归实现</p>
<pre><code>static void megeringSort(int[] array) {  
     int len = 1;  
     //程序边界的处理非常重要  
     while (len &lt;= array.length) {  
         for (int i = 0; i + len &lt;= array.length - 1; i += len * 2) {//len 1 2 4 8... ...  
             int low = i, mid = i + len - 1, high = i + len * 2 - 1; //计算每次区间的左中右索引  
             if (high &gt; array.length - 1) high = array.length - 1;  
             megre(array, i, mid, high);//执行合并  
         }  
         len *= 2;  
     }  

 }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/14/排序算法-堆排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/排序算法-堆排序/" itemprop="url">
                  排序算法-堆排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-14T23:25:17+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/14/排序算法-堆排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/14/排序算法-堆排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>堆排序（Heap Sort）</strong><br>堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。<br>堆排序的基本思想是，将待排序的序列构成一个大顶堆。此时整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其余堆数组的末尾就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素的次小值，如此反复执行，便能得到一个有序序列了。</p>
<p>若array[0，…，n-1]表示一颗完全二叉树的顺序存储模式，则双亲节点指针和孩子结点指针之间的内在关系如下：</p>
<p>任意一节点指针 i：父节点：i==0 ? null : (i-1)/2</p>
<p> 左孩子：2*i + 1</p>
<p> 右孩子：2*i + 2</p>
<p>最好情况o(nlogn)</p>
<p>最坏情况o(nlogn)</p>
<p>性能高于希尔排序，并不稳定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void heapSort(int[] array) &#123;  </div><div class="line">        if (array == null || array.length &lt;= 1) &#123;  </div><div class="line">            return;  </div><div class="line">        &#125;  </div><div class="line">        headHeap(array);//先将原始数据构造成大顶堆  </div><div class="line">        for (int i = array.length - 1; i &gt;= 1; i--) &#123;  </div><div class="line">            swap(array, i, 0);//根节点和最后节点交换数据  </div><div class="line">            sortHeap(array, i, 0);//重新构造大顶堆  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//  </div><div class="line">  /** </div><div class="line">   * 构建最大堆 </div><div class="line">   * 在构建堆的过程中，我们是从最下层最右边的非终端节点开始构建，将它与 </div><div class="line">   * 其孩子进行比较和若有必要的交换 </div><div class="line">   */  </div><div class="line">  static void headHeap(int[] array) &#123;  </div><div class="line">  </div><div class="line">      if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">          for (int i = (array.length - 1) / 2; i &gt;= 0; i--) &#123;//找出存在孩子节点的节点  </div><div class="line">              sortHeap(array, array.length, i);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void sortHeap(int[] array, int n, int i) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        int child = 2 * i + 1;//找出子节点  </div><div class="line">        while (child &lt; n) &#123;//循环比较下一层节点  </div><div class="line">            if (child + 1 &lt; n &amp;&amp; array[child + 1] &gt; array[child]) &#123;//存在右节点 右节点比左节点大  </div><div class="line">                child = child + 1;  </div><div class="line">            &#125;  </div><div class="line">            if (array[child] &gt; array[i]) &#123;//最大子节点与根节点比较  </div><div class="line">                swap(array, child, i);  </div><div class="line">                i = child;//设置最大节点 进行下一次比较  </div><div class="line">                child = 2 * child + 1;//对比下一个节点  </div><div class="line">            &#125; else &#123;//比孩子节点都大 不用继续 因为堆是底部往上构建的 比孩子大 就不用往下继续比  </div><div class="line">                break;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/** </div><div class="line"> * 将数组的2个位置交换 </div><div class="line"> */  </div><div class="line">static void swap(int[] array, int i, int j) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">            int temp = array[i];  </div><div class="line">            array[i] = array[j];  </div><div class="line">            array[j] = temp;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-希尔排序/" itemprop="url">
                  排序算法-希尔排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:43:28+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-希尔排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-希尔排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>希尔排序（Shell Sort）</strong><br>升级版的插入排序，先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为dl的倍数的记录放在同一个组中。先在各组内进行直接插人排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)， 即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</p>
<p>   时间复杂度：</p>
<p>1）最好情况o(n)</p>
<p>  2）最坏情况o(n^3/2)</p>
<p>性能高于插入排序 但不稳定。<br>算法稳定性:通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。<br><img src="http://img.blog.csdn.net/20161212174842643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static void shellSort(int[] array) &#123;  </div><div class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">            int i, j, gap, key;  </div><div class="line">            int n = array.length;  </div><div class="line">            for (gap = n / 2; gap &gt; 0; gap /= 2) //步长  </div><div class="line">            &#123;  </div><div class="line">                for (i = 0; i &lt; gap; i++)        //直接插入排序  </div><div class="line">                &#123;  </div><div class="line">                    for (j = i + gap; j &lt; n; j += gap) &#123;  </div><div class="line">                        if (array[j] &lt; array[j - gap]) &#123;  </div><div class="line">                            key = array[j];  </div><div class="line">                            int k = j - gap;  </div><div class="line">                            while (k &gt;= 0 &amp;&amp; array[k] &gt; key) &#123;  </div><div class="line">                                array[k + gap] = array[k];  </div><div class="line">                                k -= gap;  </div><div class="line">                            &#125;  </div><div class="line">                            array[k + gap] = key;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 将数组的2个位置交换 </div><div class="line"> */  </div><div class="line">static void swap(int[] array, int i, int j) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">            int temp = array[i];  </div><div class="line">            array[i] = array[j];  </div><div class="line">            array[j] = temp;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-插入排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-插入排序/" itemprop="url">
                  排序算法-插入排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:42:40+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-插入排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-插入排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>插入排序（Insert Sort）</strong><br>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的、记录数增1的有序表，类似打扑克牌排列表。</p>
<p>时间复杂度：</p>
<p> 1）最好情况o(n)</p>
<p> 2）最坏情况o(n²/4)<br> 插入排序比选择排序及冒泡排序性能好些<br> <img src="http://img.blog.csdn.net/20161212174059326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static void insertSort(int[] array) &#123;  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           int i, j, key;  </div><div class="line">           for (i = 1; i &lt; array.length; i++) &#123;  </div><div class="line">               key = array[i];  </div><div class="line">               j = i - 1;  </div><div class="line">               while (j &gt;= 0 &amp;&amp; key &lt; array[j]) &#123;  </div><div class="line">                   array[j + 1] = array[j];//// 如果要插入的元素小于第j个元素,就将第j个元素向后移动  </div><div class="line">                   j--;  </div><div class="line">               &#125;  </div><div class="line">               array[j + 1] = key;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 将数组的2个位置交换 </div><div class="line"> */  </div><div class="line">static void swap(int[] array, int i, int j) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">            int temp = array[i];  </div><div class="line">            array[i] = array[j];  </div><div class="line">            array[j] = temp;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-选择排序/" itemprop="url">
                  排序算法-选择排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:36:50+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-选择排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-选择排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>简单选择排序（Simple Selection Sort）</strong><br>就是通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1&lt;=i&lt;=n）个记录交换之</p>
<p> 时间复杂度：</p>
<p> 1） 最好情况：本身有序，需要比较n-1次 时间复杂度为o(n)</p>
<p> 2）最坏情况：逆序情况，需要比较（n-1）+(n-2)+…+2+1=n(n-1)/2 时间复杂度为o（n²）<br>性能上略优于冒泡排序 减少了交换次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void selectionSort(int[] array) &#123;  </div><div class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">            int i, j,min;  </div><div class="line">            for (i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">                min=i;  </div><div class="line">                for (j = i + 1; j &lt; array.length; j++) &#123;  </div><div class="line">                    if (array[min] &gt; array[j]) &#123;  </div><div class="line">                        min=j;//找出最小记录  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                if(i!=min)&#123;//如果最小记录位置有变化，执行交换  </div><div class="line">                    swap(array, i, min);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 将数组的2个位置交换 </div><div class="line"> */  </div><div class="line">static void swap(int[] array, int i, int j) &#123;  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">            int temp = array[i];  </div><div class="line">            array[i] = array[j];  </div><div class="line">            array[j] = temp;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/12/排序算法-冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/排序算法-冒泡排序/" itemprop="url">
                  排序算法-冒泡排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T17:26:01+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/12/排序算法-冒泡排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/12/排序算法-冒泡排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>冒泡排序（Bubble BubbleSort）</strong><br>是一种交换排序，他的基本思路是： 两两比较相邻记录的关键字，如果反序则交换。<br>时间复杂度：<br>     1）最好情况：本身有序，需要比较n-1次 时间复杂度为o(n)<br>     2）最坏情况：逆序情况，需要比较（n-1）+(n-2)+…+2+1=n(n-1)/2 时间复杂度为o（n²）<br>每一轮的排序对下一轮的排序有帮助，数字如同气泡慢慢往上浮</p>
<p><img src="http://img.blog.csdn.net/20161212172353380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void bubbleSort(int[] array) &#123;  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           int i, j;  </div><div class="line">           for (i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">               for (j = array.length - 1; j &gt; i; j--) &#123;  </div><div class="line">                   if (array[j] &lt; array[j - 1]) &#123;  </div><div class="line">                       swap(array, j, j - 1);  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line">    * 将数组的2个位置交换 </div><div class="line">    */  </div><div class="line">   static void swap(int[] array, int i, int j) &#123;  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </div><div class="line">               int temp = array[i];  </div><div class="line">               array[i] = array[j];  </div><div class="line">               array[j] = temp;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 冒泡排序优化(增加tag)，极端情况{2,1,3,4,5,6,7,8,9}后续不用交换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void bubbleSortTag(int[] array) &#123;  </div><div class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">           int i, j;  </div><div class="line">           boolean tag = true;//每一轮有木有交换数据  </div><div class="line">           for (i = 0; i &lt; array.length &amp;&amp; tag; i++) &#123;  </div><div class="line">               tag = false;  </div><div class="line">               for (j = array.length - 1; j &gt; i; j--) &#123;  </div><div class="line">                   if (array[j] &lt; array[j - 1]) &#123;  </div><div class="line">                       swap(array, j, j - 1);  </div><div class="line">                       tag = true;  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/" itemprop="url">
                  查找算法-稠密索引、分块索引、倒排索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T10:28:16+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/10/查找算法-稠密索引、分块索引、倒排索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/10/查找算法-稠密索引、分块索引、倒排索引/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h1><p>稠密索引时指在线性索引中，将数据集中的每个记录都对应一个索引项 。对于索引项一定是按照关键码有序的排列 索引项有序意味着可以使用顺序查找算法，这是稠密索引的有点， 但是如果数据集非常大，意味着索引也得有同样的数据集长度规模。</p>
<p><img src="http://img.blog.csdn.net/20161210103900031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight plain"><figcaption><span>&#123;  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    public int key;  </div><div class="line">    public Object value;  </div><div class="line">    public int size;//分块存储数量  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public String toString() &#123;  </div><div class="line">        return &quot;Index&#123;&quot; +  </div><div class="line">                &quot;key=&quot; + key +  </div><div class="line">                &quot;, value=&quot; + value +  </div><div class="line">                &quot;, size=&quot; + size +  </div><div class="line">                &apos;&#125;&apos;;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Student implements Comparable &#123;  </div><div class="line">  </div><div class="line">    public Student(int no, String name) &#123;  </div><div class="line">        this.no = no;  </div><div class="line">        this.name = name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public int no;  </div><div class="line">    public String name;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public String toString() &#123;  </div><div class="line">        return &quot;Student&#123;&quot; +  </div><div class="line">                &quot;no=&quot; + no +  </div><div class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +  </div><div class="line">                &apos;&#125;&apos;;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public int compareTo(Object o) &#123;  </div><div class="line">        Student other = (Student) o;  </div><div class="line">        if (no &lt; other.no) //这里比较的是什么 sort方法实现的就是按照此比较的东西从小到大排列  </div><div class="line">            return -1;  </div><div class="line">        if (no &gt; other.no)  </div><div class="line">            return 1;  </div><div class="line">        return 0;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static int binarySearch(Index[] array, int key) &#123;  </div><div class="line">        if (array.length &gt; 0) &#123;  </div><div class="line">            int low, high, mid;  </div><div class="line">            low = 0;  </div><div class="line">            high = array.length - 1;  </div><div class="line">            while (low &lt;= high) &#123;  </div><div class="line">                mid = (low + high) / 2;//折半  </div><div class="line">                if (key &lt; array[mid].key)  </div><div class="line">                    high = mid - 1;  </div><div class="line">                else if (key &gt; array[mid].key)  </div><div class="line">                    low = mid + 1;  </div><div class="line">                else  </div><div class="line">                    return mid;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        return -1;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static Student denseIndex(Student[] array, int key) &#123;  </div><div class="line">  </div><div class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">        Arrays.sort(array);  </div><div class="line">  </div><div class="line">        Index[] list = new Index[array.length];  </div><div class="line">        //建立索引  </div><div class="line">        for (int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">            Index index = new Index();  </div><div class="line">            index.key = array[i].no;  </div><div class="line">            index.value = array[i];  </div><div class="line">            list[i] = index;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        //根据索引关键码搜索  </div><div class="line">        int code = binarySearch(list, key);  </div><div class="line">        if (code != -1) &#123;  </div><div class="line">            return (Student) list[code].value;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h1><p>分块有序-是吧数据集合的记录分成了若干份，并且这些块需要满足2个条件</p>
<p> 1）块内无序，即每一块内的记录不要求有序。（有序更好，但需要付出大量时间和空间代价）</p>
<p>2）块间有序-例如要求第二块所有记录的关键字均要大于第一块所有记录的关键字，第三块的所有记录要大于第二块的所有记录关键字，因为只有块间有序，才能提高查找效率<br> 分块索引的平均查找长度ASL=根号n+1  高于o(n)小于折半查找o(logn)</p>
<p><img src="http://img.blog.csdn.net/20161210103917531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static int blockSearch(Index[] array, int key) &#123;  </div><div class="line">       if (array.length &gt; 0) &#123;  </div><div class="line">           int result, low, high, mid;  </div><div class="line">           result = 0;  </div><div class="line">           low = 0;  </div><div class="line">           high = array.length - 1;  </div><div class="line">           while (low &lt;= high) &#123;  </div><div class="line">               mid = (low + high) / 2;//折半  </div><div class="line">               if (key &lt; array[mid].key) &#123;  </div><div class="line">                   high = mid - 1;  </div><div class="line">                   result = high;  </div><div class="line">               &#125; else if (key &gt; array[mid].key) &#123;  </div><div class="line">                   low = mid + 1;  </div><div class="line">                   result = mid;  </div><div class="line">               &#125; else  </div><div class="line">                   return mid;  </div><div class="line"> </div><div class="line">           &#125;  </div><div class="line">           return result;  </div><div class="line">       &#125;  </div><div class="line"> </div><div class="line">       return -1;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">public static Student blockIndex(Student[] array, int block, int key) &#123;  </div><div class="line">  </div><div class="line">  </div><div class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">            if (block &lt; 1 || block &gt; array.length) &#123;  </div><div class="line">                return null;  </div><div class="line">            &#125;  </div><div class="line">            Arrays.sort(array);//为了方便构造 块内有序 其实可以无序  </div><div class="line">            Index[] list = new Index[block];  </div><div class="line">            int blocksize = array.length / block;  </div><div class="line">            //建立索引及数据分块  </div><div class="line">            for (int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">  </div><div class="line">                if (i % blocksize == 0 || block == 1) &#123;//分块建立索引  </div><div class="line">                    Index index = new Index();  </div><div class="line">                    index.key = array[i].no;  </div><div class="line">                    index.value = array[i];  </div><div class="line">                    if (block == 1) &#123;//只分一块 首个是索引  </div><div class="line">                        index.size = array.length;  </div><div class="line">                        list[0] = index;  </div><div class="line">                        break;  </div><div class="line">                    &#125; else if (i / blocksize == block - 1) &#123;//长度和分块个数不均匀，剩下最后的数据放在最后一块  </div><div class="line">                        index.size = array.length - i;  </div><div class="line">                        list[block - 1] = index;  </div><div class="line">                        break;  </div><div class="line">                    &#125; else if (i / blocksize &lt; block - 1) &#123;  </div><div class="line">                        index.size = blocksize;  </div><div class="line">                        list[i / blocksize] = index;  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                &#125;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            //根据索引关键码搜索对应的块  </div><div class="line">            int mid = blockSearch(list, key);  </div><div class="line">            System.out.println(&quot;mid:&quot; + mid);  </div><div class="line">            if (mid != -1) &#123;  </div><div class="line">                Index index = list[mid];//找出索引  </div><div class="line">                System.out.println(&quot;index:&quot; + index);  </div><div class="line">                for (int i = 0; i &lt; index.size; i++) &#123;//块内无序 顺序查找  </div><div class="line">                    System.out.println(&quot;array[i]:&quot; + array[(mid * blocksize) + i]);  </div><div class="line">                    if (key == array[(mid * blocksize) + i].no) &#123;  </div><div class="line">                        return array[(mid * blocksize) + i];  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h1><p>倒排索引的概念很简单：就是将文件中的单词作为关键字，然后建立单词与文件的映射关系。 当然，你还可以添加文件中单词出现的频数等信息。 倒排索引是搜索引擎中一个很基本的概念，几乎所有的搜索引擎都会使用到倒排索引。<br>索引项的通用结构是：</p>
<p>1）次关键码，例如上面的英文单词</p>
<p>2） 记录号表，例如上面的文章编号<br> 其中记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字)</p>
<p><img src="http://img.blog.csdn.net/20161210103931110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static List&lt;String&gt; invertedIndex(String[] array, String word) &#123;  </div><div class="line">    HashMap&lt;String, List&lt;String&gt;&gt; lists = new HashMap&lt;&gt;();  </div><div class="line"> if (array != null &amp;&amp; array.length &gt; 0) &#123;  </div><div class="line">  //建立索引  </div><div class="line">         for (int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">String page = array[i];  </div><div class="line">              String[] words = page.split(&quot; &quot;);  </div><div class="line">              for (String str : words) &#123;  </div><div class="line">                  if (lists.containsKey(str)) &#123;  </div><div class="line">                      List&lt;String&gt; pages = lists.get(str);  </div><div class="line">                      pages.add(array[i]);  </div><div class="line">                  &#125; else &#123;  </div><div class="line">                      List&lt;String&gt; pages = new ArrayList&lt;&gt;();  </div><div class="line">                      pages.add(array[i]);  </div><div class="line">                      lists.put(str, pages);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          return lists.get(word);  </div><div class="line"></div><div class="line">      &#125;  </div><div class="line">      return null;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/06/查找算法-顺序查找、有序查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/06/查找算法-顺序查找、有序查找/" itemprop="url">
                  查找算法-顺序查找、有序查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-06T16:15:51+08:00">
                2016-12-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/06/查找算法-顺序查找、有序查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/06/查找算法-顺序查找、有序查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-顺序表的查找"><a href="#1-顺序表的查找" class="headerlink" title="1.顺序表的查找"></a>1.顺序表的查找</h1><h2 id="1）顺序查找"><a href="#1）顺序查找" class="headerlink" title="1）顺序查找"></a>1）顺序查找</h2><p>顺序查找又称为线性查找，是一种最简单的查找方法。<br>        从表的一端开始，向另一端逐个按要查找的值key 与关键码key进行比较，若找到，查找成功，并给出数据元素在表中的位置；若整个表检测完，仍未找到与关键码相同的key值，则查找失败，给出失败信息。<br>说白了就是，从头到尾，一个一个地比，找着相同的就成功，找不到就失败。很明显的缺点就是查找效率低。</p>
<p>【适用性】：适用于线性表的顺序存储结构和链式存储结构。<br> 平均查找长度=（n+1）/2.</p>
<p>【顺序查找优缺点】：<br>缺点:是当n 很大时，平均查找长度较大，效率低；</p>
<p>优点:是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static int orederSearch(int[] array, int key) &#123;  </div><div class="line">       if (array.length &gt; 0) &#123;  </div><div class="line">           for (int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">               if (array[i] == key) &#123;  </div><div class="line">                   return i;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       return -1;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="2-有序表的查找"><a href="#2-有序表的查找" class="headerlink" title="2.有序表的查找"></a>2.有序表的查找</h1><h2 id="1）折半查找"><a href="#1）折半查找" class="headerlink" title="1）折半查找"></a>1）折半查找</h2><p> 在有序表中，取中间元素作为比较对象，若给定值与中间元素的关键码key相等，则查找成功；若给定值小于中间元素的关键码，则在中间元素的左半区继续查找；若给定值大于中间元素的关键码，则在中间元素的右半区继续查找。不断重复上述查找过程，直到查找成功，或所查找的区域无数据元素，查找失败。时间复杂度为o(logn)</p>
<p>折半查找的前提条件是需要有序的顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好。但是对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，不建议使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static int binarySearch(int[] array, int key) &#123;  </div><div class="line">    if (array.length &gt; 0) &#123;  </div><div class="line">        int low, high, mid;  </div><div class="line">        low = 0;  </div><div class="line">        high = array.length - 1;  </div><div class="line">        while (low &lt;= high) &#123;  </div><div class="line">            mid = (low + high) / 2;//折半  </div><div class="line">            if (key &lt; array[mid])  </div><div class="line">                high = mid - 1;  </div><div class="line">            else if (key &gt; array[mid])  </div><div class="line">                low = mid + 1;  </div><div class="line">            else  </div><div class="line">                return mid;  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return -1;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2）插值查找"><a href="#2）插值查找" class="headerlink" title="2）插值查找"></a>2）插值查找</h2><p> 插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static int interpolationSearch(int[] array, int key) &#123;  </div><div class="line">       if (array.length &gt; 0) &#123;  </div><div class="line">           int low, high, mid;  </div><div class="line">           low = 0;  </div><div class="line">           high = array.length - 1;  </div><div class="line">           while (low &lt;= high) &#123;  </div><div class="line">               mid = low + (high - low) * (key - array[low]) / (array[high] - array[low]);//插值  </div><div class="line">               if (key &lt; array[mid])  </div><div class="line">                   high = mid - 1;  </div><div class="line">               else if (key &gt; array[mid])  </div><div class="line">                   low = mid + 1;  </div><div class="line">               else  </div><div class="line">                   return mid;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">  </div><div class="line">       return -1;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="3）斐波那契查找"><a href="#3）斐波那契查找" class="headerlink" title="3）斐波那契查找"></a>3）斐波那契查找</h1><p>斐波那契查找的前提是待查找的查找表必须顺序存储并且有序。时间复杂度o(logn)<br>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。</p>
<p>他要求开始表中记录的个数为某个斐波那契数小1，及n=Fk-1;</p>
<p>开始将k值与第F(k-1）位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<p>1）相等，mid位置的元素即为所求</p>
<p>2）&gt; ,low=mid+1,k-=2;<br>    说明:low=mid+1说明待查找的元素在[mid+1,hign]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-（F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找</p>
<p>3)&lt; ,high=mid-1,k-=1;<br>    说明:low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1 个，所以可以递归 的应用斐波那契查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public static int fbnacciSearch(int[] array, int key) &#123;  </div><div class="line">       if (array == null || array.length == 0) &#123;  </div><div class="line">           return -1;  </div><div class="line">       &#125; else &#123;  </div><div class="line">           int length=array.length;  </div><div class="line">           int[] fb=makeFbnacciArray(20);  </div><div class="line">           int k=0;  </div><div class="line">           while (length&gt;fb[k]-1)&#123;//找出数组的长度在斐波那契数列中的位置 n&lt;=F[k]-1  </div><div class="line">               k++;  </div><div class="line">           &#125;  </div><div class="line">           //n不一定刚刚好等于F[k]-1 此时扩容原数组 新增的位置的值为原数组的最大值  </div><div class="line">           int[] temp= Arrays.copyOf(array,fb[k]-1);  </div><div class="line">           for (int i=length;i&lt;temp.length;i++)&#123;  </div><div class="line">               if(i&gt;=length)&#123;  </div><div class="line">                   temp[i]=array[length-1];  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">           int low=0;  </div><div class="line">           int high=array.length-1;  </div><div class="line">           while (low&lt;=high)&#123;  </div><div class="line">               int middle=low+fb[k-1]-1;  </div><div class="line">               if(temp[middle]&gt;key)&#123;  </div><div class="line">                   high=middle-1;  </div><div class="line">                   k=k-1;  </div><div class="line">               &#125;else if(temp[middle]&lt;key)&#123;  </div><div class="line">                   low=middle+1;  </div><div class="line">                   k=k-2;  </div><div class="line">               &#125;else&#123;  </div><div class="line">                   if(middle&lt;=high)&#123;  </div><div class="line">                       return  middle;//若相等则说明middle为查找的位置  </div><div class="line">                   &#125;else&#123;  </div><div class="line">                       return high;//middle的值已经大于high，进入扩展数组的填充部分，既最后一个数就是要查找的数  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">  </div><div class="line">       return -1;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">   private static int[] makeFbnacciArray(int length) &#123;  </div><div class="line">       int array[] = null;  </div><div class="line">       if (length &gt; 2) &#123;  </div><div class="line">           array = new int[length];  </div><div class="line">           array[0] = 1;  </div><div class="line">           array[1] = 1;  </div><div class="line">           for (int i = 2; i &lt; length; i++) &#123;  </div><div class="line">               array[i] = array[i - 1] + array[i - 2];  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       if (length == 2) &#123;  </div><div class="line">           array = new int[length];  </div><div class="line">           array[0] = 1;  </div><div class="line">       &#125;  </div><div class="line">       if (length == 1) &#123;  </div><div class="line">           array = new int[length];  </div><div class="line">           array[0] = 1;  </div><div class="line">           array[1] = 1;  </div><div class="line">       &#125;  </div><div class="line">       return array;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>三种有序表的查找本质是分割点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做选择。这里注意主要的运算，折半查找采用乘除（mid = (low + high) / 2）、插值采用的是四则运算（  mid = low + (high - low) * (key - array[low]) / (array[high] - array[low])），斐波那契采用的是加减（middle=low+fb[k-1]-1）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">优秀是一种习惯，坚持是一种品质。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-jun-bin-48/" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
