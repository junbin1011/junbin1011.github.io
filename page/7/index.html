<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/7/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/7/">





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/18/设计模式-建造者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/18/设计模式-建造者模式/" itemprop="url">
                  设计模式-建造者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-18T10:14:54+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/18/设计模式-建造者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/18/设计模式-建造者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-建造者模式的定义及使用场景"><a href="#1-建造者模式的定义及使用场景" class="headerlink" title="1.建造者模式的定义及使用场景"></a>1.建造者模式的定义及使用场景</h1><p>Builder模式是一步一步创建一个复制对象的创建型模式，他允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。改模式是为了将构造复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p>
<h2 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建同步的表示</p>
<h2 id="1-2使用场景"><a href="#1-2使用场景" class="headerlink" title="1.2使用场景"></a>1.2使用场景</h2><p>相同的方法，不同的执行顺序，产生不同的事件结果时<br>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适<br>当初始化一个对象特别复杂，如参数多，而且很多参数都具有默认值时</p>
<p><img src="http://img.blog.csdn.net/20170118100751791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-建造者模式的优缺点"><a href="#2-建造者模式的优缺点" class="headerlink" title="2.建造者模式的优缺点"></a>2.建造者模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>封装性</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节风险<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>会产生多余的Builder对象以及Director对象<h1 id="3-建造者模式的实现方式"><a href="#3-建造者模式的实现方式" class="headerlink" title="3.建造者模式的实现方式"></a>3.建造者模式的实现方式</h1>Product：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;  </span><br><span class="line">    private  int id;  </span><br><span class="line">    private  String  name;  </span><br><span class="line">    public void doSomeThing()&#123;  </span><br><span class="line">        System.out.println(&quot;Product doSomeThing id:&quot;+id+&quot; name:&quot;+name);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public void setId(int id) &#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;Product&#123;&quot; +  </span><br><span class="line">                &quot;id=&quot; + id +  </span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +  </span><br><span class="line">                &apos;&#125;&apos;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>AbstactBuilder:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstactBulider &#123;  </span><br><span class="line">    abstract void setId(int id);  </span><br><span class="line">    abstract void setName(String name);  </span><br><span class="line">    abstract Product build();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Builder:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Builder extends AbstactBulider &#123;  </span><br><span class="line">    Product product = new Product();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    void setId(int id) &#123;  </span><br><span class="line">        product.setId(id);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    void setName(String name) &#123;  </span><br><span class="line">        product.setName(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    Product build() &#123;  </span><br><span class="line">        return product;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Director:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;  </span><br><span class="line">    private AbstactBulider aBuilder, bBuilder;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public Product getAProduct() &#123;  </span><br><span class="line">        aBuilder = new Builder();  </span><br><span class="line">        aBuilder.setId(1);  </span><br><span class="line">        aBuilder.setName(&quot;allen&quot;);  </span><br><span class="line">        return aBuilder.build();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public Product getBProduct() &#123;  </span><br><span class="line">        bBuilder = new Builder();  </span><br><span class="line">        bBuilder.setId(2);  </span><br><span class="line">        bBuilder.setName(&quot;joy&quot;);  </span><br><span class="line">        return bBuilder.build();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-建造者模式在Android中的实际应用"><a href="#4-建造者模式在Android中的实际应用" class="headerlink" title="4.建造者模式在Android中的实际应用"></a>4.建造者模式在Android中的实际应用</h1><p>在Android源码中，最常用到的Builder模式就是AlertDialog.Builder，使用该Builder来构建复杂的AlertDialog对象。在开发过程中，我们经常用到AlertDialog，具体示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new AlertDialog.Builder(self)</span><br><span class="line">  .setTitle(&quot;列表框&quot;)</span><br><span class="line">  .setItems(new String[] &#123;&quot;列表项1&quot;,&quot;列表项2&quot;,&quot;列表项3&quot;&#125;, null)</span><br><span class="line">  .setNegativeButton(&quot;确定&quot;, null)</span><br><span class="line">  .show();</span><br></pre></td></tr></table></figure></p>
<p>从类名就可以看出这是一个Builder模式，通过Builder对象来组装Dialog的各个部分，如title、buttons、items等。分析AlertDialog源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;  </span><br><span class="line"> private final AlertController.AlertParams P;  </span><br><span class="line"> public Builder(Context context) &#123;  </span><br><span class="line"> this(context, resolveDialogTheme(context, 0));  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder(Context context, int themeResId) &#123;  </span><br><span class="line"> P = new AlertController.AlertParams(new ContextThemeWrapper(  </span><br><span class="line"> context, resolveDialogTheme(context, themeResId)));  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Context getContext() &#123;  </span><br><span class="line"> return P.mContext;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setTitle(@StringRes int titleId) &#123;  </span><br><span class="line"> P.mTitle = P.mContext.getText(titleId);  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setTitle(CharSequence title) &#123;  </span><br><span class="line"> P.mTitle = title;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setCustomTitle(View customTitleView) &#123;  </span><br><span class="line"> P.mCustomTitleView = customTitleView;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setMessage(@StringRes int messageId) &#123;  </span><br><span class="line"> P.mMessage = P.mContext.getText(messageId);  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setMessage(CharSequence message) &#123;  </span><br><span class="line"> P.mMessage = message;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setIcon(@DrawableRes int iconId) &#123;  </span><br><span class="line"> P.mIconId = iconId;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setIcon(Drawable icon) &#123;  </span><br><span class="line"> P.mIcon = icon;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setIconAttribute(@AttrRes int attrId) &#123;  </span><br><span class="line"> TypedValue out = new TypedValue();  </span><br><span class="line"> P.mContext.getTheme().resolveAttribute(attrId, out, true);  </span><br><span class="line"> P.mIconId = out.resourceId;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mPositiveButtonText = P.mContext.getText(textId);  </span><br><span class="line"> P.mPositiveButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mPositiveButtonText = text;  </span><br><span class="line"> P.mPositiveButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setNegativeButton(@StringRes int textId, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mNegativeButtonText = P.mContext.getText(textId);  </span><br><span class="line"> P.mNegativeButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setNegativeButton(CharSequence text, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mNegativeButtonText = text;  </span><br><span class="line"> P.mNegativeButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setNeutralButton(@StringRes int textId, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mNeutralButtonText = P.mContext.getText(textId);  </span><br><span class="line"> P.mNeutralButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setNeutralButton(CharSequence text, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mNeutralButtonText = text;  </span><br><span class="line"> P.mNeutralButtonListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line"> public Builder setCancelable(boolean cancelable) &#123;  </span><br><span class="line"> P.mCancelable = cancelable;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setOnCancelListener(OnCancelListener onCancelListener) &#123;  </span><br><span class="line"> P.mOnCancelListener = onCancelListener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line"> public Builder setOnDismissListener(OnDismissListener onDismissListener) &#123;  </span><br><span class="line"> P.mOnDismissListener = onDismissListener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setOnKeyListener(OnKeyListener onKeyListener) &#123;  </span><br><span class="line"> P.mOnKeyListener = onKeyListener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setItems(@ArrayRes int itemsId, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mItems = P.mContext.getResources().getTextArray(itemsId);  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setItems(CharSequence[] items, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mItems = items;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setAdapter(final ListAdapter adapter, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mAdapter = adapter;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setCursor(final Cursor cursor, final OnClickListener listener,  </span><br><span class="line"> String labelColumn) &#123;  </span><br><span class="line"> P.mCursor = cursor;  </span><br><span class="line"> P.mLabelColumn = labelColumn;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setMultiChoiceItems(@ArrayRes int itemsId, boolean[] checkedItems,  </span><br><span class="line"> final OnMultiChoiceClickListener listener) &#123;  </span><br><span class="line"> P.mItems = P.mContext.getResources().getTextArray(itemsId);  </span><br><span class="line"> P.mOnCheckboxClickListener = listener;  </span><br><span class="line"> P.mCheckedItems = checkedItems;  </span><br><span class="line"> P.mIsMultiChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems,  </span><br><span class="line"> final OnMultiChoiceClickListener listener) &#123;  </span><br><span class="line"> P.mItems = items;  </span><br><span class="line"> P.mOnCheckboxClickListener = listener;  </span><br><span class="line"> P.mCheckedItems = checkedItems;  </span><br><span class="line"> P.mIsMultiChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setMultiChoiceItems(Cursor cursor, String isCheckedColumn, String labelColumn,  </span><br><span class="line"> final OnMultiChoiceClickListener listener) &#123;  </span><br><span class="line"> P.mCursor = cursor;  </span><br><span class="line"> P.mOnCheckboxClickListener = listener;  </span><br><span class="line"> P.mIsCheckedColumn = isCheckedColumn;  </span><br><span class="line"> P.mLabelColumn = labelColumn;  </span><br><span class="line"> P.mIsMultiChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setSingleChoiceItems(@ArrayRes int itemsId, int checkedItem,  </span><br><span class="line"> final OnClickListener listener) &#123;  </span><br><span class="line"> P.mItems = P.mContext.getResources().getTextArray(itemsId);  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> P.mCheckedItem = checkedItem;  </span><br><span class="line"> P.mIsSingleChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setSingleChoiceItems(Cursor cursor, int checkedItem, String labelColumn,  </span><br><span class="line"> final OnClickListener listener) &#123;  </span><br><span class="line"> P.mCursor = cursor;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> P.mCheckedItem = checkedItem;  </span><br><span class="line"> P.mLabelColumn = labelColumn;  </span><br><span class="line"> P.mIsSingleChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setSingleChoiceItems(CharSequence[] items, int checkedItem, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mItems = items;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> P.mCheckedItem = checkedItem;  </span><br><span class="line"> P.mIsSingleChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setSingleChoiceItems(ListAdapter adapter, int checkedItem, final OnClickListener listener) &#123;  </span><br><span class="line"> P.mAdapter = adapter;  </span><br><span class="line"> P.mOnClickListener = listener;  </span><br><span class="line"> P.mCheckedItem = checkedItem;  </span><br><span class="line"> P.mIsSingleChoice = true;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setOnItemSelectedListener(final AdapterView.OnItemSelectedListener listener) &#123;  </span><br><span class="line"> P.mOnItemSelectedListener = listener;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setView(int layoutResId) &#123;  </span><br><span class="line"> P.mView = null;  </span><br><span class="line"> P.mViewLayoutResId = layoutResId;  </span><br><span class="line"> P.mViewSpacingSpecified = false;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public Builder setView(View view) &#123;  </span><br><span class="line"> P.mView = view;  </span><br><span class="line"> P.mViewLayoutResId = 0;  </span><br><span class="line"> P.mViewSpacingSpecified = false;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> @Deprecated  </span><br><span class="line"> public Builder setView(View view, int viewSpacingLeft, int viewSpacingTop,  </span><br><span class="line"> int viewSpacingRight, int viewSpacingBottom) &#123;  </span><br><span class="line"> P.mView = view;  </span><br><span class="line"> P.mViewLayoutResId = 0;  </span><br><span class="line"> P.mViewSpacingSpecified = true;  </span><br><span class="line"> P.mViewSpacingLeft = viewSpacingLeft;  </span><br><span class="line"> P.mViewSpacingTop = viewSpacingTop;  </span><br><span class="line"> P.mViewSpacingRight = viewSpacingRight;  </span><br><span class="line"> P.mViewSpacingBottom = viewSpacingBottom;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> @Deprecated  </span><br><span class="line"> public Builder setInverseBackgroundForced(boolean useInverseBackground) &#123;  </span><br><span class="line"> P.mForceInverseBackground = useInverseBackground;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * @hide </span><br><span class="line"> */  </span><br><span class="line"> public Builder setRecycleOnMeasureEnabled(boolean enabled) &#123;  </span><br><span class="line"> P.mRecycleOnMeasure = enabled;  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public AlertDialog create() &#123;  </span><br><span class="line"> // Context has already been wrapped with the appropriate theme.  </span><br><span class="line"> final AlertDialog dialog = new AlertDialog(P.mContext, 0, false);  </span><br><span class="line"> P.apply(dialog.mAlert);  </span><br><span class="line"> dialog.setCancelable(P.mCancelable);  </span><br><span class="line"> if (P.mCancelable) &#123;  </span><br><span class="line"> dialog.setCanceledOnTouchOutside(true);  </span><br><span class="line"> &#125;  </span><br><span class="line"> dialog.setOnCancelListener(P.mOnCancelListener);  </span><br><span class="line"> dialog.setOnDismissListener(P.mOnDismissListener);  </span><br><span class="line"> if (P.mOnKeyListener != null) &#123;  </span><br><span class="line"> dialog.setOnKeyListener(P.mOnKeyListener);  </span><br><span class="line"> &#125;  </span><br><span class="line"> return dialog;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> public AlertDialog show() &#123;  </span><br><span class="line"> final AlertDialog dialog = create();  </span><br><span class="line"> dialog.show();  </span><br><span class="line"> return dialog;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在AlertDialog的Builder模式中并没有看到Director角色出现，其实在很多场景中，Android并没有完全按照经典模式实现来做，而是做了一些修改，使得这个模式更易于使用。</p>
<p>这里的AlertDialog.Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做一些精简，而不是生搬硬套，使程序失去架构之美。正是由于灵活地运用设计模式，Android的源码很值得我们深入学习。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/17/Android消息机制底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/17/Android消息机制底层原理/" itemprop="url">
                  Android消息机制底层原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-17T20:44:28+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/17/Android消息机制底层原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/17/Android消息机制底层原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue是消息队列。他的内存存储了一组消息，以队列的形式对外提供插入和删除的工作。他的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper为消息循环，由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环的形式去查找是否有新的消息，如果有的话就处理消息，否则就一直等待，Looper还有一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是线程，它的作用可以在每个线程中存储数据。我们知道，Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal可以轻松获取每个线程的Looper。当然需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。我们经常提到的主线程，也就是UI线程，它就是ActivityThread，ActivityThread被创建时会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<p><img src="http://img.blog.csdn.net/20170117201927411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-ThreadLocal-线程局部变量"><a href="#2-ThreadLocal-线程局部变量" class="headerlink" title="2.ThreadLocal-线程局部变量"></a>2.ThreadLocal-线程局部变量</h1><p>ThreadLocal是一个现场内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据。对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存储。ThreadLocal是一个泛型类。<br><img src="http://img.blog.csdn.net/20170117202844933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h2 id="2-1存储机制"><a href="#2-1存储机制" class="headerlink" title="2.1存储机制"></a>2.1存储机制</h2><p>在localValues内部有一个数组；private Object[]table，ThreadLocal的值就存在这个table数组中，ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置，比如ThreadLocal的reference对象在table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1.最终ThreadLocal的值将会被存储在table数组中：table[index+1]=value</p>
<h2 id="2-put"><a href="#2-put" class="headerlink" title="2.put"></a>2.put</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> void put(ThreadLocal&lt;?&gt; key, Object value) &#123;  </span><br><span class="line">  cleanUp();  </span><br><span class="line">  </span><br><span class="line">  // Keep track of first tombstone. That&apos;s where we want to go back  </span><br><span class="line">  // and add an entry if necessary.  </span><br><span class="line">  int firstTombstone = -1;  </span><br><span class="line">  </span><br><span class="line">  for (int index = key.hash &amp; mask;; index = next(index)) &#123;  </span><br><span class="line">  Object k = table[index];  </span><br><span class="line">  </span><br><span class="line">  if (k == key.reference) &#123;  </span><br><span class="line">  // Replace existing entry.  </span><br><span class="line">  table[index + 1] = value;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  if (k == null) &#123;  </span><br><span class="line">  if (firstTombstone == -1) &#123;  </span><br><span class="line">  // Fill in null slot.  </span><br><span class="line">  table[index] = key.reference;  </span><br><span class="line">  table[index + 1] = value;  </span><br><span class="line">  size++;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // Go back and replace first tombstone.  </span><br><span class="line">  table[firstTombstone] = key.reference;  </span><br><span class="line">  table[firstTombstone + 1] = value;  </span><br><span class="line">  tombstones--;  </span><br><span class="line">  size++;  </span><br><span class="line">  return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // Remember first tombstone.  </span><br><span class="line">  if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;  </span><br><span class="line">  firstTombstone = index;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">//获取当前线程的数据  </span><br><span class="line">  Values values(Thread current) &#123;  </span><br><span class="line">  return current.localValues;//当前线程存储的数组  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">//初始化当前线程的数据  </span><br><span class="line">Values initializeValues(Thread current) &#123;  </span><br><span class="line">  return current.localValues = new Values();  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-set"><a href="#2-3-set" class="headerlink" title="2.3 set"></a>2.3 set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;  </span><br><span class="line">Thread currentThread = Thread.currentThread();//获取当前的线程  </span><br><span class="line">Values values = values(currentThread);//  </span><br><span class="line">if (values == null) &#123;  </span><br><span class="line">values = initializeValues(currentThread);  </span><br><span class="line">&#125;  </span><br><span class="line">values.put(this, value);  </span><br><span class="line">&#125;  </span><br><span class="line">3）get</span><br><span class="line">[java] view plain copy 在CODE上查看代码片派生到我的代码片</span><br><span class="line">public T get() &#123;  </span><br><span class="line"> // Optimized for the fast path.  </span><br><span class="line"> Thread currentThread = Thread.currentThread();  </span><br><span class="line"> Values values = values(currentThread);  </span><br><span class="line"> if (values != null) &#123;  </span><br><span class="line"> Object[] table = values.table;  </span><br><span class="line"> int index = hash &amp; values.mask;  </span><br><span class="line"> if (this.reference == table[index]) &#123;  </span><br><span class="line"> return (T) table[index + 1];  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> values = initializeValues(currentThread);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> return (T) values.getAfterMiss(this);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，他们对ThreadLocal所做的读写操作仅限于各自线程的内部。</p>
<h1 id="3-MessageQueue-消息队列"><a href="#3-MessageQueue-消息队列" class="headerlink" title="3.MessageQueue-消息队列"></a>3.MessageQueue-消息队列</h1><p>消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中 插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。MessageQueue内部是通过一个单链表的数据结构来维护消息列表，当链表在插入和删除上比较有优势。<br><img src="http://img.blog.csdn.net/20170117203122771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h2 id="3-1enqueueMessage插入消息"><a href="#3-1enqueueMessage插入消息" class="headerlink" title="3.1enqueueMessage插入消息"></a>3.1enqueueMessage插入消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;  </span><br><span class="line">  if (msg.target == null) &#123;  </span><br><span class="line">  throw new IllegalArgumentException(&quot;Message must have a target.&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (msg.isInUse()) &#123;  </span><br><span class="line">  throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  synchronized (this) &#123;  </span><br><span class="line">  if (mQuitting) &#123;  </span><br><span class="line">  IllegalStateException e = new IllegalStateException(  </span><br><span class="line">  msg.target + &quot; sending message to a Handler on a dead thread&quot;);  </span><br><span class="line">  Log.w(TAG, e.getMessage(), e);  </span><br><span class="line">  msg.recycle();  </span><br><span class="line">  return false;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  msg.markInUse();  </span><br><span class="line">  msg.when = when;  </span><br><span class="line">  Message p = mMessages;  </span><br><span class="line">  boolean needWake;  </span><br><span class="line">  if (p == null || when == 0 || when &lt; p.when) &#123;  </span><br><span class="line">  // New head, wake up the event queue if blocked.  </span><br><span class="line">  msg.next = p;  </span><br><span class="line">  mMessages = msg;  </span><br><span class="line">  needWake = mBlocked;  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  // Inserted within the middle of the queue. Usually we don&apos;t have to wake  </span><br><span class="line">  // up the event queue unless there is a barrier at the head of the queue  </span><br><span class="line">  // and the message is the earliest asynchronous message in the queue.  </span><br><span class="line">  needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();  </span><br><span class="line">  Message prev;  </span><br><span class="line">  for (;;) &#123;  </span><br><span class="line">  prev = p;  </span><br><span class="line">  p = p.next;  </span><br><span class="line">  if (p == null || when &lt; p.when) &#123;  </span><br><span class="line">  break;  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (needWake &amp;&amp; p.isAsynchronous()) &#123;  </span><br><span class="line">  needWake = false;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  msg.next = p; // invariant: p == prev.next  </span><br><span class="line">  prev.next = msg;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // We can assume mPtr != 0 because mQuitting is false.  </span><br><span class="line">  if (needWake) &#123;  </span><br><span class="line">  nativeWake(mPtr);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  return true;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-next获取消息"><a href="#3-2-next获取消息" class="headerlink" title="3.2 next获取消息"></a>3.2 next获取消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;  </span><br><span class="line">// Return here if the message loop has already quit and been disposed.  </span><br><span class="line">// This can happen if the application tries to restart a looper after quit  </span><br><span class="line">// which is not supported.  </span><br><span class="line">final long ptr = mPtr;  </span><br><span class="line">if (ptr == 0) &#123;  </span><br><span class="line">return null;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int pendingIdleHandlerCount = -1; // -1 only during first iteration  </span><br><span class="line">int nextPollTimeoutMillis = 0;  </span><br><span class="line">for (;;) &#123;  </span><br><span class="line">if (nextPollTimeoutMillis != 0) &#123;  </span><br><span class="line">Binder.flushPendingCommands();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">nativePollOnce(ptr, nextPollTimeoutMillis);  </span><br><span class="line">  </span><br><span class="line">synchronized (this) &#123;  </span><br><span class="line">// Try to retrieve the next message. Return if found.  </span><br><span class="line">final long now = SystemClock.uptimeMillis();  </span><br><span class="line">Message prevMsg = null;  </span><br><span class="line">Message msg = mMessages;  </span><br><span class="line">if (msg != null &amp;&amp; msg.target == null) &#123;  </span><br><span class="line">// Stalled by a barrier. Find the next asynchronous message in the queue.  </span><br><span class="line">do &#123;  </span><br><span class="line">prevMsg = msg;  </span><br><span class="line">msg = msg.next;  </span><br><span class="line">&#125; while (msg != null &amp;&amp; !msg.isAsynchronous());  </span><br><span class="line">&#125;  </span><br><span class="line">if (msg != null) &#123;  </span><br><span class="line">if (now &lt; msg.when) &#123;  </span><br><span class="line">// Next message is not ready. Set a timeout to wake up when it is ready.  </span><br><span class="line">nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">// Got a message.  </span><br><span class="line">mBlocked = false;  </span><br><span class="line">if (prevMsg != null) &#123;  </span><br><span class="line">prevMsg.next = msg.next;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">mMessages = msg.next;  </span><br><span class="line">&#125;  </span><br><span class="line">msg.next = null;  </span><br><span class="line">if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);  </span><br><span class="line">msg.markInUse();  </span><br><span class="line">return msg;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">// No more messages.  </span><br><span class="line">nextPollTimeoutMillis = -1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Process the quit message now that all pending messages have been handled.  </span><br><span class="line">if (mQuitting) &#123;  </span><br><span class="line">dispose();  </span><br><span class="line">return null;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// If first time idle, then get the number of idlers to run.  </span><br><span class="line">// Idle handles only run if the queue is empty or if the first message  </span><br><span class="line">// in the queue (possibly a barrier) is due to be handled in the future.  </span><br><span class="line">if (pendingIdleHandlerCount &lt; 0  </span><br><span class="line">&amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;  </span><br><span class="line">pendingIdleHandlerCount = mIdleHandlers.size();  </span><br><span class="line">&#125;  </span><br><span class="line">if (pendingIdleHandlerCount &lt;= 0) &#123;  </span><br><span class="line">// No idle handlers to run. Loop and wait some more.  </span><br><span class="line">mBlocked = true;  </span><br><span class="line">continue;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (mPendingIdleHandlers == null) &#123;  </span><br><span class="line">mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];  </span><br><span class="line">&#125;  </span><br><span class="line">mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Run the idle handlers.  </span><br><span class="line">// We only ever reach this code block during the first iteration.  </span><br><span class="line">for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;  </span><br><span class="line">final IdleHandler idler = mPendingIdleHandlers[i];  </span><br><span class="line">mPendingIdleHandlers[i] = null; // release the reference to the handler  </span><br><span class="line">  </span><br><span class="line">boolean keep = false;  </span><br><span class="line">try &#123;  </span><br><span class="line">keep = idler.queueIdle();  </span><br><span class="line">&#125; catch (Throwable t) &#123;  </span><br><span class="line">Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (!keep) &#123;  </span><br><span class="line">synchronized (this) &#123;  </span><br><span class="line">mIdleHandlers.remove(idler);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Reset the idle handler count to 0 so we do not run them again.  </span><br><span class="line">pendingIdleHandlerCount = 0;  </span><br><span class="line">  </span><br><span class="line">// While calling an idle handler, a new message could have been delivered  </span><br><span class="line">// so go back and look again for a pending message without waiting.  </span><br><span class="line">nextPollTimeoutMillis = 0;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直堵塞在这里。当有新消息到来时，next方法会返回这条消息并将其从链表中移除</p>
<h1 id="4-Message-消息实体"><a href="#4-Message-消息实体" class="headerlink" title="4.Message- 消息实体"></a>4.Message- 消息实体</h1><p>需要注意Message的一些成员变量<br> Handler target;  //对应的Handler<br> Runnable callback; //对应的回调<br>Message next;//单链表引用</p>
<p><img src="http://img.blog.csdn.net/20170117203304149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="5-Looper-消息循环"><a href="#5-Looper-消息循环" class="headerlink" title="5.Looper-消息循环"></a>5.Looper-消息循环</h1><p>Looper在Android的消息机制中扮演着消息循环的角色，具体来说就是他会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在哪里。<br><img src="http://img.blog.csdn.net/20170117203344134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>Looper处理prepare方法外，还提供了prepareMainLooper方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现。由于主线程的Looper比较特殊，所以Looper提供一个getMainLooper方法，通过它可以在任何地方获取主线程的Looper。Looper也是可以退出的，Looper提供勒quit和quitSafely来退出一个Looper。quit会直接退出Looper，而quitSafely只是设定一个退出标记，然后把消息队列的已有消息处理完毕后才安全退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程，如果手动为其创建了Looper，那么所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处理等待的状态。<br>Looper最重要的一个方法是Loop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;  </span><br><span class="line">final Looper me = myLooper();  </span><br><span class="line">if (me == null) &#123;  </span><br><span class="line">throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">final MessageQueue queue = me.mQueue;  </span><br><span class="line">  </span><br><span class="line">// Make sure the identity of this thread is that of the local process,  </span><br><span class="line">// and keep track of what that identity token actually is.  </span><br><span class="line">Binder.clearCallingIdentity();  </span><br><span class="line">final long ident = Binder.clearCallingIdentity();  </span><br><span class="line">  </span><br><span class="line">for (;;) &#123;  </span><br><span class="line">Message msg = queue.next(); // might block  </span><br><span class="line">if (msg == null) &#123;  </span><br><span class="line">// No message indicates that the message queue is quitting.  </span><br><span class="line">return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// This must be in a local variable, in case a UI event sets the logger  </span><br><span class="line">Printer logging = me.mLogging;  </span><br><span class="line">if (logging != null) &#123;  </span><br><span class="line">logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +  </span><br><span class="line">msg.callback + &quot;: &quot; + msg.what);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">msg.target.dispatchMessage(msg);  </span><br><span class="line">  </span><br><span class="line">if (logging != null) &#123;  </span><br><span class="line">logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Make sure that during the course of dispatching the  </span><br><span class="line">// identity of the thread wasn&apos;t corrupted.  </span><br><span class="line">final long newIdent = Binder.clearCallingIdentity();  </span><br><span class="line">if (ident != newIdent) &#123;  </span><br><span class="line">Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;  </span><br><span class="line">+ Long.toHexString(ident) + &quot; to 0x&quot;  </span><br><span class="line">+ Long.toHexString(newIdent) + &quot; while dispatching to &quot;  </span><br><span class="line">+ msg.target.getClass().getName() + &quot; &quot;  </span><br><span class="line">+ msg.callback + &quot; what=&quot; + msg.what);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">msg.recycleUnchecked();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，他的next方法会返回null。loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在哪里，这也导致loop方法一直阻塞在哪里。若有新消息，Looper会调用msg。target。dispatchMessage（msg），这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息最终又交给它的dispatchMessage方法来处理了。但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行，这样就成功将代码逻辑切换到指定的线程中去执行了。</p>
<h1 id="6-Handle-消息处理"><a href="#6-Handle-消息处理" class="headerlink" title="6.Handle-消息处理"></a>6.Handle-消息处理</h1><p>Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。<br><img src="http://img.blog.csdn.net/20170117203435091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h2 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h2><p>使用Handler必须要有Looper，不然会报异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback) &#123;  </span><br><span class="line">  this(callback, false);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  /** </span><br><span class="line">  * Use the provided &#123;@link Looper&#125; instead of the default one. </span><br><span class="line">  * </span><br><span class="line">  * @param looper The looper, must not be null. </span><br><span class="line">  */  </span><br><span class="line">  public Handler(Looper looper) &#123;  </span><br><span class="line">  this(looper, null, false);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public Handler(Callback callback, boolean async) &#123;  </span><br><span class="line">  if (FIND_POTENTIAL_LEAKS) &#123;  </span><br><span class="line">  final Class&lt;? extends Handler&gt; klass = getClass();  </span><br><span class="line">  if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;  </span><br><span class="line">  (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;  </span><br><span class="line">  Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +  </span><br><span class="line">  klass.getCanonicalName());  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  mLooper = Looper.myLooper();  </span><br><span class="line">  if (mLooper == null) &#123;  </span><br><span class="line">  throw new RuntimeException(  </span><br><span class="line">  &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  mQueue = mLooper.mQueue;  </span><br><span class="line">  mCallback = callback;  </span><br><span class="line">  mAsynchronous = async;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-2-发送"><a href="#6-2-发送" class="headerlink" title="6.2 发送"></a>6.2 发送</h2><p>Handler发送消息的过程仅仅是向消息队列中插入了一条消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;  </span><br><span class="line"> MessageQueue queue = mQueue;  </span><br><span class="line"> if (queue == null) &#123;  </span><br><span class="line"> RuntimeException e = new RuntimeException(  </span><br><span class="line"> this + &quot; sendMessageAtTime() called with no mQueue&quot;);  </span><br><span class="line"> Log.w(&quot;Looper&quot;, e.getMessage(), e);  </span><br><span class="line"> return false;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return enqueueMessage(queue, msg, uptimeMillis);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-3-接收"><a href="#6-3-接收" class="headerlink" title="6.3 接收"></a>6.3 接收</h2><p> 当消息队列插入消息后，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;  </span><br><span class="line"> public boolean handleMessage(Message msg);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * Subclasses must implement this to receive messages. </span><br><span class="line"> */  </span><br><span class="line"> public void handleMessage(Message msg) &#123;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> /** </span><br><span class="line"> * Handle system messages here. </span><br><span class="line"> */  </span><br><span class="line"> public void dispatchMessage(Message msg) &#123;  </span><br><span class="line"> if (msg.callback != null) &#123;  </span><br><span class="line"> handleCallback(msg);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> if (mCallback != null) &#123;  </span><br><span class="line"> if (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line"> return;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> handleMessage(msg);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-主线程的消息循环"><a href="#7-主线程的消息循环" class="headerlink" title="7.主线程的消息循环"></a>7.主线程的消息循环</h1><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper。loop（）来开启主线程的消息循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);  </span><br><span class="line"> SamplingProfilerIntegration.start();  </span><br><span class="line">  </span><br><span class="line"> // CloseGuard defaults to true and can be quite spammy. We  </span><br><span class="line"> // disable it here, but selectively enable it later (via  </span><br><span class="line"> // StrictMode) on debug builds, but using DropBox, not logs.  </span><br><span class="line"> CloseGuard.setEnabled(false);  </span><br><span class="line">  </span><br><span class="line"> Environment.initForCurrentUser();  </span><br><span class="line">  </span><br><span class="line"> // Set the reporter for event logging in libcore  </span><br><span class="line"> EventLogger.setReporter(new EventLoggingReporter());  </span><br><span class="line">  </span><br><span class="line"> AndroidKeyStoreProvider.install();  </span><br><span class="line">  </span><br><span class="line"> // Make sure TrustedCertificateStore looks in the right place for CA certificates  </span><br><span class="line"> final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());  </span><br><span class="line"> TrustedCertificateStore.setDefaultUserDirectory(configDir);  </span><br><span class="line">  </span><br><span class="line"> Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);  </span><br><span class="line">  </span><br><span class="line"> Looper.prepareMainLooper();  </span><br><span class="line">  </span><br><span class="line"> ActivityThread thread = new ActivityThread();  </span><br><span class="line"> thread.attach(false);  </span><br><span class="line">  </span><br><span class="line"> if (sMainThreadHandler == null) &#123;  </span><br><span class="line"> sMainThreadHandler = thread.getHandler();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (false) &#123;  </span><br><span class="line"> Looper.myLooper().setMessageLogging(new  </span><br><span class="line"> LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> // End of event ActivityThreadMain.  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line"> Looper.loop();  </span><br><span class="line">  </span><br><span class="line"> throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>主线程的消息循环开始以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，他的内部定义了一组消息类型，主要管理Activity的生命周期及四大组件的启动和停止过程等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> private class H extends Handler &#123;  </span><br><span class="line">  public static final int LAUNCH_ACTIVITY = 100;  </span><br><span class="line">  public static final int PAUSE_ACTIVITY = 101;  </span><br><span class="line">  public static final int PAUSE_ACTIVITY_FINISHING= 102;  </span><br><span class="line">  public static final int STOP_ACTIVITY_SHOW = 103;  </span><br><span class="line">  public static final int STOP_ACTIVITY_HIDE = 104;  </span><br><span class="line">  public static final int SHOW_WINDOW = 105;  </span><br><span class="line">  public static final int HIDE_WINDOW = 106;  </span><br><span class="line">  public static final int RESUME_ACTIVITY = 107;  </span><br><span class="line">  public static final int SEND_RESULT = 108;  </span><br><span class="line">  public static final int DESTROY_ACTIVITY = 109;  </span><br><span class="line">  public static final int BIND_APPLICATION = 110;  </span><br><span class="line">  public static final int EXIT_APPLICATION = 111;  </span><br><span class="line">  public static final int NEW_INTENT = 112;  </span><br><span class="line">  public static final int RECEIVER = 113;  </span><br><span class="line">  public static final int CREATE_SERVICE = 114;  </span><br><span class="line">  public static final int SERVICE_ARGS = 115;  </span><br><span class="line">  public static final int STOP_SERVICE = 116;  </span><br><span class="line">  </span><br><span class="line">  public static final int CONFIGURATION_CHANGED = 118;  </span><br><span class="line">  public static final int CLEAN_UP_CONTEXT = 119;  </span><br><span class="line">  public static final int GC_WHEN_IDLE = 120;  </span><br><span class="line">  public static final int BIND_SERVICE = 121;  </span><br><span class="line">  public static final int UNBIND_SERVICE = 122;  </span><br><span class="line">  public static final int DUMP_SERVICE = 123;  </span><br><span class="line">  public static final int LOW_MEMORY = 124;  </span><br><span class="line">  public static final int ACTIVITY_CONFIGURATION_CHANGED = 125;  </span><br><span class="line">  public static final int RELAUNCH_ACTIVITY = 126;  </span><br><span class="line">  public static final int PROFILER_CONTROL = 127;  </span><br><span class="line">  public static final int CREATE_BACKUP_AGENT = 128;  </span><br><span class="line">  public static final int DESTROY_BACKUP_AGENT = 129;  </span><br><span class="line">  public static final int SUICIDE = 130;  </span><br><span class="line">  public static final int REMOVE_PROVIDER = 131;  </span><br><span class="line">  public static final int ENABLE_JIT = 132;  </span><br><span class="line">  public static final int DISPATCH_PACKAGE_BROADCAST = 133;  </span><br><span class="line">  public static final int SCHEDULE_CRASH = 134;  </span><br><span class="line">  public static final int DUMP_HEAP = 135;  </span><br><span class="line">  public static final int DUMP_ACTIVITY = 136;  </span><br><span class="line">  public static final int SLEEPING = 137;  </span><br><span class="line">  public static final int SET_CORE_SETTINGS = 138;  </span><br><span class="line">  public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139;  </span><br><span class="line">  public static final int TRIM_MEMORY = 140;  </span><br><span class="line">  public static final int DUMP_PROVIDER = 141;  </span><br><span class="line">  public static final int UNSTABLE_PROVIDER_DIED = 142;  </span><br><span class="line">  public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143;  </span><br><span class="line">  public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144;  </span><br><span class="line">  public static final int INSTALL_PROVIDER = 145;  </span><br><span class="line">  public static final int ON_NEW_ACTIVITY_OPTIONS = 146;  </span><br><span class="line">  public static final int CANCEL_VISIBLE_BEHIND = 147;  </span><br><span class="line">  public static final int BACKGROUND_VISIBLE_BEHIND_CHANGED = 148;  </span><br><span class="line">  public static final int ENTER_ANIMATION_COMPLETE = 149;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外经常使用的runOnUIThread(Runable action),通过源码分析也是使用了mHandler，而mHandler的Looper也是使用的UI线程的mainLooper。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void runOnUiThread(Runnable action) &#123;  </span><br><span class="line">      if (Thread.currentThread() != mUiThread) &#123;  </span><br><span class="line">          mHandler.post(action);  </span><br><span class="line">      &#125; else &#123;  </span><br><span class="line">          action.run();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/14/设计模式-模板模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/14/设计模式-模板模式/" itemprop="url">
                  设计模式-模板模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-14T09:42:44+08:00">
                2017-01-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/14/设计模式-模板模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/14/设计模式-模板模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-模板模式的定义及使用场景"><a href="#1-模板模式的定义及使用场景" class="headerlink" title="1.模板模式的定义及使用场景"></a>1.模板模式的定义及使用场景</h1><p>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><img src="http://img.blog.csdn.net/20170114093517561?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>多个子类有公有的方法，并且逻辑基本相同</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为</li>
</ul>
<h1 id="2-模板模式的优缺点"><a href="#2-模板模式的优缺点" class="headerlink" title="2.模板模式的优缺点"></a>2.模板模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>封装不变的部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
<li>行为由父类控制，子类实现<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响父类的结果，也就是子类对父类产生了影响，在负责的项目中，会带来代码阅读的复杂性<h2 id="2-3注意事项"><a href="#2-3注意事项" class="headerlink" title="2.3注意事项"></a>2.3注意事项</h2>在开发中经常遇到一个问题，父类怎么调用子类的方法？应善用模板模式，避免如下的使用：</li>
<li>把子类传递到父类的有参构造中，然后调用</li>
<li>使用反射的反射调用</li>
<li>父类调用子类的静态方法<h1 id="3-模板模式的实现方式"><a href="#3-模板模式的实现方式" class="headerlink" title="3.模板模式的实现方式"></a>3.模板模式的实现方式</h1>AbstactTemple <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstactTemple &#123;  </span><br><span class="line">  </span><br><span class="line">    protected abstract void doOne();  </span><br><span class="line">  </span><br><span class="line">    protected abstract boolean doTwo();  </span><br><span class="line">  </span><br><span class="line">    public final void templeMethod() &#123;  </span><br><span class="line">        doOne();  </span><br><span class="line">        if (doTwo()) &#123;  </span><br><span class="line">            System.out.println(&quot;the world is bueatiful&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ConcreteTempleOne<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTempleOne extends AbstactTemple &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void doOne() &#123;  </span><br><span class="line">        System.out.println(&quot;ConcreteTempleOne:&quot; + &quot;doOne&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected boolean doTwo() &#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcreteTempleTwo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTempleTwo extends AbstactTemple &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void doOne() &#123;  </span><br><span class="line">        System.out.println(&quot;ConcreteTempleTwo:&quot; + &quot;doOne&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected boolean doTwo() &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        AbstactTemple templeOne = new ConcreteTempleOne();  </span><br><span class="line">        AbstactTemple templeTwo = new ConcreteTempleTwo();  </span><br><span class="line">        templeOne.templeMethod();  </span><br><span class="line">        templeTwo.templeMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-模板模式在Android中的实际应用"><a href="#4-模板模式在Android中的实际应用" class="headerlink" title="4.模板模式在Android中的实际应用"></a>4.模板模式在Android中的实际应用</h1><p>在Android中，AsyncTask是比较常见的一个类型，这个类就是使用了模板模式。在使用AsyncTask时，我们都知道把耗时的方法放在doInBackground（Params… params）中，在doInBackground之前，如果还想做一些类似初始化的操作，可以把实现卸载onPreExecutre方法中，当doInBackground方法执行完成后，会执行onPostExecutre方法，而我们只需要构建AsyncTask对象，然后执行exexute方法即可。</p>
<p>AsyncTask主要使用了线程池及任务队列，handle消息机制。</p>
<p>启动执行：将任务交由线程池处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;  </span><br><span class="line"> return executeOnExecutor(sDefaultExecutor, params);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">ublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,  </span><br><span class="line"> Params... params) &#123;  </span><br><span class="line"> if (mStatus != Status.PENDING) &#123;  </span><br><span class="line"> switch (mStatus) &#123;  </span><br><span class="line"> case RUNNING:  </span><br><span class="line"> throw new IllegalStateException(&quot;Cannot execute task:&quot;  </span><br><span class="line"> + &quot; the task is already running.&quot;);  </span><br><span class="line"> case FINISHED:  </span><br><span class="line"> throw new IllegalStateException(&quot;Cannot execute task:&quot;  </span><br><span class="line"> + &quot; the task has already been executed &quot;  </span><br><span class="line"> + &quot;(a task can be executed only once)&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> mStatus = Status.RUNNING;  </span><br><span class="line">  </span><br><span class="line"> onPreExecute(); //初始化  </span><br><span class="line">  </span><br><span class="line"> mWorker.mParams = params;  </span><br><span class="line"> exec.execute(mFuture);  </span><br><span class="line">  </span><br><span class="line"> return this;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>处理消息队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;  </span><br><span class="line"> mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;  </span><br><span class="line"> public Result call() throws Exception &#123;  </span><br><span class="line"> mTaskInvoked.set(true);  </span><br><span class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line"> //noinspection unchecked  </span><br><span class="line"> Result result = doInBackground(mParams); //处理后台的方法  </span><br><span class="line"> Binder.flushPendingCommands();  </span><br><span class="line"> return postResult(result); //消息分发  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">  </span><br><span class="line"> mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;  </span><br><span class="line"> @Override  </span><br><span class="line"> protected void done() &#123;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> postResultIfNotInvoked(get());  </span><br><span class="line"> &#125; catch (InterruptedException e) &#123;  </span><br><span class="line"> android.util.Log.w(LOG_TAG, e);  </span><br><span class="line"> &#125; catch (ExecutionException e) &#123;  </span><br><span class="line"> throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,  </span><br><span class="line"> e.getCause());  </span><br><span class="line"> &#125; catch (CancellationException e) &#123;  </span><br><span class="line"> postResultIfNotInvoked(null);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> private Result postResult(Result result) &#123;  </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line"> Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,  </span><br><span class="line"> new AsyncTaskResult&lt;Result&gt;(this, result));  </span><br><span class="line"> message.sendToTarget();  </span><br><span class="line"> return result;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>处理Mesage消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;  </span><br><span class="line">  public InternalHandler() &#123;  </span><br><span class="line">  super(Looper.getMainLooper());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)  </span><br><span class="line">  @Override  </span><br><span class="line">  public void handleMessage(Message msg) &#123;  </span><br><span class="line">  AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;  </span><br><span class="line">  switch (msg.what) &#123;  </span><br><span class="line">  case MESSAGE_POST_RESULT:  </span><br><span class="line">  // There is only one result  </span><br><span class="line">  result.mTask.finish(result.mData[0]);  </span><br><span class="line">  break;  </span><br><span class="line">  case MESSAGE_POST_PROGRESS:  </span><br><span class="line">  result.mTask.onProgressUpdate(result.mData);  </span><br><span class="line">  break;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  private void finish(Result result) &#123;  </span><br><span class="line">  if (isCancelled()) &#123;  </span><br><span class="line">  onCancelled(result);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  onPostExecute(result);//处理完成的回调  </span><br><span class="line">  &#125;  </span><br><span class="line">  mStatus = Status.FINISHED;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/11/设计模式-抽象工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/设计模式-抽象工厂模式/" itemprop="url">
                  设计模式-抽象工厂模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-11T12:13:33+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/11/设计模式-抽象工厂模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/11/设计模式-抽象工厂模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-抽象工厂模式的定义及使用场景"><a href="#1-抽象工厂模式的定义及使用场景" class="headerlink" title="1.抽象工厂模式的定义及使用场景"></a>1.抽象工厂模式的定义及使用场景</h1><p>抽象工厂也是创建型设计模式之一。为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体类。一个对象族有相同约束时可以使用抽象工厂模式。<br><img src="http://img.blog.csdn.net/20170111121026175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-抽象工厂模式的优缺点"><a href="#2-抽象工厂模式的优缺点" class="headerlink" title="2.抽象工厂模式的优缺点"></a>2.抽象工厂模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>良好封装性，低耦合</li>
<li>产品族内具有约束性，且为非公开状态<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>产品族的扩展非常困难，需要修改抽象工厂及其实现，违背了开闭原则。但工厂的扩展是灵活的。<h1 id="3-抽象工厂模式的实现方式"><a href="#3-抽象工厂模式的实现方式" class="headerlink" title="3.抽象工厂模式的实现方式"></a>3.抽象工厂模式的实现方式</h1>ProductA </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ProductA &#123;  </span><br><span class="line">   public abstract void excute();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductA1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductA1 extends ProductA &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">   public void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductA1excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductA2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductA2 extends ProductA &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">   public void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductA2excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ProductB &#123;  </span><br><span class="line">   public abstract void excute();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductB1 extends ProductB &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">   public void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductB1excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductB2 extends ProductB &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductB2excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Factory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;  </span><br><span class="line">    public abstract &lt;T extends ProductA&gt; T createA();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public abstract &lt;T extends ProductB&gt; T createB();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcreteOneFactory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteOneFactory extends Factory &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public &lt;T extends ProductA&gt; T createA() &#123;  </span><br><span class="line">        ProductA product = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            product = new ProductA1();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return (T) product;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public &lt;T extends ProductB&gt; T createB() &#123;  </span><br><span class="line">        ProductB1 product = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            product = new ProductB1();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return (T) product;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcreteTwoFactory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTwoFactory extends Factory &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public &lt;T extends ProductA&gt; T createA() &#123;  </span><br><span class="line">        ProductA2 product = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            product = new ProductA2();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return (T) product;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public &lt;T extends ProductB&gt; T createB() &#123;  </span><br><span class="line">        ProductB2 product = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            product = new ProductB2();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return (T) product;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Factory fOne = new ConcreteOneFactory();  </span><br><span class="line">        Factory fTwo = new ConcreteTwoFactory();  </span><br><span class="line">        ProductA a1 = fOne.createA();  </span><br><span class="line">        ProductB b1 = fOne.createB();  </span><br><span class="line">        a1.excute();  </span><br><span class="line">        b1.excute();  </span><br><span class="line">        ProductA a2 = fTwo.createA();  </span><br><span class="line">        ProductB b2 = fTwo.createB();  </span><br><span class="line">        a2.excute();  </span><br><span class="line">        b2.excute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/10/设计模式-工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/10/设计模式-工厂模式/" itemprop="url">
                  设计模式-工厂模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-10T09:36:23+08:00">
                2017-01-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/10/设计模式-工厂模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/10/设计模式-工厂模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-工厂模式的定义及使用场景"><a href="#1-工厂模式的定义及使用场景" class="headerlink" title="1.工厂模式的定义及使用场景"></a>1.工厂模式的定义及使用场景</h1><p>工厂模式是创建型设计模式之一。定义一个用户创建对象的接口，让子类决定实例化那个类。工厂模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用</p>
<p><img src="http://img.blog.csdn.net/20170110092505708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-工厂模式的优缺点"><a href="#2-工厂模式的优缺点" class="headerlink" title="2.工厂模式的优缺点"></a>2.工厂模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>良好的封装性，代码结构清晰</li>
<li>具有良好的扩展性，在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成需求变化</li>
<li>典型解耦框架，遵循迪米特法则、里氏替换原则、依赖倒置原则<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>需要谨慎考虑是否要增加一个工厂类进行管理，会增加代码的复杂度</li>
</ul>
<h1 id="3-工厂模式的实现方式"><a href="#3-工厂模式的实现方式" class="headerlink" title="3.工厂模式的实现方式"></a>3.工厂模式的实现方式</h1><p>Product:抽象产品类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Product &#123;  </span><br><span class="line">  public abstract void excute();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Facory：抽象工厂类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;  </span><br><span class="line">  public abstract &lt;T extends Product&gt; T excute(Class&lt;T&gt; tClass);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcreteFactory：工厂实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory extends Factory &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">  public  &lt;T extends Product&gt; T excute(Class&lt;T&gt; tClass) &#123;  </span><br><span class="line">        Product product = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            product = (Product) Class.forName(tClass.getName()).newInstance();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return (T)product;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductOne：产品实现One<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductOne extends Product &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">  public void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductOne excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductTwo：产品实现Two<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductTwo extends Product &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public  void excute() &#123;  </span><br><span class="line">        System.out.println(&quot;ProductTwo excute!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test：客户端使用类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Factory factory = new ConcreteFactory();  </span><br><span class="line">        Product r1 = factory.excute(ProductOne.class);  </span><br><span class="line">        r1.excute();  </span><br><span class="line">        Product r2 = factory.excute(ProductTwo.class);  </span><br><span class="line">        r2.excute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-工厂模式在Android中的实际应用"><a href="#4-工厂模式在Android中的实际应用" class="headerlink" title="4.工厂模式在Android中的实际应用"></a>4.工厂模式在Android中的实际应用</h1><p>关于Activity的创建工程，是一个复杂的调度过程。这里我们主要研究Activity的创建是如何采用实现。Activity的创建最终由ActivityThread的performLaunchActivity中实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;  </span><br><span class="line">  // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);  </span><br><span class="line">  </span><br><span class="line">  ActivityInfo aInfo = r.activityInfo;  </span><br><span class="line">  if (r.packageInfo == null) &#123;  </span><br><span class="line">  r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,  </span><br><span class="line">  Context.CONTEXT_INCLUDE_CODE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  ComponentName component = r.intent.getComponent();  </span><br><span class="line">  if (component == null) &#123;  </span><br><span class="line">  component = r.intent.resolveActivity(  </span><br><span class="line">  mInitialApplication.getPackageManager());  </span><br><span class="line">  r.intent.setComponent(component);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  if (r.activityInfo.targetActivity != null) &#123;  </span><br><span class="line">  component = new ComponentName(r.activityInfo.packageName,  </span><br><span class="line">  r.activityInfo.targetActivity);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  Activity activity = null;  </span><br><span class="line">  try &#123;  </span><br><span class="line">  java.lang.ClassLoader cl = r.packageInfo.getClassLoader();  </span><br><span class="line">  activity = mInstrumentation.newActivity(  </span><br><span class="line">  cl, component.getClassName(), r.intent);  </span><br><span class="line">  StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">  r.intent.setExtrasClassLoader(cl);  </span><br><span class="line">  r.intent.prepareToEnterProcess();  </span><br><span class="line">  if (r.state != null) &#123;  </span><br><span class="line">  r.state.setClassLoader(cl);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125; catch (Exception e) &#123;  </span><br><span class="line">  if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line">  throw new RuntimeException(  </span><br><span class="line">  &quot;Unable to instantiate activity &quot; + component  </span><br><span class="line">  + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  try &#123;  </span><br><span class="line">  Application app = r.packageInfo.makeApplication(false, mInstrumentation);  </span><br><span class="line">  </span><br><span class="line">  if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);  </span><br><span class="line">  if (localLOGV) Slog.v(  </span><br><span class="line">  TAG, r + &quot;: app=&quot; + app  </span><br><span class="line">  + &quot;, appName=&quot; + app.getPackageName()  </span><br><span class="line">  + &quot;, pkg=&quot; + r.packageInfo.getPackageName()  </span><br><span class="line">  + &quot;, comp=&quot; + r.intent.getComponent().toShortString()  </span><br><span class="line">  + &quot;, dir=&quot; + r.packageInfo.getAppDir());  </span><br><span class="line">  </span><br><span class="line">  if (activity != null) &#123;  </span><br><span class="line">  Context appContext = createBaseContextForActivity(r, activity);  </span><br><span class="line">  CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());  </span><br><span class="line">  Configuration config = new Configuration(mCompatConfiguration);  </span><br><span class="line">  if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;  </span><br><span class="line">  + r.activityInfo.name + &quot; with config &quot; + config);  </span><br><span class="line">  activity.attach(appContext, this, getInstrumentation(), r.token,  </span><br><span class="line">  r.ident, app, r.intent, r.activityInfo, title, r.parent,  </span><br><span class="line">  r.embeddedID, r.lastNonConfigurationInstances, config,  </span><br><span class="line">  r.referrer, r.voiceInteractor);  </span><br><span class="line">  </span><br><span class="line">  if (customIntent != null) &#123;  </span><br><span class="line">  activity.mIntent = customIntent;  </span><br><span class="line">  &#125;  </span><br><span class="line">  r.lastNonConfigurationInstances = null;  </span><br><span class="line">  activity.mStartedActivity = false;  </span><br><span class="line">  int theme = r.activityInfo.getThemeResource();  </span><br><span class="line">  if (theme != 0) &#123;  </span><br><span class="line">  activity.setTheme(theme);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  activity.mCalled = false;  </span><br><span class="line">  if (r.isPersistable()) &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnCreate(activity, r.state);  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (!activity.mCalled) &#123;  </span><br><span class="line">  throw new SuperNotCalledException(  </span><br><span class="line">  &quot;Activity &quot; + r.intent.getComponent().toShortString() +  </span><br><span class="line">  &quot; did not call through to super.onCreate()&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  r.activity = activity;  </span><br><span class="line">  r.stopped = true;  </span><br><span class="line">  if (!r.activity.mFinished) &#123;  </span><br><span class="line">  activity.performStart();  </span><br><span class="line">  r.stopped = false;  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (!r.activity.mFinished) &#123;  </span><br><span class="line">  if (r.isPersistable()) &#123;  </span><br><span class="line">  if (r.state != null || r.persistentState != null) &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,  </span><br><span class="line">  r.persistentState);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125; else if (r.state != null) &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (!r.activity.mFinished) &#123;  </span><br><span class="line">  activity.mCalled = false;  </span><br><span class="line">  if (r.isPersistable()) &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnPostCreate(activity, r.state,  </span><br><span class="line">  r.persistentState);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">  mInstrumentation.callActivityOnPostCreate(activity, r.state);  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (!activity.mCalled) &#123;  </span><br><span class="line">  throw new SuperNotCalledException(  </span><br><span class="line">  &quot;Activity &quot; + r.intent.getComponent().toShortString() +  </span><br><span class="line">  &quot; did not call through to super.onPostCreate()&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  r.paused = true;  </span><br><span class="line">  </span><br><span class="line">  mActivities.put(r.token, r);  </span><br><span class="line">  </span><br><span class="line">  &#125; catch (SuperNotCalledException e) &#123;  </span><br><span class="line">  throw e;  </span><br><span class="line">  </span><br><span class="line">  &#125; catch (Exception e) &#123;  </span><br><span class="line">  if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line">  throw new RuntimeException(  </span><br><span class="line">  &quot;Unable to start activity &quot; + component  </span><br><span class="line">  + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  return activity;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Activity newActivity(Class&lt;?&gt; clazz, Context context,  </span><br><span class="line">  </span><br><span class="line"> IBinder token, Application application, Intent intent, ActivityInfo info,  </span><br><span class="line">  </span><br><span class="line"> CharSequence title, Activity parent, String id,  </span><br><span class="line"> Object lastNonConfigurationInstance) throws InstantiationException,  </span><br><span class="line">  </span><br><span class="line"> IllegalAccessException &#123;  </span><br><span class="line"> Activity activity = (Activity)clazz.newInstance();  </span><br><span class="line"> ActivityThread aThread = null;  </span><br><span class="line"> activity.attach(context, aThread, this, token, 0, application, intent,  </span><br><span class="line"> info, title, parent, id,  </span><br><span class="line"> (Activity.NonConfigurationInstances)lastNonConfigurationInstance,  </span><br><span class="line"> new Configuration(), null, null);  </span><br><span class="line"> return activity;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Instrumentation中的newActivity最终执行了Activity的实例化创建。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/06/设计模式-单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/设计模式-单例模式/" itemprop="url">
                  设计模式-单例模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-06T09:33:13+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/06/设计模式-单例模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/06/设计模式-单例模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-单利模式的定义及使用场景"><a href="#1-单利模式的定义及使用场景" class="headerlink" title="1.单利模式的定义及使用场景"></a>1.单利模式的定义及使用场景</h1><p>确保某一个类只有一个实例，而且自行示例化并向整个系统提供这个实例。确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象应该有且只有一个。例如创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。<br><img src="http://img.blog.csdn.net/20170106093535299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-单例模式的优缺点"><a href="#2-单例模式的优缺点" class="headerlink" title="2.单例模式的优缺点"></a>2.单例模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ol>
<li>减少内存，特别是一个对象需要频繁地创建、销毁，而且创建或销毁时性能又无法优化</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免同时对一个资源文件的同时写操作</li>
<li>单例模式可以在系统设置全局的访问点，优化和共享资源访问<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2></li>
<li>单例模式一般没有接口，扩展比较困难</li>
<li>单例模式与单一责任原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中<h1 id="3-单例模式的实现方式"><a href="#3-单例模式的实现方式" class="headerlink" title="3.单例模式的实现方式"></a>3.单例模式的实现方式</h1><h2 id="3-1懒汉模式"><a href="#3-1懒汉模式" class="headerlink" title="3.1懒汉模式"></a>3.1懒汉模式</h2></li>
<li><p>最原始的懒汉模式</p>
<p> 优点：懒加载</p>
<p> 缺点：未考虑线程安全</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加锁的懒汉模式</li>
</ol>
<p>优点：懒加载 、线程安全</p>
<p>缺点：效率低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>双重锁懒汉模式</li>
</ol>
<p>优点：懒加载、线程安全</p>
<p>缺点：效率高于2）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">     private volatile static Singleton singleton;  </span><br><span class="line">     private Singleton ()&#123;&#125;  </span><br><span class="line">     public static Singleton getSingleton() &#123;  </span><br><span class="line">     if (singleton == null) &#123;  </span><br><span class="line">         synchronized (Singleton.class) &#123;  </span><br><span class="line">         if (singleton == null) &#123;  </span><br><span class="line">             singleton = new Singleton();  </span><br><span class="line">         &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     return singleton;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>静态内部类</li>
</ol>
<p>优点：懒加载、线程安全</p>
<p>缺点：实现方式比较复杂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">     private static class SingletonHolder &#123;  </span><br><span class="line">     private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">     &#125;  </span><br><span class="line">     private Singleton ()&#123;&#125;  </span><br><span class="line">     public static final Singleton getInstance() &#123;  </span><br><span class="line">     return SingletonHolder.INSTANCE;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2饿汉模式"><a href="#3-2饿汉模式" class="headerlink" title="3.2饿汉模式"></a>3.2饿汉模式</h2><p>优点：非懒加载</p>
<p>缺点：线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">     private Singleton instance = null;  </span><br><span class="line">     static &#123;  </span><br><span class="line">     instance = new Singleton();  </span><br><span class="line">     &#125;  </span><br><span class="line">     private Singleton ()&#123;&#125;  </span><br><span class="line">     public static Singleton getInstance() &#123;  </span><br><span class="line">     return this.instance;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-单例模式在Android中的实际应用"><a href="#4-单例模式在Android中的实际应用" class="headerlink" title="4.单例模式在Android中的实际应用"></a>4.单例模式在Android中的实际应用</h1><p>相信大家对LayoutInflate都不陌生，特别在ListView的Adapter的getView方法中基本都会出现，使用inflate方法去加载一个布局，用于ListView的每个Item的布局。最简单的使用方法是LayoutInflater layoutInflater = LayoutInflater.from(context);  那么Android的源码中是怎么保持LayoutInflater的单例模式呢？分析源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Obtains the LayoutInflater from the given context. </span><br><span class="line"> */  </span><br><span class="line"> public static LayoutInflater from(Context context) &#123;  </span><br><span class="line"> LayoutInflater LayoutInflater =  </span><br><span class="line"> (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);  </span><br><span class="line"> if (LayoutInflater == null) &#123;  </span><br><span class="line"> throw new AssertionError(&quot;LayoutInflater not found.&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> return LayoutInflater;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> Context：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">public final &lt;T&gt; T getSystemService(Class&lt;T&gt; serviceClass) &#123;  </span><br><span class="line">// Because subclasses may override getSystemService(String) we cannot  </span><br><span class="line">// perform a lookup by class alone. We must first map the class to its  </span><br><span class="line">// service name then invoke the stringbased method.  </span><br><span class="line">String serviceName = getSystemServiceName(serviceClass);  </span><br><span class="line">return serviceName != null ? (T)getSystemService(serviceName) : null;  </span><br><span class="line">&#125;  </span><br><span class="line">public abstract String getSystemServiceName(Class&lt;?&gt; serviceClass);</span><br></pre></td></tr></table></figure></p>
<p> ContextImpl：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line"> public String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123;  </span><br><span class="line"> return SystemServiceRegistry.getSystemServiceName(serviceClass);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> SystemServiceRegistry :<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> /** </span><br><span class="line">  * Gets the name of the systemlevel service that is represented by the specified class. </span><br><span class="line">  */  </span><br><span class="line">  public static String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123;  </span><br><span class="line">  return SYSTEM_SERVICE_NAMES.get(serviceClass);  </span><br><span class="line">  &#125;  </span><br><span class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,  </span><br><span class="line">  new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;  </span><br><span class="line">  @Override  </span><br><span class="line">  public LayoutInflater createService(ContextImpl ctx) &#123;  </span><br><span class="line">  return new PhoneLayoutInflater(ctx.getOuterContext());  </span><br><span class="line">  &#125;&#125;);  </span><br><span class="line">  </span><br><span class="line">  /** </span><br><span class="line">  * Statically registers a system service with the context. </span><br><span class="line">  * This method must be called during static initialization only. </span><br><span class="line">  */  </span><br><span class="line">  private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,  </span><br><span class="line">  ServiceFetcher&lt;T&gt; serviceFetcher) &#123;  </span><br><span class="line">  SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);  </span><br><span class="line">  SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;  </span><br><span class="line">  private final int mCacheIndex;  </span><br><span class="line">  </span><br><span class="line">  public CachedServiceFetcher() &#123;  </span><br><span class="line">  mCacheIndex = sServiceCacheSize++;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  @Override  </span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">  public final T getService(ContextImpl ctx) &#123;  </span><br><span class="line">  final Object[] cache = ctx.mServiceCache;  </span><br><span class="line">  synchronized (cache) &#123;  </span><br><span class="line">  // Fetch or create the service.  </span><br><span class="line">  Object service = cache[mCacheIndex];  </span><br><span class="line">  if (service == null) &#123;  </span><br><span class="line">  service = createService(ctx);  </span><br><span class="line">  cache[mCacheIndex] = service;  </span><br><span class="line">  &#125;  </span><br><span class="line">  return (T)service;  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public abstract T createService(ContextImpl ctx);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过源码分析可知，LayoutInflater最终是保存在cache的一个Object数组中，以这种方式进行单例的提供。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/01/03/设计模式-面向对象的六大设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/03/设计模式-面向对象的六大设计原则/" itemprop="url">
                  设计模式-面向对象的六大设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-03T09:39:58+08:00">
                2017-01-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/03/设计模式-面向对象的六大设计原则/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/03/设计模式-面向对象的六大设计原则/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在应用的开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护中让应用系统能够拥抱变化。拥抱变化也就是意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了各版本的变更之后依旧保持清晰、灵活、稳定的系统架构。</p>
<p>虽然在实际的应该开发中，要饱受产品的折磨和摧残、需要在极其有限的研发时间里完成功能、上线。但是我们仍需尽量保持遵循面向对象的六大设计原则，这才能让我们不必在各种需求的苦海中挣扎。</p>
<h2 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1.单一责任原则"></a>1.单一责任原则</h2><ul>
<li>定义：就一个类而言，应该只有一个引起变化的原因。</li>
<li>优点：低耦合</li>
<li>缺点：责任界限比较难划分</li>
<li>总结：在研发当中，设计的规范应尽量满足单一责任原则。接口一定要做到单一责任原则，类的设计尽量做到只有一个引起变化的原因。<h2 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h2></li>
<li>定义： 所有引用父类的地方，必要能透明的使用其子类</li>
<li>优点：低耦合，高内聚，增强程序的健壮性。版本升级时，只需新增对应的实现子类，不必影响旧的业务逻辑</li>
<li>缺点： 继承是侵入性的，子类必须拥有分类的所有属性和方法，同时可能造成子类代码冗余、灵活性降低</li>
<li>总结： 在项目中，采用里氏替换原则，应尽量避免子类的个性（拥有自己的业务实现方法），把子类当父类使用，个性无法使用，单独作为一个业务，耦合关系复杂<h2 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3.依赖倒置原则"></a>3.依赖倒置原则</h2></li>
<li>定义： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</li>
<li>优点： 减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和维护性</li>
<li>缺点： 前期需要耗时进行结构设计及抽象提取</li>
<li>总结： 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。在实践中可以根据以下几个规则来衡量：</li>
</ul>
<ol>
<li>每个类尽量都有接口或抽象类，或者抽象类和两者都具备</li>
<li>任何类尽量都不应该从具体的类派生</li>
<li>结合里氏替换原则</li>
<li>接口隔离原则</li>
</ol>
<ul>
<li>定义： 客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上</li>
<li>优点： 接口隔离的原则将非常庞大、臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署<br>缺点： 需要耗时统筹接口隔离颗粒度，接口拆分的标准、颗粒度比较难划分，太大降低灵活性，太小，导致接口数据增大，开发成本更高<br>总结： 接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口和原子类来组织。在实践中可以根据以下几个规则来衡量：</li>
</ul>
<ol>
<li>一个接口只服务于一个子模块或业务逻辑</li>
<li>通过业务逻辑压缩接口中的public方法，尽量让接口精简，而不是暴露一大堆方法</li>
<li>已被污染的接口，尽量去修改，若变更风险较大，则采用设配器模式进行转换处理</li>
<li>根据业务，每个项目或产品都有特定的环境因素，拆分的标准可能不同，不要硬套标准<h2 id="5-迪米特原则"><a href="#5-迪米特原则" class="headerlink" title="5.迪米特原则"></a>5.迪米特原则</h2></li>
</ol>
<ul>
<li>定义： 一个对象应该对自己需要耦合或调用的类知道最少，尽量不要对外公布太多的public方法和非静态的public变量</li>
<li>优点： 迪米特法则的核心观念就是类间解耦，提高类的复用率</li>
<li>缺点： 可能产生大量的中转或者跳转类，导致系统的复杂性提高</li>
<li>总结： 迪米特法则是要求类间解耦，但解耦是有限度。在实际的项目中，要适度的参考运用，严格执行就是“过犹不及”<h2 id="6-开放封闭原则"><a href="#6-开放封闭原则" class="headerlink" title="6.开放封闭原则"></a>6.开放封闭原则</h2></li>
<li>定义：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。</li>
<li>优点：</li>
</ul>
<ol>
<li>避免修改代码，影响已经通过单元测试等原业务逻辑</li>
<li>可以提高复用性、可维护性</li>
</ol>
<ul>
<li>缺点： 需要预知变化，全局统筹。</li>
<li>总结： 在将开闭原则运行到实际的项目中需注意:</li>
</ul>
<ol>
<li>抽象约束，通过接口或者抽象类约束扩展，对扩展进行边界开放。</li>
<li>元数据控制模块行为，通过配置参数（文件，数据库），减少重复开发</li>
<li>制定项目章程</li>
<li>封装变化，第一将相同的变化封装到同一个接口或者抽象类中；第二将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/24/排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/24/排序算法总结/" itemprop="url">
                  排序算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-24T15:19:06+08:00">
                2016-12-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/24/排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/24/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-排序算法分类"><a href="#1-排序算法分类" class="headerlink" title="1.排序算法分类"></a>1.排序算法分类</h1><p>基础的排序算法包含冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序及快速排序。<br>根据实现类型可分为插入排序类、选择排序类、交换排序类及归并排序类。</p>
<p><img src="http://img.blog.csdn.net/20161224151916566?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h1 id="2-排序算法的综合分析"><a href="#2-排序算法的综合分析" class="headerlink" title="2.排序算法的综合分析"></a>2.排序算法的综合分析</h1><p>各算法的排序方式、平均情况、最好最坏情况、所需的辅助空间及稳定性如下：<br><img src="http://img.blog.csdn.net/20161224151927488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>事实上，排序算法没有十全十美，本来想写一套模拟测试的数据来验证孰优孰略。但是突然发现可比性不高，需要根据排序源的情况，选择合适的排序算法。<br>从平均情况来看，显然最后3种改进的算法要优于希尔排序及其他3种简单的排序算法<br>从最坏情况来看，堆排序与归并排序又强过快速排序及其他简单排序<br>从辅助空间来看，简单排序算法及堆排序算法最优<br>从稳定性来看，改进的排序算法只有归并排序最稳定<br>选择怎样的排序算法需要根据各项指标来综合考虑，从待排序的个数上来说，待排序的个数n越小，采用简单排序的方法越合适，反之n越大，采用改进排序方法越合适，例如当关键字本身信息量很大，暂用存储空间大，移动比较花费时间，此时简单排序算法比较有优势。当然如果需要考虑算法的稳定性，显然改进的算法中只有归并排序合适。当然如果一定要说那个排序算法比较好，从综合的情况来说，改进的排序算法显然更优。</p>
<h1 id="3-JDK1-7中的排序算法"><a href="#3-JDK1-7中的排序算法" class="headerlink" title="3.JDK1.7中的排序算法"></a>3.JDK1.7中的排序算法</h1><p>java的程序员都知道我们对排序经常使用Collections.sort()或者Arrays.sort(),当然Collections.sort(）最后也是调用了Arrays.sort(),如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;  </span><br><span class="line"> Object[] a = list.toArray();  </span><br><span class="line"> Arrays.sort(a);  </span><br><span class="line"> ListIterator&lt;T&gt; i = list.listIterator();  </span><br><span class="line"> for (int j=0; j&lt;a.length; j++) &#123;  </span><br><span class="line"> i.next();  </span><br><span class="line"> i.set((T)a[j]);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>那个Arrays.sort()，到底使用什么排序的算法呢？<br>分析源码得知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] a) &#123;  </span><br><span class="line">  DualPivotQuicksort.sort(a);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>DualPivotQuicksort是一种在快速排序（单轴）上优化的排序算法，是一种双轴快排。该算法的实现印证了第2点中的描述，算法的选择根据了数据源的情况进行实现。DualPivotQuicksort的实现包含组合了 TimSort（ 是一个归并排序做了大量优化的版本）、插入排序、单轴快速排序等。</p>
<p>有兴趣的深入了解DualPivotQuicksort的具体实现参考：<br><a href="http://www.tuicool.com/articles/BfY7Nz" target="_blank" rel="noopener">http://www.tuicool.com/articles/BfY7Nz</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/24/排序算法-快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/24/排序算法-快速排序/" itemprop="url">
                  排序算法-快速排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-24T11:26:51+08:00">
                2016-12-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/24/排序算法-快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/24/排序算法-快速排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>快速排序（Quick Sort）</strong><br>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小， 则可分别对这部分记录继续进行排序，以达到整个序列有序的目的</p>
<p>最好情况o(logn)</p>
<p>最坏情况o(n²)</p>
<p>排序稳定，但需要额外的辅助空间</p>
<p><img src="http://img.blog.csdn.net/20161224113321667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void quickSort(int[] array, int low, int high) &#123;  </span><br><span class="line">  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           if (low &gt;= high)  </span><br><span class="line">               return;  </span><br><span class="line">           // 找出中间索引  </span><br><span class="line">           int pivot = partition(array, low, high);  </span><br><span class="line">           System.out.println(&quot;low right:&quot; + low + &quot;  &quot; + high);  </span><br><span class="line">           System.out.println(pivot + &quot;array result:&quot; + Arrays.toString(array));  </span><br><span class="line">           // 对低子表递归排序  </span><br><span class="line">           quickSort(array, low, pivot - 1);  </span><br><span class="line">           // 对高子表递归排序  </span><br><span class="line">           quickSort(array, pivot + 1, high);  </span><br><span class="line">  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">     * 交换顺序表中子表的记录，使枢轴记录到位，并返回其所在位置 </span><br><span class="line">     * 此时在他之前（后）的记录均不打（小）于它 </span><br><span class="line">     */  </span><br><span class="line">    static int partition(int[] array, int low, int height) &#123;  </span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">            int pivotkey;  </span><br><span class="line">            pivotkey = array[low];  </span><br><span class="line">            while (low &lt; height) &#123;  </span><br><span class="line">                while (low &lt; height &amp;&amp; array[height] &gt;= pivotkey) &#123;  </span><br><span class="line">                    height--;  </span><br><span class="line">                &#125;  </span><br><span class="line">                swap(array, low, height);//将比根轴记录小的记录交换到低端  </span><br><span class="line">                while (low &lt; height &amp;&amp; array[low] &lt;= pivotkey) &#123;  </span><br><span class="line">                    low++;  </span><br><span class="line">                &#125;  </span><br><span class="line">                swap(array, low, height);//将比轴记录大的记录交换到高端  </span><br><span class="line">            &#125;  </span><br><span class="line">            return low;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    * 将数组的2个位置交换 </span><br><span class="line">    */  </span><br><span class="line">   static void swap(int[] array, int i, int j) &#123;  </span><br><span class="line">       if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">           if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt;= array.length &amp;&amp; j &lt;= array.length) &#123;  </span><br><span class="line">               int temp = array[i];  </span><br><span class="line">               array[i] = array[j];  </span><br><span class="line">               array[j] = temp;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>快速排序优化</p>
<p>递归对性能有一定的影响。栈的大小事很有限的，每次递归调用都会消耗一定的栈空间， 函数的参数越多，每次递归消耗的空间也越多。实现尾递归优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void quickSort2(int[] array, int low, int high) &#123;  </span><br><span class="line">  </span><br><span class="line">     if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">         int pivot;  </span><br><span class="line">         while (low &lt; high) &#123;  </span><br><span class="line">             // 找出中间索引  </span><br><span class="line">             pivot = partition2(array, low, high);  </span><br><span class="line">             System.out.println(&quot;low right:&quot; + low + &quot;  &quot; + high);  </span><br><span class="line">             System.out.println(pivot + &quot;array result:&quot; + Arrays.toString(array));  </span><br><span class="line">             // 对低子表递归排序  </span><br><span class="line">             quickSort2(array, low, pivot - 1);  </span><br><span class="line">             // 尾递归  </span><br><span class="line">             low = pivot + 1;  </span><br><span class="line">  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>优化选取枢轴（三数取中）<br>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int partition2(int[] array, int low, int height) &#123;  </span><br><span class="line">      if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">          int pivotkey;  </span><br><span class="line">          int m=low+(height-low)/2;//计算数组中间的元素下标  </span><br><span class="line">          if(array[low]&gt;array[height])&#123;  </span><br><span class="line">              swap(array,low,height);//保证左端最小  </span><br><span class="line">          &#125;  </span><br><span class="line">          if(array[m]&gt;array[height])&#123;  </span><br><span class="line">              swap(array,m,height);//保证中间最小  </span><br><span class="line">          &#125;  </span><br><span class="line">          if(array[m]&gt;array[low])&#123;  </span><br><span class="line">              swap(array,m,low);//保证中间最小  </span><br><span class="line">          &#125;  </span><br><span class="line">          pivotkey = array[low];  </span><br><span class="line">          while (low &lt; height) &#123;  </span><br><span class="line">              while (low &lt; height &amp;&amp; array[height] &gt;= pivotkey) &#123;  </span><br><span class="line">                  height--;  </span><br><span class="line">              &#125;  </span><br><span class="line">              swap(array, low, height);//将比根轴记录小的记录交换到低端  </span><br><span class="line">              while (low &lt; height &amp;&amp; array[low] &lt;= pivotkey) &#123;  </span><br><span class="line">                  low++;  </span><br><span class="line">              &#125;  </span><br><span class="line">              swap(array, low, height);//将比轴记录大的记录交换到高端  </span><br><span class="line">          &#125;  </span><br><span class="line">          return low;  </span><br><span class="line">      &#125;  </span><br><span class="line">      return 0;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2016/12/16/排序算法-归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/16/排序算法-归并排序/" itemprop="url">
                  排序算法-归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-16T17:36:41+08:00">
                2016-12-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/16/排序算法-归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/16/排序算法-归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>归并排序（Merging Sort）</strong><br>利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列然后反复进行两两归并，直到得到一个长度为n的有序序列为止。</p>
<p>时间复杂度</p>
<p>最好情况o(nlogn)</p>
<p>最坏情况o(nlogn)</p>
<p>排序稳定，但需要额外的辅助空间</p>
<h2 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1.递归实现"></a>1.递归实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void partSort(int[] array, int left, int right) &#123;  </span><br><span class="line">  </span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">            if (left &gt;= right)  </span><br><span class="line">                return;  </span><br><span class="line">            // 找出中间索引  </span><br><span class="line">            int center = (left + right) / 2;  </span><br><span class="line">            // 对左边数组进行递归  </span><br><span class="line">            partSort(array, left, center);  </span><br><span class="line">            // 对右边数组进行递归  </span><br><span class="line">            partSort(array, center + 1, right);  </span><br><span class="line">            //合并  </span><br><span class="line">            megre(array, left, center, right);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 将左右两边有序的数据进行合并 </span><br><span class="line"> */  </span><br><span class="line">static void megre(int[] array, int left, int center, int right) &#123;  </span><br><span class="line">    if (array != null &amp;&amp; array.length &gt; 0) &#123;  </span><br><span class="line">        // 临时数组  </span><br><span class="line">        int[] tmpArray = new int[array.length];  </span><br><span class="line">        // 右数组第一个元素索引  </span><br><span class="line">        int mid = center + 1;  </span><br><span class="line">        // tag 记录临时数组的索引  </span><br><span class="line">        int tag = left;  </span><br><span class="line">        // 缓存左数组第一个元素的索引  </span><br><span class="line">        int tmp = left;  </span><br><span class="line">        while (left &lt;= center &amp;&amp; mid &lt;= right) &#123;  </span><br><span class="line">            // 从两个数组中取出最小的放入临时数组  </span><br><span class="line">            if (array[left] &lt;= array[mid]) &#123;  </span><br><span class="line">                tmpArray[tag++] = array[left++];  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                tmpArray[tag++] = array[mid++];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）  </span><br><span class="line">        while (mid &lt;= right) &#123;  </span><br><span class="line">            tmpArray[tag++] = array[mid++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (left &lt;= center) &#123;  </span><br><span class="line">            tmpArray[tag++] = array[left++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 将临时数组中的内容拷贝回原数组中  </span><br><span class="line">        // （原left-right范围的内容被复制回原数组）  </span><br><span class="line">        while (tmp &lt;= right) &#123;  </span><br><span class="line">            array[tmp] = tmpArray[tmp++];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2.非递归实现"></a>2.非递归实现</h2><p>非递归思想: 将数组中的相邻元素两两配对。用merge函数将他们排序，构成n/2组长度为2的排序好的子数组段，然后再将他们排序成长度为4的子数组段，如此继续下去，直至整个数组排好序。性能由于递归实现</p>
<pre><code>static void megeringSort(int[] array) {  
     int len = 1;  
     //程序边界的处理非常重要  
     while (len &lt;= array.length) {  
         for (int i = 0; i + len &lt;= array.length - 1; i += len * 2) {//len 1 2 4 8... ...  
             int low = i, mid = i + len - 1, high = i + len * 2 - 1; //计算每次区间的左中右索引  
             if (high &gt; array.length - 1) high = array.length - 1;  
             megre(array, i, mid, high);//执行合并  
         }  
         len *= 2;  
     }  

 }  
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">82</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
