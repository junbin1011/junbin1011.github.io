<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="优秀是一种习惯，坚持是一种品质。">
<meta property="og:type" content="website">
<meta property="og:title" content="黄俊彬个人博客">
<meta property="og:url" content="https://junbin1011.github.io/page/4/index.html">
<meta property="og:site_name" content="黄俊彬个人博客">
<meta property="og:description" content="优秀是一种习惯，坚持是一种品质。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄俊彬个人博客">
<meta name="twitter:description" content="优秀是一种习惯，坚持是一种品质。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/4/"/>





  <title> 黄俊彬个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄俊彬个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">优秀是一种习惯，坚持是一种品质。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/22/Android性能优化-内存泄漏（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/22/Android性能优化-内存泄漏（下）/" itemprop="url">
                  Android性能优化-内存泄漏（下）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T10:29:02+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/22/Android性能优化-内存泄漏（下）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/22/Android性能优化-内存泄漏（下）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何进行内存泄漏的分析"><a href="#如何进行内存泄漏的分析" class="headerlink" title="如何进行内存泄漏的分析"></a>如何进行内存泄漏的分析</h1><h2 id="使用Android-Studio-Monitors"><a href="#使用Android-Studio-Monitors" class="headerlink" title="使用Android Studio  Monitors"></a>使用Android Studio  Monitors</h2><p>AndroidMonitors是Android Studio自带的功能，我们可以通过里面的Memory模块来进行内存泄漏的分析，平时开发我们也可以通过该模块来观察内存的抖动情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-16714b3ef941e1b6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里我们首先知道，标注1是进行GC的操作，标注2是进行Dump操作，也就是可以生成我们瞬时的堆内存快照，我们主要也是通过分析堆内存的快照来进行内存泄漏分析。<br>一般我们先进行几次gc操作，待内存平稳后，执行dump操作。会生成一个phrof的内存快照</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB0621ed808d662b530f710a7b94838ed4?method=download&amp;shareKey=25da5526e52b0833c0b282887d70aeec" alt=""></p>
<p>此时我们可以看到几个面板：</p>
<ol>
<li>ClassName：堆内存中存在的类</li>
<li>Instaance：类存在的实例</li>
<li>ReferenceTree：持有该类的引用</li>
</ol>
<p>几个属性的含义：</p>
<ol>
<li>Depth:引用的层级</li>
<li>Shallow Size:对象的大小（Byte）</li>
<li>Dominating Size:释放该对象能节省的堆内存（Byte）</li>
</ol>
<p>将快照转换为Mat能够导入的格式<br>在as的captures中可以右键选择export to standard  .hprof 将快照转换为mat能够带入的文件格式</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6e9e7d2b51e0d4ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="使用MAT"><a href="#使用MAT" class="headerlink" title="使用MAT"></a>使用MAT</h2><p>MAT是一款功能更强大的内存泄漏分析工具，在实际的内存分析中，我们可以结合Monitors进行内存泄漏分析。</p>
<p><a href="http://www.eclipse.org/mat/" target="_blank" rel="external">下载地址http://www.eclipse.org/mat/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-8ba2a74943e4efaa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>导入快照后，我们可以通过Histogram查看内存快照<br><img src="http://note.youdao.com/yws/api/personal/file/WEB8211d428e66bc581253f74e28ee78f78?method=download&amp;shareKey=7b8c7db3758507fb6f409e66aba03f23" alt=""></p>
<p>在Histogram中，我们可以通过筛选过滤出我们项目中的包和类，这个操作实际中很有用。</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB12eff1828f48890b194fdec8b247ff20?method=download&amp;shareKey=f417238f179bd1c6621097f153512d5d" alt=""></p>
<p>选中具体的对象后，右键list objects–with incoming references可以查看对改对象持有的应用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-a1edb426316f38ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们可以看到，这个时候引用还是非常的，我们需要过滤一些无用的软引用之类的。通过右键-megre shortest path to GC roots-exclude all phantom/sofe/weak etc.refrences进行过滤,这个时候基本就能查出我们自己写的代码的引用</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB613af7e59acfc2bbc08ca85504030f81?method=download&amp;shareKey=c60166a7574820f768b041b480bb98e9" alt=""></p>
<p>另外Mat还支持2个快照进行比对，这个功能也是非常有用的。<br>我们可以在Navigation History中选择 Histogram，然后右键选择Add to compare basket加入比较选项，将2个快照的Histogram加入后在compare basket栏中点击红色感叹号就可以执行快照的比对。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5ab78b29c0689fdc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="使用leakcanary"><a href="#使用leakcanary" class="headerlink" title="使用leakcanary"></a>使用leakcanary</h2><p>Square开源了一个内存泄露自动探测神器——LeakCanary，它是一个Android和Java的内存泄露检测库，可以大幅度减少了开发中遇到的OOM问题。</p>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="external">github https://github.com/square/leakcanary</a></p>
<p>通过官方的文档介绍，我们可以轻松在项目集成</p>
<p>加入依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos;</div><div class="line">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</div><div class="line">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Application 配置:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ExampleApplication extends Application &#123;</div><div class="line"></div><div class="line">  ......</div><div class="line">  //在自己的Application中添加如下代码</div><div class="line">public static RefWatcher getRefWatcher(Context context) &#123;</div><div class="line">    ExampleApplication application = (ExampleApplication) context</div><div class="line">            .getApplicationContext();</div><div class="line">    return application.refWatcher;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  //在自己的Application中添加如下代码</div><div class="line">private RefWatcher refWatcher;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    ......</div><div class="line">        //在自己的Application中添加如下代码</div><div class="line">    refWatcher = LeakCanary.install(this);</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 RefWatcher 监控那些本该被回收的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseFragment extends Fragment &#123;</div><div class="line"></div><div class="line">  @Override public void onDestroy() &#123;</div><div class="line">    super.onDestroy();</div><div class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</div><div class="line">    refWatcher.watch(this);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 最后如果有内存泄漏，会接收到相应的推送。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-8884ec7e4a009422?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样我们就能在编码的阶段，尽量的避免出现内存泄漏的情况。</p>
<h2 id="如何对自己的项目进行内存泄漏分析"><a href="#如何对自己的项目进行内存泄漏分析" class="headerlink" title="如何对自己的项目进行内存泄漏分析"></a>如何对自己的项目进行内存泄漏分析</h2><p>上面说了这么多，怎么来对我们自己的项目进行内存泄漏的分析呢？</p>
<p>一般我们都是在不知道项目中那里有存在内存泄漏的情况下，怎么来查找出那个地方出现了内存泄漏？</p>
<p>这里我们主要检查Activity及Fragment的内存泄漏情况。</p>
<p>使用Memory Usage查看Activity及Fragment的内存泄漏情况，首先先运行自己项目到MainActivity，观察 Menory Usage。</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB7ec616be1982e225160c263823001c54?method=download&amp;shareKey=c90694f64906445c1d63fbc13114072b" alt=""></p>
<p>待gc内存稳定后，我们可以执行一些操作，如进入其他的Activity执行其他操作，然后 检测内存的抖动情况及gc稳定后，内存与初始内存的对比。</p>
<p>这里我使用开启不保留活动来模拟MainActivity的异常退出及恢复。继续看Menory Usage。<br><img src="http://note.youdao.com/yws/api/personal/file/WEB774b02e733d81a05f918c4ee11a34dbd?method=download&amp;shareKey=624484855f442464e7e67299fb762225" alt=""><br>这个时候，我只有在MainActivity出现过， 理论上应当只有一个MainActivity的实例，这个地方就是一个值得怀疑的内存泄漏的点。这个时候我们就可以通过Mioniter和Mat进行内存分析</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-34e698b3baf98a80?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个时候我们可以看到引用的的可怀疑对象，接着我们就进入源码分析。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-1f1856e3fc019bb2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>果然这里有一个单例持有了MainActivity的使用。</p>
<p>分析内存泄漏是一个体力活，我们大概在项目中主要要记住。</p>
<ol>
<li><p>使用leakcanary 在编码阶段进行检测</p>
</li>
<li><p>结合内存抖动及Memory Usage 检查Activity及Fragment的的泄漏情况</p>
</li>
<li><p>使用Monitor及Mat进行引用持有分析找出怀疑的对象</p>
</li>
<li><p>分析源代码，找到元凶</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/22/Android性能优化-内存泄漏（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/22/Android性能优化-内存泄漏（上）/" itemprop="url">
                  Android性能优化-内存泄漏（上）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T10:28:54+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/22/Android性能优化-内存泄漏（上）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/22/Android性能优化-内存泄漏（上）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要做性能优化？"><a href="#为什么要做性能优化？" class="headerlink" title="为什么要做性能优化？"></a>为什么要做性能优化？</h1><ol>
<li><p>手机性能越来越好，不用纠结这些细微的性能？</p>
<ul>
<li><p>Android每一个应用都是运行的独立的Dalivk虚拟机，根据不同的手机分配的可用内存可能只有（32M、64M等），所谓的4GB、6GB运行内存其实对于我们的应用不是可以任意索取</p>
</li>
<li><p>优秀的算法与效率低下的算法之间的运行效率要远远超过计算机硬件的的发展，虽然手机单核、双核到4核、8核的发展，但性能优化任然不可忽略</p>
</li>
</ul>
</li>
<li><p>手机应用一般使用的周期比较短，用完就关了。不像服务器应用要长年累月运行，似乎影响不大？</p>
<ul>
<li>现在一般的用户都不会重启手机，可能一个月都不会重启。像微信这样的APP，每天都在使用。如果一旦发生内存泄漏，那么可能一点一点的累积，程序就会出现OOM。</li>
</ul>
</li>
<li><p>等应用出现卡顿、发烫等，再来关注性能优化？</p>
<ul>
<li>似乎是没错的。现在一般我们也都是等出现问题了再来找原因。但是学好性能优化的目的不仅仅如此，我们在编码阶段就应该从源头来杜绝一些坑，这样的成本比后期再来寻找原因要少得多</li>
</ul>
<p>所以为了我们的应用的健壮性、有良好的用户体验。性能优化技术，需要我们用心去研究和应用。</p>
</li>
</ol>
<h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><h2 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-27e80eb1c5c73953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Java采用GC进行内存管理。深入的JVM内存管理知识，推荐《深入理解Java虚拟机》。关于内存泄漏我们要知道，JVM内存分配的几种策略。</p>
<ol>
<li><p>静态的</p>
<p> 静态的存储区，内存在程序编译的时候就已经分配好了，这块内存在程序整个运行期间都一直存在，它主要存放静态数据、全局的static数据和一些常量。</p>
</li>
<li><p>栈式的</p>
<p> 在执行方法时，方法一些内部变量的存储都可以放在栈上面创建，方法执行结束的时候这些存储单元就会自动被注释掉。栈 内存包括分配的运算速度很快，因为内在在处理器里面。当然容量有限，并且栈式一块连续的内存区域，大小是由操作系统决定的，他先进后 出，进出完成不会产生碎片，运行效率高且稳定</p>
</li>
<li><p>堆式的</p>
<p> 也叫动态内存 。我们通常使用new 来申请分配一个内存。这里也是我们讨论内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。堆内存是一块不连续的内存区域，如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能</p>
</li>
</ol>
<p>我们知道可以调用 System.gc();进行内存回收，但是GC不一定会执行。面对GC的机制，我们是否无能为力？其实我们可以通过声明一些引用标记来让GC更好对内存进行回收。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>回收时机</th>
<th>生命周期</th>
</tr>
</thead>
<tbody>
<tr>
<td>StrongReference （强引用）</td>
<td>任何时候GC是不能回收他的，哪怕内存不足时，系统会直接抛出异常OutOfMemoryError，也不会去回收</td>
<td>进程终止</td>
</tr>
<tr>
<td>SoftReference （软引用）</td>
<td>当内存足够时不会回收这种引用类型的对象，只有当内存不够用时才会回收</td>
<td>内存不足，进行GC的时候</td>
</tr>
<tr>
<td>WeakReference （弱引用）</td>
<td>GC一运行就会把给回收了</td>
<td>GC后终止</td>
</tr>
<tr>
<td>PhantomReference  (虚引用)</td>
<td>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收</td>
<td>任何时候都有可能</td>
</tr>
</tbody>
</table>
<p>开发时，为了防止内存溢出，处理一些比较占用内存并且生命周期长的对象时，可以尽量使用软引用和弱引用。</p>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<p>成员变量全部存储在堆中（包括基本数据类型，引用及引用的对象实体），因为他们属于类，类对象最终还是要被new出来的</p>
<p>局部变量的基本数据类型和引用存在栈中，应用的对象实体存储在堆中。因为它们属于方法当中的变量，生命周期会随着方法一起结束</p>
</blockquote>
<h2 id="内存泄漏的定义"><a href="#内存泄漏的定义" class="headerlink" title="内存泄漏的定义"></a>内存泄漏的定义</h2><p>当一个对象已经不需要使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用，从而导致了对象不能被GC回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏</p>
<h2 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h2><ul>
<li><p>内存泄漏（Memory Leak）<br>  进程中某些对象已经没有使用的价值了，但是他们却还可以直接或间接地被引用到GC Root导致无法回收。当内存泄漏过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM</p>
</li>
<li><p>内存溢出（OOM）<br>  当 应用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出</p>
</li>
</ul>
<h2 id="内存泄漏带来的影响"><a href="#内存泄漏带来的影响" class="headerlink" title="内存泄漏带来的影响"></a>内存泄漏带来的影响</h2><ul>
<li><p>应用卡顿<br>  泄漏的内存影响了GC的内存分配，过多的内存泄漏会影响应用的执行效率    </p>
</li>
<li><p>应用异常（OOM）<br>  过多的内存泄漏，最终会导致 Dalvik分配的内存，出现OOM</p>
</li>
</ul>
<h1 id="Android开发常见的内存泄漏"><a href="#Android开发常见的内存泄漏" class="headerlink" title="Android开发常见的内存泄漏"></a>Android开发常见的内存泄漏</h1><h2 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h2><ol>
<li>错误示例</li>
<li><p>当调用getInstance时，如果传入的context是Activity的context。只要这个单例没有被释放，那么这个<br>Activity也不会被释放一直到进程退出才会释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CommUtil &#123;</div><div class="line">    private static CommUtil instance;</div><div class="line">    private Context context;</div><div class="line">    private CommUtil(Context context)&#123;</div><div class="line">	this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static CommUtil getInstance(Context mcontext)&#123;</div><div class="line">	if(instance == null)&#123;</div><div class="line">	    instance = new CommUtil(mcontext);</div><div class="line">	&#125;</div><div class="line">	return instance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解决方案</p>
<p>能使用Application的Context就不要使用Activity的Content，Application的生命周期伴随着整个进程的周期</p>
<h2 id="非静态内部类创建静态实例造成的内存泄漏"><a href="#非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="非静态内部类创建静态实例造成的内存泄漏"></a>非静态内部类创建静态实例造成的内存泄漏</h2></li>
<li><p>错误示例</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static TestResource mResource = null;</div><div class="line">   @Override</div><div class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">       super.onCreate(savedInstanceState);</div><div class="line">       setContentView(R.layout.activity_main);</div><div class="line">       if(mManager == null)&#123;</div><div class="line">           mManager = new TestResource();</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">   &#125;</div><div class="line">   class TestResource &#123;</div><div class="line">      </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>解决方案</li>
</ol>
<p>将非静态内部类修改为静态内部类。（静态内部类不会隐式持有外部类）</p>
<h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private MyHandler mHandler = new MyHandler(this);</div><div class="line">   private TextView mTextView ;</div><div class="line">   private static class MyHandler extends Handler &#123;</div><div class="line">       private WeakReference&lt;Context&gt; reference;</div><div class="line">       public MyHandler(Context context) &#123;</div><div class="line">           reference = new WeakReference&lt;&gt;(context);</div><div class="line">       &#125;</div><div class="line">       @Override</div><div class="line">       public void handleMessage(Message msg) &#123;</div><div class="line">           MainActivity activity = (MainActivity) reference.get();</div><div class="line">           if(activity != null)&#123;</div><div class="line">               activity.mTextView.setText(&quot;&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">       super.onCreate(savedInstanceState);</div><div class="line">       setContentView(R.layout.activity_main);</div><div class="line">       mTextView = (TextView)findViewById(R.id.textview);</div><div class="line">       loadData();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadData() &#123;</div><div class="line"></div><div class="line">       Message message = Message.obtain();</div><div class="line">       mHandler.sendMessage(message);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>解决方案</li>
</ol>
<p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">   private MyHandler mHandler = new MyHandler(this);</div><div class="line">    private TextView mTextView ;</div><div class="line">    private static class MyHandler extends Handler &#123;</div><div class="line">        private WeakReference&lt;Context&gt; reference;</div><div class="line">        public MyHandler(Context context) &#123;</div><div class="line">            reference = new WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            MainActivity activity = (MainActivity) reference.get();</div><div class="line">            if(activity != null)&#123;</div><div class="line">                activity.mTextView.setText(&quot;&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mTextView = (TextView)findViewById(R.id.textview);</div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private void loadData() &#123;</div><div class="line">        //...request</div><div class="line">        Message message = Message.obtain();</div><div class="line">        mHandler.sendMessage(message);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        mHandler.removeCallbacksAndMessages(null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程造成的内存泄漏"><a href="#线程造成的内存泄漏" class="headerlink" title="线程造成的内存泄漏"></a>线程造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">new AsyncTask&lt;Void, Void, Void&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    protected Void doInBackground(Void... params) &#123;</div><div class="line">        SystemClock.sleep(10000);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;.execute();</div><div class="line"></div><div class="line"></div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        SystemClock.sleep(10000);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<ol>
<li>解决方案</li>
</ol>
<p>使用 静态内部类，避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123;</div><div class="line">        private WeakReference&lt;Context&gt; weakReference;</div><div class="line"> </div><div class="line">        public MyAsyncTask(Context context) &#123;</div><div class="line">            weakReference = new WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        protected Void doInBackground(Void... params) &#123;</div><div class="line">            SystemClock.sleep(10000);</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        protected void onPostExecute(Void aVoid) &#123;</div><div class="line">            super.onPostExecute(aVoid);</div><div class="line">            MainActivity activity = (MainActivity) weakReference.get();</div><div class="line">            if (activity != null) &#123;</div><div class="line">                //...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    static class MyRunnable implements Runnable&#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            SystemClock.sleep(10000);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//——————</div><div class="line">    new Thread(new MyRunnable()).start();</div><div class="line">    new MyAsyncTask(this).execute();</div></pre></td></tr></table></figure>
<h2 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</p>
<ol>
<li>解决方案</li>
</ol>
<p>在Activity销毁时及时关闭或者注销</p>
<h2 id="使用了静态的Activity和View"><a href="#使用了静态的Activity和View" class="headerlink" title="使用了静态的Activity和View"></a>使用了静态的Activity和View</h2><ol>
<li>错误示例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static view; </div><div class="line"> </div><div class="line">    void setStaticView() &#123; </div><div class="line">      view = findViewById(R.id.sv_button); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    View svButton = findViewById(R.id.sv_button); </div><div class="line">    svButton.setOnClickListener(new View.OnClickListener() &#123; </div><div class="line">      @Override public void onClick(View v) &#123; </div><div class="line">        setStaticView(); </div><div class="line">        nextActivity(); </div><div class="line">      &#125; </div><div class="line">    &#125;); </div><div class="line">    </div><div class="line">    </div><div class="line">    static Activity activity; </div><div class="line"> </div><div class="line">    void setStaticActivity() &#123; </div><div class="line">      activity = this; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    View saButton = findViewById(R.id.sa_button); </div><div class="line">    saButton.setOnClickListener(new View.OnClickListener() &#123; </div><div class="line">      @Override public void onClick(View v) &#123; </div><div class="line">        setStaticActivity(); </div><div class="line">        nextActivity(); </div><div class="line">      &#125; </div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ol>
<li><p>解决方案</p>
<p>应该及时将静态的应用 置为null，而且一般不建议将View及Activity设置为静态</p>
</li>
</ol>
<h2 id="注册了系统的服务，但onDestory未注销"><a href="#注册了系统的服务，但onDestory未注销" class="headerlink" title="注册了系统的服务，但onDestory未注销"></a>注册了系统的服务，但onDestory未注销</h2><ol>
<li>错误示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE);</div><div class="line">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</div><div class="line"> sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//不需要用的时候记得移除监听</div><div class="line">     sensorManager.unregisterListener(listener);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="不需要用的监听未移除会发生内存泄露"><a href="#不需要用的监听未移除会发生内存泄露" class="headerlink" title="不需要用的监听未移除会发生内存泄露"></a>不需要用的监听未移除会发生内存泄露</h2><ol>
<li><p>错误示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//add监听，放到集合里面</div><div class="line">        tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onWindowFocusChanged(boolean b) &#123;</div><div class="line">                //监听view的加载，view加载出来的时候，计算他的宽高等。</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//计算完后，一定要移除这个监听</div><div class="line">             tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<p> tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏<br>tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏</p>
</blockquote>
<h1 id="下一篇将介绍如何进行内存泄漏的分析"><a href="#下一篇将介绍如何进行内存泄漏的分析" class="headerlink" title="下一篇将介绍如何进行内存泄漏的分析"></a>下一篇将介绍如何进行内存泄漏的分析</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/09/2017小年的小目标/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/2017小年的小目标/" itemprop="url">
                  2017小年的小目标
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T14:19:18+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/09/2017小年的小目标/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/09/2017小年的小目标/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2016年辞去了在研究院轻松的工作，来到了东莞，加入了新的公司。这一年，总体来说进步还是蛮大，主要一个是思想觉悟的提升，怎么说呢？作为一个程序员，经历过外包公司，一年10几个项目的折磨，也从事过自由软件开发者，也在很多人梦寐以求的事业单位待过，但是却时常感觉到内心的空洞。有幸通过博客及知乎了解到了行业大神们的学习经历，发现很多人比你都优秀，却比你加倍的认真，成功是有理由。优秀是一种习惯，坚持是一种品质。作为一个程序员，需要不断地去学习积累，而不能局限于在自己掌握的知识。所以当你感觉瓶颈的到来，请静下来思考。下面说说我的思考。</p>
<ul>
<li>跳出自己的舒适区</li>
</ul>
<p>作为Android开发者很容易陷入一个误区，就是能够开始利用API及开源项目开发出绚丽的动画及功能，这往往是一个致命的陷阱。在外包公司的经历，我们讲究的是快，只为实现功能，进行交互。不考虑软件的迭代及设计，这使得一年可能开发出10几个项目，但可能永远是一个初级的程序员。所以我们需要深入去学习Android这个系统而不是仅仅懂得API及开源框架的使用</p>
<ul>
<li>基础很重要</li>
</ul>
<p>来到新的公司，公司的项目是经历了7 8年的迭代，经过了N多人的手。可想而知，一个好的架构及代码的设计是何其重要，面临需求的不断变化，这个时候设计模式、基础的数据结构算法是何等的重要。想想问问自己，是否知道最常用ArrayList、HashMap的实现原理？想想问问自己，作为一个程序员，是否连最简单的排序算法都不知道，一个冒泡排序都写不出呢？这些都是我们常常易于忘记的基础，却是对我们写出高质量的代码有着深远的意义</p>
<ul>
<li>贵在坚持</li>
</ul>
<p>知识在于积累，贵在坚持。没有什么是速成的，需要每一天的积累及沉淀。</p>
<p>所以2016底开通了自己的博客，一个是希望能够督促自己坚持，一个是希望能够总结自己的学习知识。另外公司9点30上班，每天坚持7点30分起来看书及学习。初步的计划完成基础知识的复习，包括数据结构及算法、设计模式等。2017希望能够继续坚持学习及工作，使得自己能够在技术上跟进一步，生活过得更加充实。</p>
<ul>
<li><p>努力工作，写出更优质、稳定的代码<br>通过学习及积累，写出更高质量的代码，能够更好的适应需求的变化。同时提升代码的稳定性，为用户提供更优质的体验</p>
</li>
<li><p>坚持每月4遍博客<br>博客还是要继续坚持写的，能够督促自己，同时也能将自己的学习知识进行归纳总结，便于复习及加深记忆理解。2017年希望能够看完《JAVA并发编程实践》《深入理解Java虚拟机 JVM高级特性与最佳实践》，以及对网络通信、Android底层源码及性能优化相关的学习</p>
</li>
<li><p>参与1-2个开源项目的开发<br>希望能够在下半年有机会参与或自己开发一些开源的项目，将学习积累的一些的知识，进行实践</p>
</li>
<li><p>除了工作及学习，抽多些时间陪家人<br>工作学习很重要，家人也很重要。希望能够在兼顾学习工作的情况下，抽多点时间陪家里人…</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/08/设计模式-桥梁模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/设计模式-桥梁模式/" itemprop="url">
                  设计模式-桥梁模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T13:36:09+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/设计模式-桥梁模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/设计模式-桥梁模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-桥梁模式的定义及使用场景"><a href="#1-桥梁模式的定义及使用场景" class="headerlink" title="1.桥梁模式的定义及使用场景"></a>1.桥梁模式的定义及使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>桥梁模式也称为桥接模式，是结构型设计模式之一。将抽象和实现解耦，使得两者可以独立地变化</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>不希望或不适合使用继承的场景<br>例如继承层次过渡、无法更细化设计颗粒等场景，而要考虑使用桥梁模式</li>
<li>接口或抽象类不稳定的场景<br>明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失，也是比较失败的做法</li>
<li>重用性要求较高的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170308133538612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-桥梁模式的优缺点"><a href="#2-桥梁模式的优缺点" class="headerlink" title="2. 桥梁模式的优缺点"></a>2. 桥梁模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>抽象和实现分离<br>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定一个固定的抽象层次上</li>
<li>优秀的扩充能力</li>
<li>实现细节对客户透明<br>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>良好的设计不易，对开发者来说要有一定的经验要求，原因是对于抽象和实现的分离需要有良好的把握。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>桥梁模式是非常简单的，使用该模式时注意考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，那还要继承干什么呢？桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此在进行系统涉及是，发现类的继承有N层时，可以考虑使用桥梁模式。<h2 id="4-桥梁模式的实现方式"><a href="#4-桥梁模式的实现方式" class="headerlink" title="4. 桥梁模式的实现方式"></a>4. 桥梁模式的实现方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Implementor &#123;</div><div class="line">    //基本方法</div><div class="line">    public void doSomething();</div><div class="line">    public void doAnything();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConcreteImplementor1 implements Implementor &#123;</div><div class="line">    @Override</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.println(&quot;ConcreteImplementor1 doSomething!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doAnything() &#123;</div><div class="line">        System.out.println(&quot;ConcreteImplementor1 doAnything!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConcreteImplementor2 implements Implementor &#123;</div><div class="line">    @Override</div><div class="line">    public void doSomething() &#123;</div><div class="line">        System.out.println(&quot;ConcreteImplementor2 doSomething!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doAnything() &#123;</div><div class="line">        System.out.println(&quot;ConcreteImplementor2 doAnything!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class Abstraction &#123;</div><div class="line">    //定义对实现化角色的引用</div><div class="line">    private Implementor imp;</div><div class="line"></div><div class="line">    //约束子类必须实现该构造函数</div><div class="line">    public Abstraction(Implementor imp) &#123;</div><div class="line">        this.imp = imp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //自身的行为和属性</div><div class="line">    public void request() &#123;</div><div class="line">        this.imp.doSomething();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Implementor getImp() &#123;</div><div class="line">        return imp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class RefineAbstraction extends Abstraction &#123;</div><div class="line"></div><div class="line">    public RefineAbstraction(Implementor imp) &#123;</div><div class="line">        super(imp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void request() &#123;</div><div class="line">        /**</div><div class="line">         * 业务处理</div><div class="line">         */</div><div class="line">        super.request();</div><div class="line">        super.getImp().doAnything();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        Implementor imp = new ConcreteImplementor1();</div><div class="line">        Abstraction abstraction = new RefineAbstraction(imp);</div><div class="line">        abstraction.request();</div><div class="line"></div><div class="line">        Implementor imp2 = new ConcreteImplementor2();</div><div class="line">        abstraction = new RefineAbstraction(imp2);</div><div class="line">        abstraction.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/07/设计模式-享元模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/设计模式-享元模式/" itemprop="url">
                  设计模式-享元模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T09:36:59+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/07/设计模式-享元模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/07/设计模式-享元模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-享元模式的定义及使用场景"><a href="#1-享元模式的定义及使用场景" class="headerlink" title="1.享元模式的定义及使用场景"></a>1.享元模式的定义及使用场景</h1><p>享元模式是对象池的一种实现。享元模式用来尽可能减少内存的使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。</p>
<p>享元对象中的部分状态是可以共享，可以共享的状态分为内部状态，内部状态不会随着环境变化；不可共享的状态则称为外部状态，他们会随着环境的改变而改变。在享元模式中会建议一个对象容器，在经典的享元模式中该容器为一个Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元模式工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免了创建过多对象的问题。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>享元模式是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>系统中存在大量的相似对象</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特点身份</li>
<li>需要缓冲池的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170307093437266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-享元模式的优缺点"><a href="#2-享元模式的优缺点" class="headerlink" title="2. 享元模式的优缺点"></a>2. 享元模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><p>享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。</p>
<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2><p>提高了系统的复杂性，需要分离出外部状态和内部状态，而且内部状态具有固化特性，不应随外部状态改变而改变</p>
<h1 id="3-享元模式的实现方式"><a href="#3-享元模式的实现方式" class="headerlink" title="3. 享元模式的实现方式"></a>3. 享元模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Flyweight &#123;</div><div class="line">    //一个示意性方法，参数state是外蕴状态</div><div class="line">    public void operation(String state);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class ConcreteFlyweight implements Flyweight &#123;</div><div class="line">    private Character intrinsicState = null;</div><div class="line">    /**</div><div class="line">     * 构造函数，内蕴状态作为参数传入</div><div class="line">     * @param state</div><div class="line">     */</div><div class="line">    public ConcreteFlyweight(Character state)&#123;</div><div class="line">        this.intrinsicState = state;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    /**</div><div class="line">     * 外蕴状态作为参数传入方法中，改变方法的行为，</div><div class="line">     * 但是并不改变对象的内蕴状态。</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void operation(String state) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);</div><div class="line">        System.out.println(&quot;Extrinsic State = &quot; + state);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FlyweightFactory &#123;</div><div class="line">    private Map&lt;Character,Flyweight&gt; files = new HashMap&lt;Character,Flyweight&gt;();</div><div class="line"></div><div class="line">    public Flyweight factory(Character state)&#123;</div><div class="line">        //先从缓存中查找对象</div><div class="line">        Flyweight fly = files.get(state);</div><div class="line">        if(fly == null)&#123;</div><div class="line">            //如果对象不存在则创建一个新的Flyweight对象</div><div class="line">            fly = new ConcreteFlyweight(state);</div><div class="line">            //把这个新的Flyweight对象添加到缓存中</div><div class="line">            files.put(state, fly);</div><div class="line">        &#125;</div><div class="line">        return fly;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        FlyweightFactory factory = new FlyweightFactory();</div><div class="line">        Flyweight fly = factory.factory(new Character(&apos;a&apos;));</div><div class="line">        fly.operation(&quot;First Call&quot;);</div><div class="line"></div><div class="line">        fly = factory.factory(new Character(&apos;b&apos;));</div><div class="line">        fly.operation(&quot;Second Call&quot;);</div><div class="line"></div><div class="line">        fly = factory.factory(new Character(&apos;a&apos;));</div><div class="line">        fly.operation(&quot;Third Call&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/06/设计模式-解释器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/设计模式-解释器模式/" itemprop="url">
                  设计模式-解释器模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T10:22:49+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/06/设计模式-解释器模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/06/设计模式-解释器模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-解释器模式的定义及使用场景"><a href="#1-解释器模式的定义及使用场景" class="headerlink" title="1.解释器模式的定义及使用场景"></a>1.解释器模式的定义及使用场景</h1><p>解释器模式是一种用得比较少的行为模式，其提供了一种解释语言的语法或表达式的方式，该模式定义了一个表达式接口，通过该接口解释一个特定的上下文</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素相同。按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。在这种情况下，可以通过程序来一劳永逸地解决该问题</li>
<li>一个简单语法需要解释的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170306102013110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-解释器模式的优缺点"><a href="#2-解释器模式的优缺点" class="headerlink" title="2. 解释器模式的优缺点"></a>2. 解释器模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p>
<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2><ul>
<li>解释器模式会引起类膨胀<br>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦</li>
<li>解释器模式采用递归调用方式<br>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地解析，无论是面向对象的语言还是面向过程的语言，递归都是 在必要条件下使用的，它导致调试非常复杂。想想看，如果要排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。</li>
<li>效率问题<br>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。<h1 id="4-解释器模式的实现方式"><a href="#4-解释器模式的实现方式" class="headerlink" title="4. 解释器模式的实现方式"></a>4. 解释器模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Expression &#123;</div><div class="line">    //每个表达式必须有一个解析任务</div><div class="line">    public abstract Object interpreter(Context ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NoterminalExpression extends Expression &#123;</div><div class="line">    //每个非终结符表达式都会对其他表达式产生依赖</div><div class="line">    public NoterminalExpression(Expression... expressions) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object interpreter(Context ctx) &#123;</div><div class="line">        //进行文法处理</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class TerminaExpression extends Expression &#123;</div><div class="line">    //通常终结符表达式只有一个，但是有多个对象</div><div class="line">    @Override</div><div class="line">    public Object interpreter(Context ctx) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">       Context ctx=new Context();</div><div class="line">        Stack&lt;Expression&gt; stack=new Stack&lt;&gt;();</div><div class="line">        //通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等</div><div class="line">        for(;;)&#123;</div><div class="line">            //进行语法判断，并产生递归调用</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        //产生一个完整的语法树，由各个具体的语法分析进行解析</div><div class="line">        Expression expression=stack.pop();</div><div class="line">        //具体元素进入场景</div><div class="line">        expression.interpreter(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/04/设计模式-状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/04/设计模式-状态模式/" itemprop="url">
                  设计模式-状态模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-04T15:20:39+08:00">
                2017-03-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/04/设计模式-状态模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/04/设计模式-状态模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-状态模式的定义及使用场景"><a href="#1-状态模式的定义及使用场景" class="headerlink" title="1.状态模式的定义及使用场景"></a>1.状态模式的定义及使用场景</h1><p>状态模式中的行为是由状态来决定的，不同的状态下又不同的行为。状态模式和策略模式的结构几乎完全一样，但他们的目的，本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、互相替换的。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>当一个对象内在状态改变时允许其 改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发送了改变一样。</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为</li>
<li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的多分支语句，且这些分支依赖于该对象的状态</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170304151833643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-状态模式的优缺点"><a href="#2-状态模式的优缺点" class="headerlink" title="2. 状态模式的优缺点"></a>2. 状态模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>结构清晰<br>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性，提高系统的可维护性</li>
<li>遵循设计原则<br>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类。你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了</li>
<li>良好的封装性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>状态模式既有优点，也有缺点。子类会比较多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>状态模式适用于当某个对象在它的状态发送改变时，它的行为也随着发送比较大的变化，也就是说在行为状态受约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个<h1 id="4-状态模式的实现方式"><a href="#4-状态模式的实现方式" class="headerlink" title="4. 状态模式的实现方式"></a>4. 状态模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public abstract class State &#123;</div><div class="line">    //定义一个环境角色，提供子类访问</div><div class="line">    protected Context context;</div><div class="line"></div><div class="line">    //设置环境角色</div><div class="line">    public void setContext(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void handle1();</div><div class="line"></div><div class="line">    public abstract void handle2();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ConcreteState1 extends State &#123;</div><div class="line">    @Override</div><div class="line">    public void handle1() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handle2() &#123;</div><div class="line">        //设置当前状态为stat2</div><div class="line">        super.context.setCurrentState(Context.state2);</div><div class="line">        //过渡到state2状态</div><div class="line">        super.context.handler2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ConcreteState2 extends  State &#123;</div><div class="line">    @Override</div><div class="line">    public void handle1() &#123;</div><div class="line">        //设置当前状态为stat2</div><div class="line">        super.context.setCurrentState(Context.state1);</div><div class="line">        //过渡到state2状态</div><div class="line">        super.context.handle1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handle2() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">    //定义状态</div><div class="line">    public final static State state1 = new ConcreteState1();</div><div class="line">    public final static State state2 = new ConcreteState2();</div><div class="line">    //当前状态</div><div class="line">    private State currentState;</div><div class="line"></div><div class="line">    public State getCurrentState() &#123;</div><div class="line">        return currentState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCurrentState(State currentState) &#123;</div><div class="line">        this.currentState = currentState;</div><div class="line">        this.currentState.setContext(this);</div><div class="line">    &#125;</div><div class="line">    //行为委托</div><div class="line">    public void handle1()&#123;</div><div class="line">        this.currentState.handle1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void handler2()&#123;</div><div class="line">        this.currentState.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        Context context=new Context();</div><div class="line">        context.setCurrentState(new ConcreteState1());</div><div class="line">        context.handle1();</div><div class="line">        context.handler2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/03/设计模式-访问者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/03/设计模式-访问者模式/" itemprop="url">
                  设计模式-访问者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T08:23:29+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/03/设计模式-访问者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/03/设计模式-访问者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-访问者模式的定义及使用场景"><a href="#1-访问者模式的定义及使用场景" class="headerlink" title="1.访问者模式的定义及使用场景"></a>1.访问者模式的定义及使用场景</h1><p>访问者模式是一种数据操作与数据结构分离的设计模式，访问者模式的基本想法是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中会调用访问者的visit方法，从而使访问者得以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象设施一些依赖于具体类的操作，也就说是用迭代器模式已经不能胜任的情景</li>
<li><p>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类</p>
<p><img src="http://img.blog.csdn.net/20170303082103186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h1 id="2-访问者模式的优缺点"><a href="#2-访问者模式的优缺点" class="headerlink" title="2. 访问者模式的优缺点"></a>2. 访问者模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>各角色职责分离，符合单一责任原则</li>
<li>具有优秀的扩展性</li>
<li>使得数据结构和作用于数据结构上的操作解耦，使得操作集合可以独立变化</li>
<li>高灵活性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2></li>
<li>具体元素对访问者公布细节<br>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是访问者关注了其他类的内部细节，这是迪米特法则所不建议</li>
<li>具体元素变更比较困难<br>具体元素角色的增加、删除、修改都是比较困难</li>
<li>违背了依赖倒置原则<br>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。<h1 id="4-访问者模式的实现方式"><a href="#4-访问者模式的实现方式" class="headerlink" title="4. 访问者模式的实现方式"></a>4. 访问者模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Element &#123;</div><div class="line">    //定义业务逻辑</div><div class="line">    public abstract void doSomeThing();</div><div class="line"></div><div class="line">    //允许谁来访问</div><div class="line">    public abstract void accept(IVisitor visitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CocreteElement1 extends Element &#123;</div><div class="line">    @Override</div><div class="line">    public void doSomeThing() &#123;</div><div class="line">        System.out.println(&quot;CocreteElement1 doSomeThing&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void accept(IVisitor visitor) &#123;</div><div class="line">        visitor.visit(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CocreteElement2 extends Element &#123;</div><div class="line">    @Override</div><div class="line">    public void doSomeThing() &#123;</div><div class="line">        System.out.println(&quot;CocreteElement2 doSomeThing&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void accept(IVisitor visitor) &#123;</div><div class="line">        visitor.visit(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface IVisitor &#123;</div><div class="line">    //可以访问那些对象</div><div class="line">    public void visit(CocreteElement1 element1);</div><div class="line"></div><div class="line">    public void visit(CocreteElement2 element2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Visitor implements IVisitor &#123;</div><div class="line">    @Override</div><div class="line">    public void visit(CocreteElement1 element1) &#123;</div><div class="line">        element1.doSomeThing();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void visit(CocreteElement2 element2) &#123;</div><div class="line">        element2.doSomeThing();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ObjectStruture &#123;</div><div class="line">    public static Element createElement() &#123;</div><div class="line">        Random random = new Random();</div><div class="line">        if (random.nextInt(100) &gt; 50) &#123;</div><div class="line">            return new CocreteElement1();</div><div class="line">        &#125; else &#123;</div><div class="line">            return new CocreteElement2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        for (int i = 0; i &lt; 20; i++) &#123;</div><div class="line">            Element element = ObjectStruture.createElement();</div><div class="line">            element.accept(new Visitor());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/01/设计模式-备忘录模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/设计模式-备忘录模式/" itemprop="url">
                  设计模式-备忘录模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T10:02:18+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/设计模式-备忘录模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/设计模式-备忘录模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-备忘录模式的定义及使用场景"><a href="#1-备忘录模式的定义及使用场景" class="headerlink" title="1.备忘录模式的定义及使用场景"></a>1.备忘录模式的定义及使用场景</h1><p>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象回复到原先保存的状态</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>需要用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170301095411447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-备忘录模式的优缺点"><a href="#2-备忘录模式的优缺点" class="headerlink" title="2. 备忘录模式的优缺点"></a>2. 备忘录模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保持细节<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1></li>
<li>备忘录的生命期<br>备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li>
<li>备忘录的性能<br>不要在频繁建立备份的场景中使用备忘录模式（比如一个for循环中），主要原因是一是控制不了备忘录建立的对象数量；而是大对象的建立是要消耗资源的，系统的性能需要考虑。<h1 id="4-备忘录模式的实现方式"><a href="#4-备忘录模式的实现方式" class="headerlink" title="4. 备忘录模式的实现方式"></a>4. 备忘录模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Memento &#123;</div><div class="line">    //发起人的内部状态</div><div class="line">    private String state=&quot;&quot;;</div><div class="line"></div><div class="line">    public Memento(String state) &#123;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getState() &#123;</div><div class="line">        return state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setState(String state) &#123;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Caretaker &#123;</div><div class="line">    //备忘录对象</div><div class="line">    private  Memento memento;</div><div class="line"></div><div class="line">    public Memento getMemento() &#123;</div><div class="line">        return memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMemento(Memento memento) &#123;</div><div class="line">        this.memento = memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">    //内部状态</div><div class="line">    private String state = &quot;&quot;;</div><div class="line"></div><div class="line">    public String getState() &#123;</div><div class="line">        return state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setState(String state) &#123;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //创建一个备忘录</div><div class="line">    public Memento createMemento() &#123;</div><div class="line">        return new Memento(state);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //恢复一个备忘录</div><div class="line">    public void restoreMemento(Memento memento) &#123;</div><div class="line">        this.setState(memento.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        //定义出发起人</div><div class="line">        Originator originator = new Originator();</div><div class="line">        originator.setState(&quot;初始：1111111111111&quot;);</div><div class="line">        //定义出备忘录管理员</div><div class="line">        Caretaker caretaker = new Caretaker();</div><div class="line">        System.out.println(originator.getState());</div><div class="line">        //创建一个备忘录</div><div class="line">        caretaker.setMemento(originator.createMemento());</div><div class="line">        originator.setState(&quot;改变：22222222222222&quot;);</div><div class="line">        System.out.println(originator.getState());</div><div class="line">        originator.setState(&quot;恢复：restoreMemento&quot;);</div><div class="line">        originator.restoreMemento(caretaker.getMemento());</div><div class="line">        System.out.println(originator.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-备忘录模式在Android中的实际应用"><a href="#5-备忘录模式在Android中的实际应用" class="headerlink" title="5. 备忘录模式在Android中的实际应用"></a>5. 备忘录模式在Android中的实际应用</h1><p>在Android开发中，状态模式应用是Android中的状态保持，也就是里面的onSaveInstanceState和onRestoreInstanceState。当Activity不是正常方式退出，且Activity在随后的时间内被系统杀死之前会调用这两个方法让开发人员可以有机会存储Activity的相关信息，并且在下次放好Activity的时候恢复这些数据。<br>Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line"> outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); //保存当前窗口的视图树的状态</div><div class="line"> Parcelable p = mFragments.saveAllState(); //存储Fragment的状态</div><div class="line"> if (p != null) &#123;</div><div class="line"> outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line"> &#125;</div><div class="line"> getApplication().dispatchActivitySaveInstanceState(this, outState);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>Window的实现为PhoneWindow：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> /** &#123;@inheritDoc&#125; */</div><div class="line">  @Override</div><div class="line">  public Bundle saveHierarchyState() &#123;</div><div class="line">  Bundle outState = new Bundle();</div><div class="line">  if (mContentParent == null) &#123;</div><div class="line">  return outState;</div><div class="line">  &#125;</div><div class="line">//通过SparseArray类来存储，这相当于一个key为整型的map</div><div class="line">  SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();</div><div class="line">//mContentParent就是调用Activity的setContentView函数设置的内容视图，它是内容视图的根节点，在这里存储整棵树的结构</div><div class="line">  mContentParent.saveHierarchyState(states);</div><div class="line">//将视图树结构放到outState中</div><div class="line">  outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">  // 保存当前界面中获取了焦点的View</div><div class="line">  View focusedView = mContentParent.findFocus();</div><div class="line">  if (focusedView != null) &#123;</div><div class="line">  if (focusedView.getId() != View.NO_ID) &#123;</div><div class="line">  outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">  &#125; else &#123;</div><div class="line">  if (false) &#123;</div><div class="line">  Log.d(TAG, &quot;couldn&apos;t save which view has focus because the focused view &quot;</div><div class="line">  + focusedView + &quot; has no id.&quot;);</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 存储整个面板的状态</div><div class="line">  SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">  savePanelState(panelStates);</div><div class="line">  if (panelStates.size() &gt; 0) &#123;</div><div class="line">  outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//存储actionBar的状态</div><div class="line">  if (mDecorContentParent != null) &#123;</div><div class="line">  SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();</div><div class="line">  mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">  outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return outState;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在saveHierarchyState函数中，主要是存储了与当前UI、ActionBar相关的View状态。mContentParent就是我们通过Activity的setContentView函数设置的内容视图，他是这个内容视图的根节点。mContentParent是一个ViewGroup对象，但是saveHierachyState是在父类View中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line"> dispatchSaveInstanceState(container);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123;</div><div class="line">mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">Parcelable state = onSaveInstanceState();</div><div class="line">if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</div><div class="line">throw new IllegalStateException(</div><div class="line">&quot;Derived class did not call super.onSaveInstanceState()&quot;);</div><div class="line">&#125;</div><div class="line">if (state != null) &#123;</div><div class="line">// Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)</div><div class="line">// + &quot;: &quot; + state);</div><div class="line">container.put(mID, state); //将自身状态放到container中 key 为id value为自身状态</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//View类默认的存储的状态为空</div><div class="line"> protected Parcelable onSaveInstanceState() &#123;</div><div class="line">  mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">  if (mStartActivityRequestWho != null) &#123;</div><div class="line">  BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);</div><div class="line">  state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</div><div class="line">  return state;</div><div class="line">  &#125;</div><div class="line">  return BaseSavedState.EMPTY_STATE;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>恢复数据的调用过程如下，基本流程与保存类似<br>Activity:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">if (mWindow != null) &#123;</div><div class="line">Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);</div><div class="line">if (windowState != null) &#123;</div><div class="line">mWindow.restoreHierarchyState(windowState);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PhoneWindow:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/** &#123;@inheritDoc&#125; */</div><div class="line"> @Override</div><div class="line"> public void restoreHierarchyState(Bundle savedInstanceState) &#123;</div><div class="line"> if (mContentParent == null) &#123;</div><div class="line"> return;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> SparseArray&lt;Parcelable&gt; savedStates</div><div class="line"> = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);</div><div class="line"> if (savedStates != null) &#123;</div><div class="line"> mContentParent.restoreHierarchyState(savedStates);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> // restore the focused view</div><div class="line"> int focusedViewId = savedInstanceState.getInt(FOCUSED_ID_TAG, View.NO_ID);</div><div class="line"> if (focusedViewId != View.NO_ID) &#123;</div><div class="line"> View needsFocus = mContentParent.findViewById(focusedViewId);</div><div class="line"> if (needsFocus != null) &#123;</div><div class="line"> needsFocus.requestFocus();</div><div class="line"> &#125; else &#123;</div><div class="line"> Log.w(TAG,</div><div class="line"> &quot;Previously focused view reported id &quot; + focusedViewId</div><div class="line"> + &quot; during save, but can&apos;t be found during restore.&quot;);</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> // restore the panels</div><div class="line"> SparseArray&lt;Parcelable&gt; panelStates = savedInstanceState.getSparseParcelableArray(PANELS_TAG);</div><div class="line"> if (panelStates != null) &#123;</div><div class="line"> restorePanelState(panelStates);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> if (mDecorContentParent != null) &#123;</div><div class="line"> SparseArray&lt;Parcelable&gt; actionBarStates =</div><div class="line"> savedInstanceState.getSparseParcelableArray(ACTION_BAR_TAG);</div><div class="line"> if (actionBarStates != null) &#123;</div><div class="line"> doPendingInvalidatePanelMenu();</div><div class="line"> mDecorContentParent.restoreToolbarHierarchyState(actionBarStates);</div><div class="line"> &#125; else &#123;</div><div class="line"> Log.w(TAG, &quot;Missing saved instance states for action bar views! &quot; +</div><div class="line"> &quot;State will not be restored.&quot;);</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>View:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">  dispatchRestoreInstanceState(container);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Called by &#123;@link #restoreHierarchyState(android.util.SparseArray)&#125; to retrieve the</div><div class="line">* state for this view and its children. May be overridden to modify how restoring</div><div class="line">* happens to a view&apos;s children; for example, some views may want to not store state</div><div class="line">* for their children.</div><div class="line">*</div><div class="line">* @param container The SparseArray which holds previously saved state.</div><div class="line">*</div><div class="line">* @see #dispatchSaveInstanceState(android.util.SparseArray)</div><div class="line">* @see #restoreHierarchyState(android.util.SparseArray)</div><div class="line">* @see #onRestoreInstanceState(android.os.Parcelable)</div><div class="line">*/</div><div class="line">protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) &#123;</div><div class="line">if (mID != NO_ID) &#123;</div><div class="line">Parcelable state = container.get(mID);</div><div class="line">if (state != null) &#123;</div><div class="line">// Log.i(&quot;View&quot;, &quot;Restoreing #&quot; + Integer.toHexString(mID)</div><div class="line">// + &quot;: &quot; + state);</div><div class="line">mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">onRestoreInstanceState(state);</div><div class="line">if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123;</div><div class="line">throw new IllegalStateException(</div><div class="line">&quot;Derived class did not call super.onRestoreInstanceState()&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">protected void onRestoreInstanceState(Parcelable state) &#123;</div><div class="line">mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">if (state != null &amp;&amp; !(state instanceof AbsSavedState)) &#123;</div><div class="line">throw new IllegalArgumentException(&quot;Wrong state class, expecting View State but &quot;</div><div class="line">+ &quot;received &quot; + state.getClass().toString() + &quot; instead. This usually happens &quot;</div><div class="line">+ &quot;when two views of different type have the same id in the same hierarchy. &quot;</div><div class="line">+ &quot;This view&apos;s id is &quot; + ViewDebug.resolveId(mContext, getId()) + &quot;. Make sure &quot;</div><div class="line">+ &quot;other views do not use the same id.&quot;);</div><div class="line">&#125;</div><div class="line">if (state != null &amp;&amp; state instanceof BaseSavedState) &#123;</div><div class="line">mStartActivityRequestWho = ((BaseSavedState) state).mStartActivityRequestWhoSaved;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个过程中，Activity扮演了Caretaker角色，负责存储、恢复UI的状态信息；Activity、Fragement、View、ViewGroup等对象为Originator角色，也就是需要存储状态的对象；Memento则是由Bundle类扮演。</p>
<p>Activity在停止之前会根据Activity的退出情景来选择是否需要存储状态，在重新启动该Activity时会判断ActivityClientRecord对象中是否存储了Activity的状态，如果含有状态则调用Activity的onRestoreInstanceState函数，从而使得Activity的UI效果与上次保持一致，这样一来，就保证了在非正常退出Activity时不会丢失数据的情况，很好地提升了用户体验。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/02/28/设计模式-外观模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/设计模式-外观模式/" itemprop="url">
                  设计模式-外观模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T09:29:08+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/28/设计模式-外观模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/28/设计模式-外观模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-外观模式的定义及使用场景"><a href="#1-外观模式的定义及使用场景" class="headerlink" title="1.外观模式的定义及使用场景"></a>1.外观模式的定义及使用场景</h1><p>外观模式（Facade）在开发过程中的运用频率非常高，尤其是在现阶段各个第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式，通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。</p>
<p><img src="http://img.blog.csdn.net/20170228092218459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>要求一个子系统的外部与其内部的通讯必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口</li>
<li>子系统相对独立–外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散<h1 id="2-外观模式的优缺点"><a href="#2-外观模式的优缺点" class="headerlink" title="2. 外观模式的优缺点"></a>2. 外观模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2></li>
<li>减少系统的相互依赖</li>
<li>提高了灵活性</li>
<li>提高安全性<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>门面模式的最大缺点就是不符合开闭原则，对修改关闭，对扩展开放，需求变化时，需要修改Facade的代码，这样相对风险比较大<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1></li>
<li>对于庞大到不能容忍的程度，一个子系统可以有多个门面</li>
<li>门面不要参与子系统内的业务逻辑<h1 id="4-外观模式的实现方式"><a href="#4-外观模式的实现方式" class="headerlink" title="4. 外观模式的实现方式"></a>4. 外观模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ClassA &#123;</div><div class="line">    public void doSomeThing() &#123;</div><div class="line">        System.out.println(&quot;ClassA is doSomeThing!!!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ClassB &#123;</div><div class="line">    public void doSomeThing() &#123;</div><div class="line">        System.out.println(&quot;ClassB is doSomeThing!!!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ClassC &#123;</div><div class="line">    public void doSomeThing() &#123;</div><div class="line">        System.out.println(&quot;ClassC is doSomeThing!!!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Facade &#123;</div><div class="line">    ClassA classA = new ClassA();</div><div class="line">    ClassB classB = new ClassB();</div><div class="line">    ClassC classC = new ClassC();</div><div class="line"></div><div class="line">    public void doMethodA() &#123;</div><div class="line">        classA.doSomeThing();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doMethodB() &#123;</div><div class="line">        classB.doSomeThing();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doMethodC() &#123;</div><div class="line">        classC.doSomeThing();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    public  static void main(String args[]) &#123;</div><div class="line">        Facade facade = new Facade();</div><div class="line">        facade.doMethodA();</div><div class="line">        facade.doMethodB();</div><div class="line">        facade.doMethodC();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-外观模式在Android中的实际应用"><a href="#5-外观模式在Android中的实际应用" class="headerlink" title="5. 外观模式在Android中的实际应用"></a>5. 外观模式在Android中的实际应用</h1><p>在Android开发过程中，Context是最重要的一个类型，Context意为上下文，也就是程序的运行环境。它封装了很多重要的操作。如startActivity（）、sendBoradcast（）、bindService等，因此，Context对开发者来说就是重要的高层接口。</p>
<p>我们都知道Context的实现类是ContextImpl。ContextImpl内部封装了很多不同子系统的操作，例如Activity的跳转、广播、启动服务、设置壁纸等，这些工作并不是在ContextImpl中实现，而是转交给了具体的子系统进行处理。</p>
<p>用户可以通过Context这个接口统一进行与Android系统的交互，这样用户通过情况下就不需要对每个子系统进行了解，例如启动Activity时用户不需要手动调用mMainThread.getInstrumentation().execStartActivity函数进行执行，发送广播时也不需要直接操作ActivityManagerNative类。用户于系统服务的交互都通过Context的高层接口，这样对用户屏蔽了具体的实现细节，降低了使用成本</p>
<p>关于Context的具体介绍可以参考博文：<br><a href="http://blog.csdn.net/junbin1011/article/details/54612858（" target="_blank" rel="external">http://blog.csdn.net/junbin1011/article/details/54612858（</a>  Android之Context底层原理）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">优秀是一种习惯，坚持是一种品质。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-jun-bin-48/" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
