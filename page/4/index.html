<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="一花一世界，一码一浮生">
<meta property="og:type" content="website">
<meta property="og:title" content="JunBin">
<meta property="og:url" content="https://junbin1011.github.io/page/4/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="一花一世界，一码一浮生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JunBin">
<meta name="twitter:description" content="一花一世界，一码一浮生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/page/4/">





  <title> JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/03/JVM学习笔记-内存分配与回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/JVM学习笔记-内存分配与回收/" itemprop="url">
                  JVM学习笔记-内存分配与回收
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:03:11+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/03/JVM学习笔记-内存分配与回收/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/03/JVM学习笔记-内存分配与回收/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们介绍了new一个对象需要经过类加载、内存分配、初始化、对象设置、执行init等操作。那么在我们的代码中，一个对象是怎么样就被回收的呢？我们所知道的当一个对象实例没用被引用持有，就会被GC回收，究竟JVM是怎样来判断一个对象是否被持有引用的呢？下面我们将一一来进行分析。</p>
<h1 id="如何判断对象是否被持有引用？"><a href="#如何判断对象是否被持有引用？" class="headerlink" title="如何判断对象是否被持有引用？"></a>如何判断对象是否被持有引用？</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><ul>
<li>定义：引用计数算法（Reference Counting）:给对象添加一个引用计数器，每当一个地方引用它时，计数器值就+1；当引用失效时，计数器值就-1；任何时刻计数器为0的对象就是不可能被再使用的；</li>
<li>优点：实现简单，判定效率高；微软的COM技术、Python中都使用了Reference Couting算法进行内存管理；</li>
<li>缺点：由于其很难解决对象之间相互循环引用的问题，主流Java虚拟机里面都没有选用Refrence Couting算法来管理内存；<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2>定义：可达性分析（Reachability Analysis）判断对象存活的基本思路：通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-0b5d19574afc5621?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>Java语言中，可作为GC Roots对象包括：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中产量引用的对象；</li>
<li>本地方法栈中JNI（即一般的Native方法）引用的对象</li>
</ol>
<h1 id="没有持有引用就会被GC回收么？"><a href="#没有持有引用就会被GC回收么？" class="headerlink" title="没有持有引用就会被GC回收么？"></a>没有持有引用就会被GC回收么？</h1><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，而真正宣告一个对象死亡，至少要经历两次标记过程；如果对象在进行可达性分析后发现没有GC Roots想连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize()方法中执行缓慢，或者发送了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只有重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移除出F-Queue；如果对象这时候还没有逃脱，那就会被GC回收。</p>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>由于不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收的效率。因此JVM采用了分代垃圾回收。在JVM的内存空间中把堆空间分为年老代和年轻代。将大量创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。年轻代中又被分为Eden区、和两个Survivor区。新的对象分配是首先放在Eden区、Survivor区作为Eden区和Old区的缓冲，在Survivor区的对象经历若干次收集任然存活的，就会被转移到年老区。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-7cc47a60fd0e8dc5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>对象的内存分配，主要分配在年轻代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用了哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数配置，接下来将会介绍几条最普遍的内存分配规则。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来存放</p>
<h3 id="长期存活的对象将进入年老代"><a href="#长期存活的对象将进入年老代" class="headerlink" title="长期存活的对象将进入年老代"></a>长期存活的对象将进入年老代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该在年轻代，哪些应该在年老代。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次的GC后任然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中每熬过一次GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>为了能更换地适应不同程序的内存情况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升年老代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入年老代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生MinorGC之前，虚拟机会先检查年老代最大可用的连续空间是否大于年轻代所有对象空间，如果这个条件成立，那么GC可以确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查年老代最大可用的连续空间是否大于历次晋升到年老代的对象的平均大小。如果大于，将尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromotionFailure不允许冒险，那这时也要改为进行一次FullGC</p>
<h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发SMinorGC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li><p>年老代（Tenured）被写满</p>
</li>
<li><p>持久代（Perm）被写满</p>
</li>
<li><p>System.gc()被显示调用</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文主要参考《深入理解Java虚拟机：JVM高级特性与最佳实践》后的学习笔记及总结</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/27/JVM学习笔记-内存管理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/27/JVM学习笔记-内存管理机制/" itemprop="url">
                  JVM学习笔记-内存管理机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T15:31:07+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/27/JVM学习笔记-内存管理机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/27/JVM学习笔记-内存管理机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java与C++之间有一堆由内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 —— 《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-27e80eb1c5c73953.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器只占用了一块比较小的内存空间。</p>
<p>可以看作是当前线程所执行的字节码文件（class）的行号指示器。在虚拟机的世界中，字节码解析器就是通过改变计数器的值来选取下一条执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等，都需要通过程序计数器来实现。</p>
<p>因为处理器在一个确定的时刻只会执行一个线程中的指令，线程切换后，是通过计数器来记录执行痕迹，因而可以看出，程序计数器是每个线程私有的</p>
<p>如果执行的是java方法，那么记录的是正在执行的虚拟机字节码指令的地址的地址，如果是native方法，计数器的值为空（undefined）</p>
<p>这个内存区域是唯一一个在java虚拟机规范中没有规定任务OutOfMemoryError的情况区域</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法都在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和局部变量。变量槽（Variable Slot）是局部变量表的最小单位，没有强制规定大小为32位，虽然32位足够存放大部分类型的数据。一个Slot可以方法boolean、byte、char、short、int、float、reference、和returnAddress 8种类型。其中reference表示对一个对象实例的引用，通过它可以得到对象在java堆中存放的起始地址的索引和该数据所属数据类型的方法区的类型信息。returnAddress则指向一条字节码指令的地址。对于64位的long和double变量而言，虚拟机会为其分配两个连续的slot空间。</p>
<p>虚拟机通过索引定位的方式使用局部变量表。为了节省栈帧空间，局部变量表中的Slot是可以重要的。当离开了某些变量的作用域之后，这些变量对应的Slot就可以交给其他变量使用。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也称为操作栈，是一个后入先出的栈。方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行以后，只有两种方法可以退出当前方法：</p>
<ul>
<li>当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口，一般来说，调用者的PC计数器可以作为返回地址</li>
<li>当执行遇到一次，并且当前方法体内没有得到处理，就会导致方法退出，此时没有返回值，称为异常完成出口，返回地址要通过异常处理器表来确定</li>
</ul>
<p>当方法返回时，可能进行3个操作：</p>
<ul>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值压入调用者调用栈帧的操作数栈</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令</li>
<li></li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地的方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言，使用方式和数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 Sun HotSport虚拟机）直接就把本地方法栈和虚拟机栈合二为一，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集管理器的主要区域。因此很多时候也被称做“GC”堆。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法。所以Java堆中还可以细分为：新生代和老年代：再细致一点的有Eden空间、From Survivor空间、ToSurvivor空间等，从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私用的分配缓冲区。不过无论如何如何划分，都与存放内容无关，无论哪个区域，存储的都任然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>Java堆可以处理物理上不连续的内存空间，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMenoryError异常</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，<br>方法区也叫永久代。在过去（自定义类加载器还不是很常见的时候），类大多是”static”的，很少被卸载或收集，因此被称为“永久的(Permanent)”。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。同时，由于类class是JVM实现的一部分，并不是由应用创建的，所以又被认为是“非堆(non-heap)”内存。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外们还有一项信息是常量池，用于存放编译期生成的各种常量和符合引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了MIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在Java堆和Native堆中来回复制数据</p>
<h1 id="new-一个对象-发生了什么？"><a href="#new-一个对象-发生了什么？" class="headerlink" title="new 一个对象 发生了什么？"></a>new 一个对象 发生了什么？</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来，在语言层面只是使用new关键字，而在虚拟机中，对象的创建又是怎样一个过程呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ec514d3f1620b0c2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ol>
<li><p>类加载检查<br>虚拟机遇到一条new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符合引用，并且检查这个符合引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p>对象分配内存</p>
</li>
</ol>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。根据Java堆中的内存是否规整，有2种处理方式。</p>
<ul>
<li>指针碰撞(Bump the pointer) </li>
</ul>
<p>Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：Serial、ParNew等收集器。</p>
<ul>
<li>空闲列表(Free List) </li>
</ul>
<p>Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。例如：CMS这种基于Mark-Sweep算法的收集器。</p>
<ol start="3">
<li>并发处理</li>
</ol>
<p>对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。处理方案有2种。</p>
<ul>
<li>同步处理</li>
</ul>
<p>对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p>
<ul>
<li><p>TLAB</p>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。那个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需同步锁定。</p>
</li>
</ul>
<ol start="4">
<li>内存空间初始化</li>
</ol>
<p>虚拟机将分配到的内存空间都初始化为零值（不包括对象头）,如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行。<br>内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<ol start="5">
<li>对象设置</li>
</ol>
<p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。</p>
<ol start="6">
<li>执行init()</li>
</ol>
<p>在上面的工作都完成之后，从虚拟机的角度看，一个新的对象已经产生了。但是从Java程序的角度看，对象的创建才刚刚开始init()方法还没有执行，所有的字段都还是零。</p>
<p>所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行init()方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算产生出来。</p>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p> 对象的内存结构又可以被分为：对象头，实例数据，对象填充。</p>
<ul>
<li>对象头</li>
</ul>
<p>对象头包括两部分信息</p>
<p>第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody>
</table>
<p>第二部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<ul>
<li>实例数据</li>
</ul>
<p>对象真正存储的有效信息，也是在程序代码中定义的各种类型字段内容。无论是从父类继承下来的还是子类定义的，都需要记录下来。 </p>
<ul>
<li>对象填充</li>
</ul>
<p>没有实际意义，仅仅起着占位符的作用。以为对象的大小必须是8字节的整数倍。 </p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于在Java虚拟机规范里面只规定了reference类型是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。  </p>
<ul>
<li>句柄访问</li>
</ul>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4f9fb3059d34d7a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>指针访问对象</li>
</ul>
<p>使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-dfdf9058de2064b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可 观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种 语言、框架中使用句柄来访问的情况也十分常见</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文主要参考《深入理解Java虚拟机：JVM高级特性与最佳实践》后的学习笔记及总结</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/19/Android之Binder底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/Android之Binder底层原理/" itemprop="url">
                  Android之Binder底层原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T08:44:42+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/19/Android之Binder底层原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/19/Android之Binder底层原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h1><p>Binder是Android中特有的一种跨进程通讯的方式。但我们在平时的开发过程中，可能很少用的。而Binder的整个体系结构又尤为复杂，一般很难通过网上的一两篇博客，就能把Binder吃透，我们需要通过源码及Binder的一些架构原理，来进行研究。后面的章节我们将主要通过3个部分来由浅至深来了解Binder。首先我们先看在实际的开发中怎么来实现Binder通讯，接着分析Binder框架的原理，最后结合源码进行分析。</p>
<h2 id="为什么感觉Binder很陌生？"><a href="#为什么感觉Binder很陌生？" class="headerlink" title="为什么感觉Binder很陌生？"></a>为什么感觉Binder很陌生？</h2><ol>
<li>项目业务简单，不涉及多进程通讯</li>
<li>涉及多进程通讯，只简单用AIDL，没深入了解</li>
</ol>
<h2 id="为什么要学习Binder？"><a href="#为什么要学习Binder？" class="headerlink" title="为什么要学习Binder？"></a>为什么要学习Binder？</h2><p>Binder作为Android核心的跨进程通讯方式。如果我们要研究Android的源码，Binder是一道需要跨过去的坎。我们都知道系统的各种服务运行在SystemServer进程中，我们应用与系统的各种交互都涉及到跨进程通讯。</p>
<p>例如最简单的启动一个Activity、启动一个Service。到例如使用系统的网络、硬件、等各种Service，其实都涉及到跨进程通讯。只是系统为我们做好了各种封装调用而已。</p>
<p>所以如果你只希望一直停留在应用层的业务开发，其实你可能一直永远都不知道Binder，但是一旦你开始了解Android的源码，那么你总会与Binder相遇。</p>
<h2 id="Android为什么使用Binder作为主要进程间通讯机制？"><a href="#Android为什么使用Binder作为主要进程间通讯机制？" class="headerlink" title="Android为什么使用Binder作为主要进程间通讯机制？"></a>Android为什么使用Binder作为主要进程间通讯机制？</h2><ol>
<li>安全性：Binder机制从协议本身就支持对通信双方做身份校检，安全性高。传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造</li>
<li>性能：socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信，Binder其实通过Binder驱动在内核区域进行了数据的传输，性能高</li>
</ol>
<h1 id="如何实现一个Binder通讯？"><a href="#如何实现一个Binder通讯？" class="headerlink" title="如何实现一个Binder通讯？"></a>如何实现一个Binder通讯？</h1><ol>
<li>在项目中新建一个aidl</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// IBookManager.aidl</span><br><span class="line"></span><br><span class="line">package com.jd.test.myapplication;</span><br><span class="line">import com.jd.test.myapplication.Book;</span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface IBookManager &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line"></span><br><span class="line">    List&lt;Book&gt; getBooks();</span><br><span class="line"></span><br><span class="line">    void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建一个在独立进程的Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.BookManagerService&quot;</span><br><span class="line">            android:process=&quot;:remote&quot;/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BookManagerService extends Service &#123;</span><br><span class="line">    private CopyOnWriteArrayList&lt;Book&gt; mBookList=new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        mBookList.add(new Book(1,&quot;Android&quot;));</span><br><span class="line">        mBookList.add(new Book(2,&quot;IOS&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Binder mBinder=new IBookManager.Stub()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public List&lt;Book&gt; getBooks() throws RemoteException &#123;</span><br><span class="line">            return mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>另外一个进程，启用远程的Service，并调用接口方法，进行通讯</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent=new Intent(this,BookManagerService.class);</span><br><span class="line">        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> private ServiceConnection mConnection=new ServiceConnection() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</span><br><span class="line">        IBookManager manager=IBookManager.Stub.asInterface(iBinder);</span><br><span class="line">         try &#123;</span><br><span class="line">             List&lt;Book&gt; books=manager.getBooks();</span><br><span class="line">             System.out.println(&quot;books:&quot;+books);</span><br><span class="line">         &#125; catch (RemoteException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onServiceDisconnected(ComponentName componentName) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 只能说so easy。Android提供了优秀的API，使得我们可以很方便的通过AIDL实现进程间的通讯。貌似我们实现了进程间通讯，但是连Binder的身影都没看到，这也就是上面的Binder对很多童鞋都很陌生的原因。</p>
<h1 id="Binder的原理"><a href="#Binder的原理" class="headerlink" title="Binder的原理"></a>Binder的原理</h1><p>我们定义了AIDI后，默认系统都会生成一个集成了IInterface的接口的类，eclipse默认是在gen目录下。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-54449047e423b0a3?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> * Original file: G:\\Source\\Demo\\MyApplication\\app\\src\\main\\aidl\\com\\jd\\test\\myapplication\\IBookManager.aidl</span><br><span class="line"> */</span><br><span class="line">package com.jd.test.myapplication;</span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface IBookManager extends android.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line">/** Local-side IPC implementation stub class. */</span><br><span class="line">public static abstract class Stub extends android.os.Binder implements com.jd.test.myapplication.IBookManager</span><br><span class="line">&#123;</span><br><span class="line">private static final java.lang.String DESCRIPTOR = &quot;com.jd.test.myapplication.IBookManager&quot;;</span><br><span class="line">/** Construct the stub at attach it to the interface. */</span><br><span class="line">public Stub()</span><br><span class="line">&#123;</span><br><span class="line">this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Cast an IBinder object into an com.jd.test.myapplication.IBookManager interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span><br><span class="line">public static com.jd.test.myapplication.IBookManager asInterface(android.os.IBinder obj)</span><br><span class="line">&#123;</span><br><span class="line">if ((obj==null)) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">if (((iin!=null)&amp;&amp;(iin instanceof com.jd.test.myapplication.IBookManager))) &#123;</span><br><span class="line">return ((com.jd.test.myapplication.IBookManager)iin);</span><br><span class="line">&#125;</span><br><span class="line">return new com.jd.test.myapplication.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br><span class="line">@Override public android.os.IBinder asBinder()</span><br><span class="line">&#123;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">switch (code)</span><br><span class="line">&#123;</span><br><span class="line">case INTERFACE_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">reply.writeString(DESCRIPTOR);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">case TRANSACTION_basicTypes:</span><br><span class="line">&#123;</span><br><span class="line">data.enforceInterface(DESCRIPTOR);</span><br><span class="line">int _arg0;</span><br><span class="line">_arg0 = data.readInt();</span><br><span class="line">long _arg1;</span><br><span class="line">_arg1 = data.readLong();</span><br><span class="line">boolean _arg2;</span><br><span class="line">_arg2 = (0!=data.readInt());</span><br><span class="line">float _arg3;</span><br><span class="line">_arg3 = data.readFloat();</span><br><span class="line">double _arg4;</span><br><span class="line">_arg4 = data.readDouble();</span><br><span class="line">java.lang.String _arg5;</span><br><span class="line">_arg5 = data.readString();</span><br><span class="line">this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">reply.writeNoException();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">case TRANSACTION_getBooks:</span><br><span class="line">&#123;</span><br><span class="line">data.enforceInterface(DESCRIPTOR);</span><br><span class="line">java.util.List&lt;com.jd.test.myapplication.Book&gt; _result = this.getBooks();</span><br><span class="line">reply.writeNoException();</span><br><span class="line">reply.writeTypedList(_result);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">case TRANSACTION_addBook:</span><br><span class="line">&#123;</span><br><span class="line">data.enforceInterface(DESCRIPTOR);</span><br><span class="line">com.jd.test.myapplication.Book _arg0;</span><br><span class="line">if ((0!=data.readInt())) &#123;</span><br><span class="line">_arg0 = com.jd.test.myapplication.Book.CREATOR.createFromParcel(data);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">_arg0 = null;</span><br><span class="line">&#125;</span><br><span class="line">this.addBook(_arg0);</span><br><span class="line">reply.writeNoException();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return super.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line">private static class Proxy implements com.jd.test.myapplication.IBookManager</span><br><span class="line">&#123;</span><br><span class="line">private android.os.IBinder mRemote;</span><br><span class="line">Proxy(android.os.IBinder remote)</span><br><span class="line">&#123;</span><br><span class="line">mRemote = remote;</span><br><span class="line">&#125;</span><br><span class="line">@Override public android.os.IBinder asBinder()</span><br><span class="line">&#123;</span><br><span class="line">return mRemote;</span><br><span class="line">&#125;</span><br><span class="line">public java.lang.String getInterfaceDescriptor()</span><br><span class="line">&#123;</span><br><span class="line">return DESCRIPTOR;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">@Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">try &#123;</span><br><span class="line">_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">_data.writeInt(anInt);</span><br><span class="line">_data.writeLong(aLong);</span><br><span class="line">_data.writeInt(((aBoolean)?(1):(0)));</span><br><span class="line">_data.writeFloat(aFloat);</span><br><span class="line">_data.writeDouble(aDouble);</span><br><span class="line">_data.writeString(aString);</span><br><span class="line">mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);</span><br><span class="line">_reply.readException();</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">_reply.recycle();</span><br><span class="line">_data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override public java.util.List&lt;com.jd.test.myapplication.Book&gt; getBooks() throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">java.util.List&lt;com.jd.test.myapplication.Book&gt; _result;</span><br><span class="line">try &#123;</span><br><span class="line">_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">mRemote.transact(Stub.TRANSACTION_getBooks, _data, _reply, 0);</span><br><span class="line">_reply.readException();</span><br><span class="line">_result = _reply.createTypedArrayList(com.jd.test.myapplication.Book.CREATOR);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">_reply.recycle();</span><br><span class="line">_data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">return _result;</span><br><span class="line">&#125;</span><br><span class="line">@Override public void addBook(com.jd.test.myapplication.Book book) throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">try &#123;</span><br><span class="line">_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">if ((book!=null)) &#123;</span><br><span class="line">_data.writeInt(1);</span><br><span class="line">book.writeToParcel(_data, 0);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">_data.writeInt(0);</span><br><span class="line">&#125;</span><br><span class="line">mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">_reply.readException();</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">_reply.recycle();</span><br><span class="line">_data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">static final int TRANSACTION_getBooks = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;</span><br><span class="line">public java.util.List&lt;com.jd.test.myapplication.Book&gt; getBooks() throws android.os.RemoteException;</span><br><span class="line">public void addBook(com.jd.test.myapplication.Book book) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类也就是我们在onServiceConnected中使用的接口。在这个IBookManager中我们有几个关键的类Stub、Proxy，也见到了久违的Binder。那么纠结Binder是怎么样来进行间通讯的呢？下面我们先通过一个示例图来简单描述一下该流程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ee815022cc036d97?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
<h2 id="IInterface结构分析"><a href="#IInterface结构分析" class="headerlink" title="IInterface结构分析"></a>IInterface结构分析</h2><p>首先变量DESCRIPTOR定义了接口和对应方法的唯一标示。因为Binder其实是一种底层的通讯方式，Google工程师将Binder包装成了一种对象的引用。所以这里的标识是告诉底层的Binder驱动，我的Binder引用标识，对应的方法标识。这样Binder驱动才能在进程间进行装换。</p>
<p>Proxy：实现了IBookManager接口，这个代理类是往Binder驱动里面写数据，通过调用Binder的transact方法往Binder驱动写Parcel数据。可以理解为告诉Binder驱动我们要调用什么方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br></pre></td></tr></table></figure></p>
<p>Stub：继承了Binder，实现了IBookManager接口。Binder驱动调用远程方法成功后，要回调告诉执行的结果。通过回调onTransact方法。将Binder驱动中的Parcel数据转换为我们的回调数据。</p>
<h2 id="IBinder引用是什么时候注册到了Binder驱动中呢？"><a href="#IBinder引用是什么时候注册到了Binder驱动中呢？" class="headerlink" title="IBinder引用是什么时候注册到了Binder驱动中呢？"></a>IBinder引用是什么时候注册到了Binder驱动中呢？</h2><p>我们知道Stub继承了Binder，那么当Stub实例化的时候，这个时候Binder无参构造被调用，执行了一个native 的init方法。这个时候向Binder驱动注册了IBinder的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Binder() &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Binder&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Binder class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private native final void init();</span><br></pre></td></tr></table></figure></p>
<h2 id="transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact"><a href="#transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact" class="headerlink" title="transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact"></a>transact方法（往Binder驱动写数据）最后调用为BinderProxy代理类的transact</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">     Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">     return transactNative(code, data, reply, flags);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">         int flags) throws RemoteException;</span><br></pre></td></tr></table></figure>
<h2 id="onTransact方法-（Binder驱动回调数据）"><a href="#onTransact方法-（Binder驱动回调数据）" class="headerlink" title="onTransact方法 （Binder驱动回调数据）"></a>onTransact方法 （Binder驱动回调数据）</h2><p>根据定义的常量标识，解析Parcel数据，回调本地方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">       public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">           switch (code) &#123;</span><br><span class="line">               case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                   reply.writeString(DESCRIPTOR);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               case TRANSACTION_basicTypes: &#123;</span><br><span class="line">                   data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                   int _arg0;</span><br><span class="line">                   _arg0 = data.readInt();</span><br><span class="line">                   long _arg1;</span><br><span class="line">                   _arg1 = data.readLong();</span><br><span class="line">                   boolean _arg2;</span><br><span class="line">                   _arg2 = (0 != data.readInt());</span><br><span class="line">                   float _arg3;</span><br><span class="line">                   _arg3 = data.readFloat();</span><br><span class="line">                   double _arg4;</span><br><span class="line">                   _arg4 = data.readDouble();</span><br><span class="line">                   java.lang.String _arg5;</span><br><span class="line">                   _arg5 = data.readString();</span><br><span class="line">                   this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                   reply.writeNoException();</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               case TRANSACTION_getBooks: &#123;</span><br><span class="line">                   data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                   java.util.List&lt;com.jd.test.myapplication.Book&gt; _result = this.getBooks();</span><br><span class="line">                   reply.writeNoException();</span><br><span class="line">                   reply.writeTypedList(_result);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               case TRANSACTION_addBook: &#123;</span><br><span class="line">                   data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                   com.jd.test.myapplication.Book _arg0;</span><br><span class="line">                   if ((0 != data.readInt())) &#123;</span><br><span class="line">                       _arg0 = com.jd.test.myapplication.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       _arg0 = null;</span><br><span class="line">                   &#125;</span><br><span class="line">                   this.addBook(_arg0);</span><br><span class="line">                   reply.writeNoException();</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return super.onTransact(code, data, reply, flags);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Binder应用层源码实现流程分析"><a href="#Binder应用层源码实现流程分析" class="headerlink" title="Binder应用层源码实现流程分析"></a>Binder应用层源码实现流程分析</h1><p>我们了解了Binder通讯的一些基础原理后，通过应用层的调用来追踪整个执行的流程。下面我们通过一个表格索引来描述Binder通讯的结构</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>调用的类间关系</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Activity：bindService</td>
<td>执行服务的绑定</td>
</tr>
<tr>
<td>2</td>
<td>Context：bindService</td>
<td>基类的的服务绑定抽象方法</td>
</tr>
<tr>
<td>3</td>
<td>ContextImpl：bindService</td>
<td>Context实现类的方法</td>
</tr>
<tr>
<td>4</td>
<td>ContextImpl:bindServiceCommon</td>
<td>进行一些Intent校验等，调用ActivityManagerNative.getDefault().bindService</td>
</tr>
<tr>
<td>5</td>
<td>ActivityManagerService:bindService</td>
<td>进行一些合法 非空的校验</td>
</tr>
<tr>
<td>6</td>
<td>ActiveServices:bindServiceLocked</td>
<td>创建Service，对服务进行缓存记录，同时回调了connection方法</td>
</tr>
<tr>
<td>7</td>
<td>ActiveServices：requestServiceBindingLocked</td>
<td>校验服务进程是否存在，调用ApplicationThread的scheduleBindService</td>
</tr>
<tr>
<td>8</td>
<td>ApplicationThread：scheduleBindService</td>
<td>ApplicationThread是ActivityThread的内部类，该方法发送了一个Message sendMessage(H.BIND_SERVICE, s);</td>
</tr>
<tr>
<td>9</td>
<td>ActiviThread：handleBindService</td>
<td>校验Service是否存在，执行AMS的publishService方法</td>
</tr>
<tr>
<td>10</td>
<td>ActivityManagerService：publishService</td>
<td>校验及调用ActiveServices的publishServiceLocked方法</td>
</tr>
<tr>
<td>11</td>
<td>ActiveServices：publishServiceLocked</td>
<td>执行Binder的restoreCallingIdentity方法</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>本文对Bidner做了一些整体的介绍，主要是基于应用层的流程进行分析，如果要彻底搞清楚Bidner，可能还需阅读Binder驱动的源码及Bidner的协议等</li>
<li>Binder在Android体系中，有着非常重要的地位，是核心的IPC方式。如果希望学习Android源码，Binder是一道需要越过去的坎。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/10/Android之Activity启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/Android之Activity启动流程/" itemprop="url">
                  Android之Activity启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T18:25:25+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/10/Android之Activity启动流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/10/Android之Activity启动流程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么要学习Android的源码"><a href="#为什么要学习Android的源码" class="headerlink" title="为什么要学习Android的源码"></a>为什么要学习Android的源码</h2><ol>
<li>学习优秀的代码，可能是进步最快的方式之一，特别是看一群优秀的Google开发工程师的代码。</li>
<li>知己知彼，了解系统的运行原理。在实际的项目开发中，解决一些疑难杂症，对于排障分析有很重要的意义。（开发中最怕就是特殊机型兼容，一些无日志的问题，这个时候只能靠经验来分析，熟悉系统的运行流程就显得很重要）</li>
<li>不要做一个只会堆砌API的工程师，否则无论3年或者5年，你始终会感觉到瓶颈的到来。其实换个角度学Android，例如源码分析、性能优化。你可能可以看到不一样的世界。</li>
</ol>
<h2 id="什么是Activity的启动流程"><a href="#什么是Activity的启动流程" class="headerlink" title="什么是Activity的启动流程"></a>什么是Activity的启动流程</h2><p>很多童鞋可能想，这还不简单，项目中用了千千万万遍了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(new Intent(this, Activity.class));</span><br></pre></td></tr></table></figure></p>
<p>只能说Too young,Too simple。</p>
<p>我一开始也以为只是简单调用个startActivity，然后屏幕就跳转到指定的Activity，这就是Activity的启动流程。</p>
<p>我们都知道Activity有一个栈，当我们按了back键的时候，就会回到上一个Activity。那么系统是如何来管理这个栈的呢？</p>
<p>我们从launcher点击一个应用图标，那么会启动一个新的进程，系统如何控制多进程之间的Activity切换呢？</p>
<p>我们都知道Activity有它自己的生命周期，那么这个生命周期在运行的过程中，系统是怎么去做控制的呢？</p>
<p>实际上问题远远不止这些，可见Activity的启动流程不是想象中的那么简单，所以为了找寻真相，我们需要从Android的源码来分析Activity的启动流程。</p>
<h1 id="Activity基础"><a href="#Activity基础" class="headerlink" title="Activity基础"></a>Activity基础</h1><p>这里我们先简单来了解一些我们开发项目过程中，常用的一些Activity的基础知识，然后后续才来进行源码的分析。在源码的分析中，我们也可以结合日常的使用来结合分析。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>这里使用Google官方的示例图来说明</p>
<p><img src="https://developer.android.google.cn/images/activity_lifecycle.png" alt="Google官方示例图"></p>
<ul>
<li><p>Activity 的整个生命周期发生在 onCreate() 调用与 onDestroy() 调用之间。您的 Activity 应在 onCreate() 中执行“全局”状态设置（例如定义布局），并释放 onDestroy() 中的所有其余资源。例如，如果您的 Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate() 中创建该线程，然后在 onDestroy() 中停止该线程。</p>
</li>
<li><p>Activity 的可见生命周期发生在 onStart() 调用与 onStop() 调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 onStop()。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 onStart() 中注册一个 BroadcastReceiver 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop() 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart() 和 onStop()。</p>
</li>
<li><p>Activity 的前台生命周期发生在 onResume() 调用与 onPause() 调用之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。</p>
</li>
</ul>
<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><ul>
<li>standard（默认模式）</li>
</ul>
<p>默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p>
<ul>
<li>singleTop</li>
</ul>
<p>如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。 </p>
<ul>
<li>singleTask</li>
</ul>
<p>系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。 </p>
<ul>
<li>singleInstance</li>
</ul>
<p>与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p>
<h2 id="运行状态保存"><a href="#运行状态保存" class="headerlink" title="运行状态保存"></a>运行状态保存</h2><p>这里同样借助Google官方的示例图来说明<br><img src="https://developer.android.google.cn/images/fundamentals/restore_instance.png" alt="Google官方示例图"></p>
<p>这个运行状态的保存，往往很容易在开发中被遗忘。如果不注意，却很容易引起一些程序的异常。首先，系统的运行的中，如果内存不足，会回收一些资源。再者，一些ROM会开启例如开发中选项中的不保留活动，当应用到后台时，则会被回收，或者屏幕旋转等一些配置变更。这些情况都需要我们处理好运行状态的保存。例如Viewpager保存好当前的tab位置，一些数据的保存和恢复，避免空指针等。</p>
<p>在界面被回收时，系统会先调用 onSaveInstanceState()，然后再使 Activity 变得易于销毁。系统会向该方法传递一个 Bundle，您可以在其中使用 putString() 和 putInt() 等方法以名称-值对形式保存有关 Activity 状态的信息。然后，如果系统终止您的应用进程，并且用户返回您的 Activity，则系统会重建该 Activity，并将 Bundle 同时传递给 onCreate() 和 onRestoreInstanceState()。您可以使用上述任一方法从 Bundle 提取您保存的状态并恢复该 Activity 状态。如果没有状态信息需要恢复，则传递给您的 Bundle 是空值</p>
<h1 id="源码相关类介绍"><a href="#源码相关类介绍" class="headerlink" title="源码相关类介绍"></a>源码相关类介绍</h1><p>过完了Activity的基础知识后，我们通过一个表格来分析一下Activity启动流程中核心的一些类的设计及作用，这样可以让我们更好的来了解启动的流程。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td>Activity 是一个应用组件，用户可与其提供的屏幕进行交互。</td>
</tr>
<tr>
<td>Instrumentation</td>
<td>每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。当ActivityThread需要操作Activity的生命周期，都是通过Instrumentation来完成，实际Activity的实例化，也是在里面的newActivity完成。</td>
</tr>
<tr>
<td>ActivityManagerService</td>
<td>AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作</td>
</tr>
<tr>
<td>PackageManagerService</td>
<td>Android系统下的apk程序都是通过名为PackageManagerService的包管理服务来管理的。PacketManagerService是安卓系统的一个重要服务，由SystemServer启动，主要实现apk程序包的解析，安装，更新，移动，卸载等服务。不管是系统apk(/system/app)，还是我们手工安装上去的，系统所有的apk都是由其管理</td>
</tr>
<tr>
<td>ActivityStackSupervisor</td>
<td>主要是对整个APP的Task进行管理，通常一个进程拥有一个或多个Task</td>
</tr>
<tr>
<td>ActivityStack</td>
<td>传说中的Activity栈，我们都知道Activity的管理就是通过栈管理，默认显示栈顶，当按back键后，就将栈顶的Activity移除，遵循后进先去原则</td>
</tr>
<tr>
<td>ActivityRecord</td>
<td>ActivityRecord 是Activity的标识，与每个Activity是一一对应的，存储这Activity的一些信息，便于后续操作Activity </td>
</tr>
<tr>
<td>ActivityThread</td>
<td>传说中的UI线程， 它管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，并根据AMS的要求（通过IApplicationThread接口）负责调度和执行activities、broadcasts和其它操作</td>
</tr>
</tbody>
</table>
<h1 id="源码启动流程分析"><a href="#源码启动流程分析" class="headerlink" title="源码启动流程分析"></a>源码启动流程分析</h1><p>Activity的源码启动流程，其实一开始想试试用流程图来说明，但最后发现实在太长，欲生欲死。下面我们同样通过表格，以序号的方式来一步步显示Activity启动流程。这个可以更清晰便捷的来理解。具体的关键实现源码会在说明中分析，可以自己在结合源码进行分析。</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>调用的类间关系</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Activity：startActivity-&gt;startActivityForResult</td>
<td>startActivity其实最终也是调用了startActivityForResult</td>
</tr>
<tr>
<td>2</td>
<td>Intrumentation：execStartActivity</td>
<td>mInstrumentation类似与管家婆，ActivityThread与AMS交互后，最后都是交由Intrumentation来处理</td>
</tr>
<tr>
<td>3</td>
<td>ActivityManagerNative.getDefault().startActivity(AIDL)-&gt;最后执行到AMS的startActivity</td>
<td>这是一个IPC的过程</td>
</tr>
<tr>
<td>4</td>
<td>AMS：startActivityAsUser</td>
<td>生成了userId</td>
</tr>
<tr>
<td>5</td>
<td>ActivityStackSupervisor：startActivityMyWait()</td>
<td>校验Intent的一些合法性,其中调用了PackageManagerService的resolveIntent</td>
</tr>
<tr>
<td>6</td>
<td>ActivityStackSupervisor：startActivityLocked()</td>
<td>验证intent、Class、Permission等保存将要启动的Activity的Record</td>
</tr>
<tr>
<td>7</td>
<td>ActivityStackSupervisor：startActivityUncheckedLocked()</td>
<td>检查将要启动的Activity的launchMode和启动Flag根据launcheMode和Flag配置task</td>
</tr>
<tr>
<td>8</td>
<td>ActvityStack：startActivityLocked</td>
<td>对栈进行初始化配置</td>
</tr>
<tr>
<td>9</td>
<td>ActivityStack： resumeTopActivityInnerLocked()</td>
<td>查找需要进入onPause的Activity</td>
</tr>
<tr>
<td>10</td>
<td>ActivityStack：startPausingLocked()</td>
<td>IPC，控制将需要OnPause的Activity进行暂停</td>
</tr>
<tr>
<td>11</td>
<td>ActivityThread： handlePauseActivity()</td>
<td>回调Activity的onPause，并通知AMS</td>
</tr>
<tr>
<td>12</td>
<td>ActivityManagerService:activityPaused()</td>
<td>获取对应的栈，执行activityPausedLocked</td>
</tr>
<tr>
<td>13</td>
<td>ActivityStack：activityPausedLocked</td>
<td>获取ActivityRecord，调用completePauseLocked</td>
</tr>
<tr>
<td>14</td>
<td>ActivityStackSuperVisor： resumeTopActivitiesLocked()</td>
<td>找出当前自己管理的task的栈，执行resumeTopActivityLocked</td>
</tr>
<tr>
<td>15</td>
<td>ActivityStack：resumeTopActivityLocked()</td>
<td>调用ActivityStackSuperVisor：resumeTopActivityInnerLocked验证是否该启动的Activity所在进程和app是否存在，若存在，直接启动。否则，准备创建该进程</td>
</tr>
<tr>
<td>16</td>
<td>ActivityStackSuperVisor：startSpecificActivityLocked()</td>
<td>该进程不存在，创建进程</td>
</tr>
<tr>
<td>17</td>
<td>ActivityManagerService：startProcessLocked()</td>
<td>通过Process.start()启动进程 entryPoint = “android.app.ActivityThread”</td>
</tr>
<tr>
<td>18</td>
<td>ActivityThread：main()</td>
<td>主线程的Looper也在这里初始化，这里是我们应用层的主入口。</td>
</tr>
<tr>
<td>19</td>
<td>ActivityThread：attach</td>
<td>调用attachApplication()</td>
</tr>
<tr>
<td>20</td>
<td>IActivityManager：attachApplication()</td>
<td>调用attachApplicationLocked，我们的Application也会在这个地方来创建</td>
</tr>
<tr>
<td>21</td>
<td>ActivityStackSuperVisor：attachApplicationLocked()</td>
<td>通过ActivityRecord找出具体的栈</td>
</tr>
<tr>
<td>22</td>
<td>ActivityStackSuperVisor：realStartActivityLocked()</td>
<td>IPC通知ActivityThread </td>
</tr>
<tr>
<td>23</td>
<td>ActivityThread：scheduleLaunchActivity()</td>
<td>通过handler调用handleLaunchActivity,接着performLaunchActivity</td>
</tr>
<tr>
<td>24</td>
<td>ActivityThread：接着performLaunchActivity</td>
<td>进行了一些Avcitity的状态判断，执行了mInstrumentation.newActivity。Activity对象真正通过反射实例化出来</td>
</tr>
<tr>
<td>25</td>
<td>Intrumentation：callActivityOnCreate</td>
<td>调用了Activity的onCreate</td>
</tr>
</tbody>
</table>
<p>过完一遍，反正欲生欲死了。觉得不是当初想象的那么简单。过源码，我们尽量保持流程性上的理解吧，如果纠结于实现的细节，反倒会适得其反，不可自拔。通过流程上的梳理，来理解设计的精髓。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>Android源码中大量使用了Service的思想。提供统一的服务，这样使得系统可以统一来调用一些任务。为什么这里的Activity启动要设计得如此的复杂？因为系统需要统一管理窗口的显示，这里涉及多进程、多窗口的管理控制。</li>
<li>单一责任原则。这个是设计模式里面的东西。不同的功能让不同的类来实现，减低耦合性。例如这里的ActivityStackSupervisor用来管理Task,ActivityStack用来管理栈。而不会将所有的东西都塞在Activity中</li>
<li>模块化思想。系统的各种Service其实很好的体现了这一点。AMS管理Activity，WMS管理窗口，PMS管理安装包，还有例如网络、电量等的管理都一致。这样使得系统逻辑更加清晰，便于维护管理及使用</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/04/01/“Android性能优化-渲染优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/“Android性能优化-渲染优化/" itemprop="url">
                  Android性能优化-渲染优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T19:32:43+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/01/“Android性能优化-渲染优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/01/“Android性能优化-渲染优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们在开发的过程中，可能经常会遇到测试的一些反馈，就是APP运行卡顿的问题。我们通常所讲的卡顿问题都是因为渲染掉帧的问题引起视觉上的卡顿感。所以了解渲染机制，我们在项目的开发过程中，可以有意识的少挖坑。同时要打造一款精品的应用，注意渲染优化也是非常重要的一件事情。</p>
<p>当然目前我们好多同学在开发的工程中，经常会忽略渲染优化这一块，主要的原因可能是</p>
<ul>
<li>项目没要求，能满足功能则可</li>
<li>缺少意识，没有做性能优化的意识</li>
<li>缺少用工具分析，主观感受不强</li>
<li>需求的苦海，无法脱身(有多少童鞋戳中泪点)</li>
</ul>
<p>不管如何，我们都需要对自己有所要求。尽量在开发的过程中注意，少挖坑。对已上线的项目能够进行优化分析，打造精品。<br>接下来我们将介绍渲染的底层机制，并针对性地进行优化分析。</p>
<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><h2 id="视觉感官"><a href="#视觉感官" class="headerlink" title="视觉感官"></a>视觉感官</h2><p>我们都可能听过Android的屏幕刷新频率是60fps 也就是16ms需要完成一帧的刷新。</p>
<p>首先我们理解一下帧的概念。<br>每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象，因此高的帧率可以得到更流畅、更逼真的动画。</p>
<p>当物体在快速运动时, 当人眼所看到的影像消失后，人眼仍能继续保留其影像1/24秒左右的图像，这种现象被称为视觉暂留现象。是人眼具有的一种性质。人眼观看物体时，成像于视网膜上，并由视神经输入人脑，感觉到物体的像。但当物体移去时，视神经对物体的印象不会立即消失，而要延续1/24秒左右的时间，人眼的这种性质被称为“眼睛的视觉暂留”。</p>
<p>所以以前我们看胶卷电影的时候刷新的频率就是24fps。我们看起来就是连续的一个视觉效果。当然这里越高的帧率，我们可以得到更流畅、逼真的画面。</p>
<h2 id="VSYNC"><a href="#VSYNC" class="headerlink" title="VSYNC"></a>VSYNC</h2><p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。如果超过了16ms那么可能就出现丢帧的情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ef657df135a35dd4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google性能优化示例图"></p>
<p>VSYNC有两个概念</p>
<ol>
<li>Refresh Rate：屏幕在一秒时间内刷新屏幕的次数—-由硬件的参数决定，比如60HZ.</li>
<li>Frame Rate：GPU在一秒内绘制操作的帧数，比如：60fps。</li>
</ol>
<p>通常来说，帧率超过刷新频率只是一种理想的状况，在超过60fps的情况下，GPU所产生的帧数据会因为等待VSYNC的刷新信息而被Hold住，这样能够保持每次刷新都有实际的新的数据可以显示。但是我们遇到更多的情况是帧率小于刷新频率。在这种情况下，某些帧显示的画面内容就会与上一帧的画面相同,造成卡顿的现象。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-e23209efde68a709?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google性能优化示例图">    </p>
<p>简单来说，VSYNC也叫垂直刷新，是一个信号。会触发渲染。这个过程需要我们屏幕的刷新频率（一般60fps）和我们GPU所产生的帧数能够进行同步，那么UI的渲染就能流畅。如果我们自己定义的布局或者自定义控件的渲染时间超过了16ms每帧，那么就可能导致屏幕刷新的时候，我们的GPU还不能产生新的帧，用户看的还是旧的帧。这就造成了我们视觉上的卡顿，影响用户体验。</p>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>我们定义好了一个xml的布局界面后，是怎样最终呈现在我们的手机屏幕上的呢？</p>
<p>这里我们借助Google官方的性能优化的一张示例图来说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-03bcc5a5b347a429?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google性能优化示例图"></p>
<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。最终在屏幕进行显示。</p>
<p>这个地方CPU主要是将我们的布局文件的View Tree进行测量和绘制，最后形成Ploygons（多边形）及Texture(纹理贴图)</p>
<p>栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作</p>
<p>Android在性能优化已经做了很多工作。在CPU将Ploygons和Texture传递到GPU是一个很耗时的过程。所以Android将Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到 GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。</p>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<p>项目里曾经遇到一个问题，对一个图标染色了。然后其他使用到改图标的地方也同样变成染色后的图标了。这个地方就是因为GPU有缓存的缘故。还有遇到过另外一个坑就是染色后的图标再红米的一个手机上无效，估计这个地方不同的硬件缓存的机制可能还不一样。所以如果项目中有用到图标的染色需要注意。</p>
</blockquote>
<h1 id="如何在我们的项目中进行渲染优化？"><a href="#如何在我们的项目中进行渲染优化？" class="headerlink" title="如何在我们的项目中进行渲染优化？"></a>如何在我们的项目中进行渲染优化？</h1><p>知道了我们的渲染的机制，我们知道整一个渲染的的流程，基本都是系统在处理，流程我们没办法进行干预。那么我们就需要针对渲染的原理，进行一些针对性的优化操作，减少我们每一帧的渲染时间，使应用更加流畅。所以平时除了我们都知道的阻塞UI线程导致卡顿，其实对于CPU及内存的不合理使用，也同样会造成我们的卡顿。接下来我们来一一进行分析。</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>程序在任意帧内执行GCs所用的时间越多，消除少于16毫秒的呈像障碍，所必需的时间就会变少，如果有许多GCs或一大串指令一个接一个地操作，帧象时间很可能会超过16毫秒的呈像障碍，这会导致隐形的碰撞或闪躲。内存在断时间的抖动也会造成我们的卡顿现象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-8592a54d9b74875e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>所以如果要减少任意帧内启动GC的次数，需要着重优化程序的内存使用量。</p>
<p>我们在实际的项目中了已通过Monitor进行内存的抖动分析，再通过分析源码来看是否在某一时刻重复创建大量的对象，导致GC的回收。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-11efe079fc9a8412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<ol>
<li>避免在循环里面重复创建对象</li>
<li>操作大量的字符，慎用String进行+=，多使用StringBuilder及StringBuffer</li>
<li>多用池进行进行对象的复用</li>
</ol>
</blockquote>
<h2 id="计算优化"><a href="#计算优化" class="headerlink" title="计算优化"></a>计算优化</h2><p>这是一个很浅显的道理，我们知道渲染的过程需要CPU参与Ploygons与Texture的生成，假如我们将CPU的使用率长时间压榨得很高，自然就会影响我们的渲染，造成UI卡顿。</p>
<p>那么怎么来分析我们的计算优化呢？</p>
<p>首先一个很简单，可以看看是否在执行某个操作的时候，过分的压榨了CPU的使用率，我们通过Android Monitor可以看到瞬时的CPU的使用率。<br>观察到CPU使用率的异常后，我们可以通过Traceview工具来查找并确定哪些是阻碍应用程序性能问题的代码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-0fa395db766a1fbc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>同样开DDMS视图选择我们要分析的应用，这里箭头所指向看上去像是三面箭头，上面有红色的圆点，如果按这些按钮，会出现一些提示，说将开始进行方法分析。这是TraceView的启动方法，我们点击它。将出现一个弹出窗口，提示有两种方法来分析你的应用程序。你可以记录每个方法的输入和输出，他们对资源的要求很高，或者，你也利用示例进行一些分析。其含义是，默认情况下分析程序，将会每1000毫秒侦测一次你的应用程序，以发现和记录实际上在运行的功能，现在，让我们来使用这些默认设置。我点击一下OK，既然分析程序已经在继续，我们就与你的应用程序进行交互，看能否记录一些动作。</p>
<p>我们来看跟踪视图，跟踪视图有两个主要组成部分。上方窗格的名称是timeline面板，下方窗格内有很多的信息，称为profile面板。这个时间线能够很好的显示代码的执行情况，这里显示的每一行，实际上对应于一个线程。显示的每一个颜色，对应于一个正在运行的特定方法。例如，我们可以看到，主线程的所有活动，我们可以看到方法启动和停止时间点，更有用的是放大这里，找到特定的方法，了解他们是如何执行的。它们会以这种U型模式显示出来。这里的条形表示，方法的启动时间。右侧的条形表示，方法的停止时间。条形的宽度表示方法执行所用的时间。现在，我们选择一个特定的方法，我们跳转到跟踪视图窗口的底部，这里，我们看到一些分析数据显示出来。我们可以看到哪些方法调用了我们选定的方法。</p>
<p>底部面板的一些字段含义如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>该进程运行过程中所调用的函数名</td>
</tr>
<tr>
<td>Incl Cpu Time</td>
<td>函数占用的CPU时间，包含内部调用其它函数的CPU时间</td>
</tr>
<tr>
<td>Excl Cpu Time</td>
<td>函数占用的CPU时间，但不包含内部调用其它函数所占用的CPU时间</td>
</tr>
<tr>
<td>Incl Real Time</td>
<td>函数运行的真实时间（以毫秒为单位），内含调用其它函数所占用的真实时间</td>
</tr>
<tr>
<td>Excl Real Time</td>
<td>函数运行的真实时间（以毫秒为单位），不包含调用其它函数所占用的真实时间</td>
</tr>
<tr>
<td>Calls+Recur Calls/Total</td>
<td>函数被调用次数以及递归调用占总调用次数的百分比</td>
</tr>
<tr>
<td>Cpu Time/Call</td>
<td>函数调用CPU时间与调用次数的比（该函数平均执行时间）</td>
</tr>
<tr>
<td>Real Time/Call</td>
<td>同CPU Time/Call类似，只不过统计单位换成了真实时间</td>
</tr>
</tbody>
</table>
<h4 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<ol>
<li>优化一些计算的算法,例如递归等</li>
<li>使用线程池技术，避免过度压榨CPU</li>
<li>使用批处理及缓存，优化CPU计算</li>
</ol>
</blockquote>
<h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>我们知道CPU在渲染的过程，主要需要处理Ploygons和Texture。在CPU方面，最常见的性能问题是不必要的布局和失效，这些内容必须在视图层次结构中进行测量、清除并重新创建，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘，这两个原因在更新显示列表或者其他缓存GPU资源时导致CPU工作过度。<br>引用Google官方示例图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-9e4fc92004fcef5e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google性能优化示例图"></p>
<p>所以我们需要进行优化的点有：</p>
<ol>
<li>减少不必要布局元素</li>
<li>减少过多的布局嵌套</li>
</ol>
<p>那么如何来知道，我们的布局是否因为CPU过度工作导致我们的渲染卡顿呢？<br>我们可以通过DDMS里面的Hierarchy Viewer 来进行我们的布局分析。</p>
<p>1）通过AS的Tools-Android-Android Device Monitor调起</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6f9f35cb1191232d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这个时候APP运行到我们需要检测的界面，这个点击蓝色的按钮，就可以显示当前界面的View Tree</p>
<p>2)我们可以通过图2箭头指向来观察我们的View布局、绘制、渲染的时间<br><img src="http://upload-images.jianshu.io/upload_images/5125122-9e2007855c88a653?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>箭头1为我们当前View节点的界面，我们可以观察当前节点的渲染时间</li>
<li>箭头2为触发检测渲染性能的按钮</li>
<li>箭头3为渲染性能的显示，有绿、黄、红三种颜色</li>
</ul>
<p>三个圆点分别代表：测量、布局、绘制三个阶段的性能表现。</p>
<ol>
<li>绿色：渲染的管道阶段，这个视图的渲染速度快于至少一半的其他的视图。</li>
<li>黄色：渲染速度比较慢的50%。</li>
<li>红色：渲染速度非常慢。</li>
</ol>
<p>所以我们可以根据分析查看自己的布局，层次是否很深以及渲染比较耗时，然后想办法能否减少层级以及优化每一个View的渲染时。</p>
<h4 id="Tip-3"><a href="#Tip-3" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<ol>
<li>避免过来无用的布局嵌套，特别是ViewGroup层级尽量最小化</li>
<li>使用<merge>标签，减少布局嵌套</merge></li>
<li>使用懒加载布局 ViewStub，尽量减少使用View的GONE方式</li>
<li>注意一些自定义的View的性能，可通过工具的绿黄红分析</li>
</ol>
</blockquote>
<h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>通过上面的流程我们知道，GPU主要干的事情就是栅格化，所以我们需要尽量尽量避免过度绘制（overdraw）。</p>
<p>我们在开发的过程中,经常会遇到牛逼的设计，需要完善绚丽的UI。高性能和完美的设计，往往会碰到一种性能问题，即过度绘制。过度绘制是一个术语，指的是屏幕上的某个像素点在同一帧的时间内被绘制了多次。假如我们有一堆重叠的UI卡片，最接近用户的卡片在最上面，其余卡片都藏在下面，也就是说我们花大力气绘制的那些下面的卡片基本都是不可见的。</p>
<p>我们借助Google官方的一个图来进行说明</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-7ad0ae5b35a74451?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google性能优化示例图"></p>
<p>Android在屏幕上使用不同颜色，标记过度绘制的区域，如果某个像素点只渲染了一次，我们看到的是它原来的颜色，随着过度绘制的增多，标记颜色也会逐渐加深，例如1倍过度绘制会被标记为蓝色，2倍、3倍、4倍过度绘制遵循同样的模式。所以当我们调试应用程序的用户界面时，目标就是尽可能的减少过度绘制，将红色区块转变成蓝色区块。</p>
<p>1）通过开发者选项打开过度绘制检测</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-c72f08897b8fb597?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>2)开启后就可以查看应用的绘制情况</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-674fcf10291d7813?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这里拿了百度网盘来做例子，还是优化得不错。</p>
<p>首先我们要从视图中清除那些，不必要的背景和图片，他们不会在最终渲染图像中显示，这些都会影响性能。其次，对视图中重叠的屏幕区域进行定义，从而降低CPU和GPU的消耗。</p>
<h4 id="Tip-4"><a href="#Tip-4" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<ol>
<li>由于我们布局设置了背景，同时用到的MaterialDesign的主题会默认给一个背景。可以在Activity设置getWindow().setBackgroundDrawable(null);</li>
<li>尽量保持你的布局只有一层拥有Background，避免给过多的ViewGroup设置背景</li>
<li>如果是自定义控件可以通过裁剪来处理（Canvas.clipRect）。</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>尽量了解渲染的机制，在开始做项目的时候就少挖坑</li>
<li>尽量动手给自己现在的项目进行优化，这样可以更深刻的理解</li>
<li>渲染优化是一个苦逼的体力活，掌握了方法以后，我们需要花时间去一个个调优</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/22/Android性能优化-内存泄漏（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/22/Android性能优化-内存泄漏（下）/" itemprop="url">
                  Android性能优化-内存泄漏（下）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T10:29:02+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/22/Android性能优化-内存泄漏（下）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/22/Android性能优化-内存泄漏（下）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何进行内存泄漏的分析"><a href="#如何进行内存泄漏的分析" class="headerlink" title="如何进行内存泄漏的分析"></a>如何进行内存泄漏的分析</h1><h2 id="使用Android-Studio-Monitors"><a href="#使用Android-Studio-Monitors" class="headerlink" title="使用Android Studio  Monitors"></a>使用Android Studio  Monitors</h2><p>AndroidMonitors是Android Studio自带的功能，我们可以通过里面的Memory模块来进行内存泄漏的分析，平时开发我们也可以通过该模块来观察内存的抖动情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-16714b3ef941e1b6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这里我们首先知道，标注1是进行GC的操作，标注2是进行Dump操作，也就是可以生成我们瞬时的堆内存快照，我们主要也是通过分析堆内存的快照来进行内存泄漏分析。<br>一般我们先进行几次gc操作，待内存平稳后，执行dump操作。会生成一个phrof的内存快照</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB0621ed808d662b530f710a7b94838ed4?method=download&amp;shareKey=25da5526e52b0833c0b282887d70aeec" alt></p>
<p>此时我们可以看到几个面板：</p>
<ol>
<li>ClassName：堆内存中存在的类</li>
<li>Instaance：类存在的实例</li>
<li>ReferenceTree：持有该类的引用</li>
</ol>
<p>几个属性的含义：</p>
<ol>
<li>Depth:引用的层级</li>
<li>Shallow Size:对象的大小（Byte）</li>
<li>Dominating Size:释放该对象能节省的堆内存（Byte）</li>
</ol>
<p>将快照转换为Mat能够导入的格式<br>在as的captures中可以右键选择export to standard  .hprof 将快照转换为mat能够带入的文件格式</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6e9e7d2b51e0d4ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="使用MAT"><a href="#使用MAT" class="headerlink" title="使用MAT"></a>使用MAT</h2><p>MAT是一款功能更强大的内存泄漏分析工具，在实际的内存分析中，我们可以结合Monitors进行内存泄漏分析。</p>
<p><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">下载地址http://www.eclipse.org/mat/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-8ba2a74943e4efaa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>导入快照后，我们可以通过Histogram查看内存快照<br><img src="http://note.youdao.com/yws/api/personal/file/WEB8211d428e66bc581253f74e28ee78f78?method=download&amp;shareKey=7b8c7db3758507fb6f409e66aba03f23" alt></p>
<p>在Histogram中，我们可以通过筛选过滤出我们项目中的包和类，这个操作实际中很有用。</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB12eff1828f48890b194fdec8b247ff20?method=download&amp;shareKey=f417238f179bd1c6621097f153512d5d" alt></p>
<p>选中具体的对象后，右键list objects–with incoming references可以查看对改对象持有的应用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-a1edb426316f38ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>我们可以看到，这个时候引用还是非常的，我们需要过滤一些无用的软引用之类的。通过右键-megre shortest path to GC roots-exclude all phantom/sofe/weak etc.refrences进行过滤,这个时候基本就能查出我们自己写的代码的引用</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB613af7e59acfc2bbc08ca85504030f81?method=download&amp;shareKey=c60166a7574820f768b041b480bb98e9" alt></p>
<p>另外Mat还支持2个快照进行比对，这个功能也是非常有用的。<br>我们可以在Navigation History中选择 Histogram，然后右键选择Add to compare basket加入比较选项，将2个快照的Histogram加入后在compare basket栏中点击红色感叹号就可以执行快照的比对。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5ab78b29c0689fdc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="使用leakcanary"><a href="#使用leakcanary" class="headerlink" title="使用leakcanary"></a>使用leakcanary</h2><p>Square开源了一个内存泄露自动探测神器——LeakCanary，它是一个Android和Java的内存泄露检测库，可以大幅度减少了开发中遇到的OOM问题。</p>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">github https://github.com/square/leakcanary</a></p>
<p>通过官方的文档介绍，我们可以轻松在项目集成</p>
<p>加入依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos;</span><br><span class="line">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</span><br><span class="line">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Application 配置:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  //在自己的Application中添加如下代码</span><br><span class="line">public static RefWatcher getRefWatcher(Context context) &#123;</span><br><span class="line">    ExampleApplication application = (ExampleApplication) context</span><br><span class="line">            .getApplicationContext();</span><br><span class="line">    return application.refWatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //在自己的Application中添加如下代码</span><br><span class="line">private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    ......</span><br><span class="line">        //在自己的Application中添加如下代码</span><br><span class="line">    refWatcher = LeakCanary.install(this);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 RefWatcher 监控那些本该被回收的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</span><br><span class="line">    refWatcher.watch(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 最后如果有内存泄漏，会接收到相应的推送。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-8884ec7e4a009422?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这样我们就能在编码的阶段，尽量的避免出现内存泄漏的情况。</p>
<h2 id="如何对自己的项目进行内存泄漏分析"><a href="#如何对自己的项目进行内存泄漏分析" class="headerlink" title="如何对自己的项目进行内存泄漏分析"></a>如何对自己的项目进行内存泄漏分析</h2><p>上面说了这么多，怎么来对我们自己的项目进行内存泄漏的分析呢？</p>
<p>一般我们都是在不知道项目中那里有存在内存泄漏的情况下，怎么来查找出那个地方出现了内存泄漏？</p>
<p>这里我们主要检查Activity及Fragment的内存泄漏情况。</p>
<p>使用Memory Usage查看Activity及Fragment的内存泄漏情况，首先先运行自己项目到MainActivity，观察 Menory Usage。</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB7ec616be1982e225160c263823001c54?method=download&amp;shareKey=c90694f64906445c1d63fbc13114072b" alt></p>
<p>待gc内存稳定后，我们可以执行一些操作，如进入其他的Activity执行其他操作，然后 检测内存的抖动情况及gc稳定后，内存与初始内存的对比。</p>
<p>这里我使用开启不保留活动来模拟MainActivity的异常退出及恢复。继续看Menory Usage。<br><img src="http://note.youdao.com/yws/api/personal/file/WEB774b02e733d81a05f918c4ee11a34dbd?method=download&amp;shareKey=624484855f442464e7e67299fb762225" alt><br>这个时候，我只有在MainActivity出现过， 理论上应当只有一个MainActivity的实例，这个地方就是一个值得怀疑的内存泄漏的点。这个时候我们就可以通过Mioniter和Mat进行内存分析</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-34e698b3baf98a80?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这个时候我们可以看到引用的的可怀疑对象，接着我们就进入源码分析。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-1f1856e3fc019bb2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>果然这里有一个单例持有了MainActivity的使用。</p>
<p>分析内存泄漏是一个体力活，我们大概在项目中主要要记住。</p>
<ol>
<li><p>使用leakcanary 在编码阶段进行检测</p>
</li>
<li><p>结合内存抖动及Memory Usage 检查Activity及Fragment的的泄漏情况</p>
</li>
<li><p>使用Monitor及Mat进行引用持有分析找出怀疑的对象</p>
</li>
<li><p>分析源代码，找到元凶</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/22/Android性能优化-内存泄漏（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/22/Android性能优化-内存泄漏（上）/" itemprop="url">
                  Android性能优化-内存泄漏（上）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T10:28:54+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/22/Android性能优化-内存泄漏（上）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/22/Android性能优化-内存泄漏（上）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要做性能优化？"><a href="#为什么要做性能优化？" class="headerlink" title="为什么要做性能优化？"></a>为什么要做性能优化？</h1><ol>
<li><p>手机性能越来越好，不用纠结这些细微的性能？</p>
<ul>
<li><p>Android每一个应用都是运行的独立的Dalivk虚拟机，根据不同的手机分配的可用内存可能只有（32M、64M等），所谓的4GB、6GB运行内存其实对于我们的应用不是可以任意索取</p>
</li>
<li><p>优秀的算法与效率低下的算法之间的运行效率要远远超过计算机硬件的的发展，虽然手机单核、双核到4核、8核的发展，但性能优化任然不可忽略</p>
</li>
</ul>
</li>
<li><p>手机应用一般使用的周期比较短，用完就关了。不像服务器应用要长年累月运行，似乎影响不大？</p>
<ul>
<li>现在一般的用户都不会重启手机，可能一个月都不会重启。像微信这样的APP，每天都在使用。如果一旦发生内存泄漏，那么可能一点一点的累积，程序就会出现OOM。</li>
</ul>
</li>
<li><p>等应用出现卡顿、发烫等，再来关注性能优化？</p>
<ul>
<li>似乎是没错的。现在一般我们也都是等出现问题了再来找原因。但是学好性能优化的目的不仅仅如此，我们在编码阶段就应该从源头来杜绝一些坑，这样的成本比后期再来寻找原因要少得多</li>
</ul>
<p>所以为了我们的应用的健壮性、有良好的用户体验。性能优化技术，需要我们用心去研究和应用。</p>
</li>
</ol>
<h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><h2 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-27e80eb1c5c73953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>Java采用GC进行内存管理。深入的JVM内存管理知识，推荐《深入理解Java虚拟机》。关于内存泄漏我们要知道，JVM内存分配的几种策略。</p>
<ol>
<li><p>静态的</p>
<p> 静态的存储区，内存在程序编译的时候就已经分配好了，这块内存在程序整个运行期间都一直存在，它主要存放静态数据、全局的static数据和一些常量。</p>
</li>
<li><p>栈式的</p>
<p> 在执行方法时，方法一些内部变量的存储都可以放在栈上面创建，方法执行结束的时候这些存储单元就会自动被注释掉。栈 内存包括分配的运算速度很快，因为内在在处理器里面。当然容量有限，并且栈式一块连续的内存区域，大小是由操作系统决定的，他先进后 出，进出完成不会产生碎片，运行效率高且稳定</p>
</li>
<li><p>堆式的</p>
<p> 也叫动态内存 。我们通常使用new 来申请分配一个内存。这里也是我们讨论内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。堆内存是一块不连续的内存区域，如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能</p>
</li>
</ol>
<p>我们知道可以调用 System.gc();进行内存回收，但是GC不一定会执行。面对GC的机制，我们是否无能为力？其实我们可以通过声明一些引用标记来让GC更好对内存进行回收。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>回收时机</th>
<th>生命周期</th>
</tr>
</thead>
<tbody>
<tr>
<td>StrongReference （强引用）</td>
<td>任何时候GC是不能回收他的，哪怕内存不足时，系统会直接抛出异常OutOfMemoryError，也不会去回收</td>
<td>进程终止</td>
</tr>
<tr>
<td>SoftReference （软引用）</td>
<td>当内存足够时不会回收这种引用类型的对象，只有当内存不够用时才会回收</td>
<td>内存不足，进行GC的时候</td>
</tr>
<tr>
<td>WeakReference （弱引用）</td>
<td>GC一运行就会把给回收了</td>
<td>GC后终止</td>
</tr>
<tr>
<td>PhantomReference  (虚引用)</td>
<td>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收</td>
<td>任何时候都有可能</td>
</tr>
</tbody>
</table>
<p>开发时，为了防止内存溢出，处理一些比较占用内存并且生命周期长的对象时，可以尽量使用软引用和弱引用。</p>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<p>成员变量全部存储在堆中（包括基本数据类型，引用及引用的对象实体），因为他们属于类，类对象最终还是要被new出来的</p>
</blockquote>
<blockquote>
<p>局部变量的基本数据类型和引用存在栈中，应用的对象实体存储在堆中。因为它们属于方法当中的变量，生命周期会随着方法一起结束</p>
</blockquote>
<h2 id="内存泄漏的定义"><a href="#内存泄漏的定义" class="headerlink" title="内存泄漏的定义"></a>内存泄漏的定义</h2><p>当一个对象已经不需要使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用，从而导致了对象不能被GC回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏</p>
<h2 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h2><ul>
<li><p>内存泄漏（Memory Leak）<br>  进程中某些对象已经没有使用的价值了，但是他们却还可以直接或间接地被引用到GC Root导致无法回收。当内存泄漏过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM</p>
</li>
<li><p>内存溢出（OOM）<br>  当 应用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出</p>
</li>
</ul>
<h2 id="内存泄漏带来的影响"><a href="#内存泄漏带来的影响" class="headerlink" title="内存泄漏带来的影响"></a>内存泄漏带来的影响</h2><ul>
<li><p>应用卡顿<br>  泄漏的内存影响了GC的内存分配，过多的内存泄漏会影响应用的执行效率    </p>
</li>
<li><p>应用异常（OOM）<br>  过多的内存泄漏，最终会导致 Dalvik分配的内存，出现OOM</p>
</li>
</ul>
<h1 id="Android开发常见的内存泄漏"><a href="#Android开发常见的内存泄漏" class="headerlink" title="Android开发常见的内存泄漏"></a>Android开发常见的内存泄漏</h1><h2 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h2><ol>
<li>错误示例</li>
<li><p>当调用getInstance时，如果传入的context是Activity的context。只要这个单例没有被释放，那么这个<br>Activity也不会被释放一直到进程退出才会释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CommUtil &#123;</span><br><span class="line">    private static CommUtil instance;</span><br><span class="line">    private Context context;</span><br><span class="line">    private CommUtil(Context context)&#123;</span><br><span class="line">	this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static CommUtil getInstance(Context mcontext)&#123;</span><br><span class="line">	if(instance == null)&#123;</span><br><span class="line">	    instance = new CommUtil(mcontext);</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案</p>
<p>能使用Application的Context就不要使用Activity的Content，Application的生命周期伴随着整个进程的周期</p>
<h2 id="非静态内部类创建静态实例造成的内存泄漏"><a href="#非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="非静态内部类创建静态实例造成的内存泄漏"></a>非静态内部类创建静态实例造成的内存泄漏</h2></li>
<li><p>错误示例</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static TestResource mResource = null;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       if(mManager == null)&#123;</span><br><span class="line">           mManager = new TestResource();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   class TestResource &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解决方案</li>
</ol>
<p>将非静态内部类修改为静态内部类。（静态内部类不会隐式持有外部类）</p>
<h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">   private TextView mTextView ;</span><br><span class="line">   private static class MyHandler extends Handler &#123;</span><br><span class="line">       private WeakReference&lt;Context&gt; reference;</span><br><span class="line">       public MyHandler(Context context) &#123;</span><br><span class="line">           reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">           if(activity != null)&#123;</span><br><span class="line">               activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">       loadData();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void loadData() &#123;</span><br><span class="line"></span><br><span class="line">       Message message = Message.obtain();</span><br><span class="line">       mHandler.sendMessage(message);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解决方案</li>
</ol>
<p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">    private TextView mTextView ;</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; reference;</span><br><span class="line">        public MyHandler(Context context) &#123;</span><br><span class="line">            reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            if(activity != null)&#123;</span><br><span class="line">                activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        //...request</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程造成的内存泄漏"><a href="#线程造成的内存泄漏" class="headerlink" title="线程造成的内存泄漏"></a>线程造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">new AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Void doInBackground(Void... params) &#123;</span><br><span class="line">        SystemClock.sleep(10000);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.execute();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解决方案</li>
</ol>
<p>使用 静态内部类，避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"> </span><br><span class="line">        public MyAsyncTask(Context context) &#123;</span><br><span class="line">            weakReference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        protected Void doInBackground(Void... params) &#123;</span><br><span class="line">            SystemClock.sleep(10000);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Void aVoid) &#123;</span><br><span class="line">            super.onPostExecute(aVoid);</span><br><span class="line">            MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class MyRunnable implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            SystemClock.sleep(10000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//——————</span><br><span class="line">    new Thread(new MyRunnable()).start();</span><br><span class="line">    new MyAsyncTask(this).execute();</span><br></pre></td></tr></table></figure>
<h2 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h2><ol>
<li>错误示例</li>
</ol>
<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>在Activity销毁时及时关闭或者注销</p>
<h2 id="使用了静态的Activity和View"><a href="#使用了静态的Activity和View" class="headerlink" title="使用了静态的Activity和View"></a>使用了静态的Activity和View</h2><ol>
<li>错误示例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static view; </span><br><span class="line"> </span><br><span class="line">    void setStaticView() &#123; </span><br><span class="line">      view = findViewById(R.id.sv_button); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    View svButton = findViewById(R.id.sv_button); </span><br><span class="line">    svButton.setOnClickListener(new View.OnClickListener() &#123; </span><br><span class="line">      @Override public void onClick(View v) &#123; </span><br><span class="line">        setStaticView(); </span><br><span class="line">        nextActivity(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    static Activity activity; </span><br><span class="line"> </span><br><span class="line">    void setStaticActivity() &#123; </span><br><span class="line">      activity = this; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    View saButton = findViewById(R.id.sa_button); </span><br><span class="line">    saButton.setOnClickListener(new View.OnClickListener() &#123; </span><br><span class="line">      @Override public void onClick(View v) &#123; </span><br><span class="line">        setStaticActivity(); </span><br><span class="line">        nextActivity(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>解决方案</p>
<p>应该及时将静态的应用 置为null，而且一般不建议将View及Activity设置为静态</p>
</li>
</ol>
<h2 id="注册了系统的服务，但onDestory未注销"><a href="#注册了系统的服务，但onDestory未注销" class="headerlink" title="注册了系统的服务，但onDestory未注销"></a>注册了系统的服务，但onDestory未注销</h2><ol>
<li>错误示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE);</span><br><span class="line">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</span><br><span class="line"> sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//不需要用的时候记得移除监听</span><br><span class="line">     sensorManager.unregisterListener(listener);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="不需要用的监听未移除会发生内存泄露"><a href="#不需要用的监听未移除会发生内存泄露" class="headerlink" title="不需要用的监听未移除会发生内存泄露"></a>不需要用的监听未移除会发生内存泄露</h2><ol>
<li><p>错误示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//add监听，放到集合里面</span><br><span class="line">        tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onWindowFocusChanged(boolean b) &#123;</span><br><span class="line">                //监听view的加载，view加载出来的时候，计算他的宽高等。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//计算完后，一定要移除这个监听</span><br><span class="line">             tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h4><blockquote>
<p> tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏<br>tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏</p>
</blockquote>
<h1 id="下一篇将介绍如何进行内存泄漏的分析"><a href="#下一篇将介绍如何进行内存泄漏的分析" class="headerlink" title="下一篇将介绍如何进行内存泄漏的分析"></a>下一篇将介绍如何进行内存泄漏的分析</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/09/2017小年的小目标/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/2017小年的小目标/" itemprop="url">
                  2017小年的小目标
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T14:19:18+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/09/2017小年的小目标/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/09/2017小年的小目标/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2016年辞去了在研究院轻松的工作，来到了东莞，加入了新的公司。这一年，总体来说进步还是蛮大，主要一个是思想觉悟的提升，怎么说呢？作为一个程序员，经历过外包公司，一年10几个项目的折磨，也从事过自由软件开发者，也在很多人梦寐以求的事业单位待过，但是却时常感觉到内心的空洞。有幸通过博客及知乎了解到了行业大神们的学习经历，发现很多人比你都优秀，却比你加倍的认真，成功是有理由。优秀是一种习惯，坚持是一种品质。作为一个程序员，需要不断地去学习积累，而不能局限于在自己掌握的知识。所以当你感觉瓶颈的到来，请静下来思考。下面说说我的思考。</p>
<ul>
<li>跳出自己的舒适区</li>
</ul>
<p>作为Android开发者很容易陷入一个误区，就是能够开始利用API及开源项目开发出绚丽的动画及功能，这往往是一个致命的陷阱。在外包公司的经历，我们讲究的是快，只为实现功能，进行交互。不考虑软件的迭代及设计，这使得一年可能开发出10几个项目，但可能永远是一个初级的程序员。所以我们需要深入去学习Android这个系统而不是仅仅懂得API及开源框架的使用</p>
<ul>
<li>基础很重要</li>
</ul>
<p>来到新的公司，公司的项目是经历了7 8年的迭代，经过了N多人的手。可想而知，一个好的架构及代码的设计是何其重要，面临需求的不断变化，这个时候设计模式、基础的数据结构算法是何等的重要。想想问问自己，是否知道最常用ArrayList、HashMap的实现原理？想想问问自己，作为一个程序员，是否连最简单的排序算法都不知道，一个冒泡排序都写不出呢？这些都是我们常常易于忘记的基础，却是对我们写出高质量的代码有着深远的意义</p>
<ul>
<li>贵在坚持</li>
</ul>
<p>知识在于积累，贵在坚持。没有什么是速成的，需要每一天的积累及沉淀。</p>
<p>所以2016底开通了自己的博客，一个是希望能够督促自己坚持，一个是希望能够总结自己的学习知识。另外公司9点30上班，每天坚持7点30分起来看书及学习。初步的计划完成基础知识的复习，包括数据结构及算法、设计模式等。2017希望能够继续坚持学习及工作，使得自己能够在技术上跟进一步，生活过得更加充实。</p>
<ul>
<li><p>努力工作，写出更优质、稳定的代码<br>通过学习及积累，写出更高质量的代码，能够更好的适应需求的变化。同时提升代码的稳定性，为用户提供更优质的体验</p>
</li>
<li><p>坚持每月4遍博客<br>博客还是要继续坚持写的，能够督促自己，同时也能将自己的学习知识进行归纳总结，便于复习及加深记忆理解。2017年希望能够看完《JAVA并发编程实践》《深入理解Java虚拟机 JVM高级特性与最佳实践》，以及对网络通信、Android底层源码及性能优化相关的学习</p>
</li>
<li><p>参与1-2个开源项目的开发<br>希望能够在下半年有机会参与或自己开发一些开源的项目，将学习积累的一些的知识，进行实践</p>
</li>
<li><p>除了工作及学习，抽多些时间陪家人<br>工作学习很重要，家人也很重要。希望能够在兼顾学习工作的情况下，抽多点时间陪家里人…</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/08/设计模式-桥梁模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/设计模式-桥梁模式/" itemprop="url">
                  设计模式-桥梁模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T13:36:09+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/设计模式-桥梁模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/设计模式-桥梁模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-桥梁模式的定义及使用场景"><a href="#1-桥梁模式的定义及使用场景" class="headerlink" title="1.桥梁模式的定义及使用场景"></a>1.桥梁模式的定义及使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>桥梁模式也称为桥接模式，是结构型设计模式之一。将抽象和实现解耦，使得两者可以独立地变化</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>不希望或不适合使用继承的场景<br>例如继承层次过渡、无法更细化设计颗粒等场景，而要考虑使用桥梁模式</li>
<li>接口或抽象类不稳定的场景<br>明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失，也是比较失败的做法</li>
<li>重用性要求较高的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170308133538612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-桥梁模式的优缺点"><a href="#2-桥梁模式的优缺点" class="headerlink" title="2. 桥梁模式的优缺点"></a>2. 桥梁模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><ul>
<li>抽象和实现分离<br>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定一个固定的抽象层次上</li>
<li>优秀的扩充能力</li>
<li>实现细节对客户透明<br>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2>良好的设计不易，对开发者来说要有一定的经验要求，原因是对于抽象和实现的分离需要有良好的把握。<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1>桥梁模式是非常简单的，使用该模式时注意考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，那还要继承干什么呢？桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此在进行系统涉及是，发现类的继承有N层时，可以考虑使用桥梁模式。<h2 id="4-桥梁模式的实现方式"><a href="#4-桥梁模式的实现方式" class="headerlink" title="4. 桥梁模式的实现方式"></a>4. 桥梁模式的实现方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Implementor &#123;</span><br><span class="line">    //基本方法</span><br><span class="line">    public void doSomething();</span><br><span class="line">    public void doAnything();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteImplementor1 implements Implementor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementor1 doSomething!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementor1 doAnything!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteImplementor2 implements Implementor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementor2 doSomething!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementor2 doAnything!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Abstraction &#123;</span><br><span class="line">    //定义对实现化角色的引用</span><br><span class="line">    private Implementor imp;</span><br><span class="line"></span><br><span class="line">    //约束子类必须实现该构造函数</span><br><span class="line">    public Abstraction(Implementor imp) &#123;</span><br><span class="line">        this.imp = imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自身的行为和属性</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Implementor getImp() &#123;</span><br><span class="line">        return imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class RefineAbstraction extends Abstraction &#123;</span><br><span class="line"></span><br><span class="line">    public RefineAbstraction(Implementor imp) &#123;</span><br><span class="line">        super(imp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 业务处理</span><br><span class="line">         */</span><br><span class="line">        super.request();</span><br><span class="line">        super.getImp().doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Implementor imp = new ConcreteImplementor1();</span><br><span class="line">        Abstraction abstraction = new RefineAbstraction(imp);</span><br><span class="line">        abstraction.request();</span><br><span class="line"></span><br><span class="line">        Implementor imp2 = new ConcreteImplementor2();</span><br><span class="line">        abstraction = new RefineAbstraction(imp2);</span><br><span class="line">        abstraction.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/03/07/设计模式-享元模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/设计模式-享元模式/" itemprop="url">
                  设计模式-享元模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T09:36:59+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/07/设计模式-享元模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/07/设计模式-享元模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-享元模式的定义及使用场景"><a href="#1-享元模式的定义及使用场景" class="headerlink" title="1.享元模式的定义及使用场景"></a>1.享元模式的定义及使用场景</h1><p>享元模式是对象池的一种实现。享元模式用来尽可能减少内存的使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。</p>
<p>享元对象中的部分状态是可以共享，可以共享的状态分为内部状态，内部状态不会随着环境变化；不可共享的状态则称为外部状态，他们会随着环境的改变而改变。在享元模式中会建议一个对象容器，在经典的享元模式中该容器为一个Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元模式工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免了创建过多对象的问题。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>享元模式是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>系统中存在大量的相似对象</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特点身份</li>
<li>需要缓冲池的场景</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170307093437266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVuYmluMTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-享元模式的优缺点"><a href="#2-享元模式的优缺点" class="headerlink" title="2. 享元模式的优缺点"></a>2. 享元模式的优缺点</h1><h2 id="2-1优点"><a href="#2-1优点" class="headerlink" title="2.1优点"></a>2.1优点</h2><p>享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。</p>
<h2 id="2-2缺点"><a href="#2-2缺点" class="headerlink" title="2.2缺点"></a>2.2缺点</h2><p>提高了系统的复杂性，需要分离出外部状态和内部状态，而且内部状态具有固化特性，不应随外部状态改变而改变</p>
<h1 id="3-享元模式的实现方式"><a href="#3-享元模式的实现方式" class="headerlink" title="3. 享元模式的实现方式"></a>3. 享元模式的实现方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyweight &#123;</span><br><span class="line">    //一个示意性方法，参数state是外蕴状态</span><br><span class="line">    public void operation(String state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFlyweight implements Flyweight &#123;</span><br><span class="line">    private Character intrinsicState = null;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，内蕴状态作为参数传入</span><br><span class="line">     * @param state</span><br><span class="line">     */</span><br><span class="line">    public ConcreteFlyweight(Character state)&#123;</span><br><span class="line">        this.intrinsicState = state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 外蕴状态作为参数传入方法中，改变方法的行为，</span><br><span class="line">     * 但是并不改变对象的内蕴状态。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void operation(String state) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);</span><br><span class="line">        System.out.println(&quot;Extrinsic State = &quot; + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    private Map&lt;Character,Flyweight&gt; files = new HashMap&lt;Character,Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    public Flyweight factory(Character state)&#123;</span><br><span class="line">        //先从缓存中查找对象</span><br><span class="line">        Flyweight fly = files.get(state);</span><br><span class="line">        if(fly == null)&#123;</span><br><span class="line">            //如果对象不存在则创建一个新的Flyweight对象</span><br><span class="line">            fly = new ConcreteFlyweight(state);</span><br><span class="line">            //把这个新的Flyweight对象添加到缓存中</span><br><span class="line">            files.put(state, fly);</span><br><span class="line">        &#125;</span><br><span class="line">        return fly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        FlyweightFactory factory = new FlyweightFactory();</span><br><span class="line">        Flyweight fly = factory.factory(new Character(&apos;a&apos;));</span><br><span class="line">        fly.operation(&quot;First Call&quot;);</span><br><span class="line"></span><br><span class="line">        fly = factory.factory(new Character(&apos;b&apos;));</span><br><span class="line">        fly.operation(&quot;Second Call&quot;);</span><br><span class="line"></span><br><span class="line">        fly = factory.factory(new Character(&apos;a&apos;));</span><br><span class="line">        fly.operation(&quot;Third Call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
