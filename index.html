<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="优秀是一种习惯，坚持是一种品质。">
<meta property="og:type" content="website">
<meta property="og:title" content="黄俊彬个人博客">
<meta property="og:url" content="https://junbin1011.github.io/index.html">
<meta property="og:site_name" content="黄俊彬个人博客">
<meta property="og:description" content="优秀是一种习惯，坚持是一种品质。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄俊彬个人博客">
<meta name="twitter:description" content="优秀是一种习惯，坚持是一种品质。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/"/>





  <title> 黄俊彬个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄俊彬个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">优秀是一种习惯，坚持是一种品质。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2019/04/24/回顾2018，展望2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/24/回顾2018，展望2019/" itemprop="url">
                  回顾2018，展望2019
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-24T16:20:05+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/24/回顾2018，展望2019/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/24/回顾2018，展望2019/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="回顾2018"><a href="#回顾2018" class="headerlink" title="回顾2018"></a>回顾2018</h1><p>2018即将结束，又到了例行年度总结的时刻了。下面通过学习、工作、生活、还有感悟来回顾即将过去的2018。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-936920284be34f2a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>不知不觉用扇贝已经2年多了，2018年也全勤打卡。发现在这个过程不仅学习了英语的知识，也慢慢练成了一些习惯，坚持、不放弃。这里推荐一下扇贝英语，一直在用很不错。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-f1fa811f20117b79?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>2018年总共输出了13篇博文，虽然只达到月均一篇。但自己感觉输出的质量较上一年还是有进步的。主要为工作上的一些提炼总结及源码学习。</p>
<h4 id="工作提炼总结"><a href="#工作提炼总结" class="headerlink" title="工作提炼总结"></a>工作提炼总结</h4><ul>
<li><a href="https://www.jianshu.com/p/ccfc28128d68" target="_blank" rel="external">Android应用架构前世今生</a></li>
<li><a href="https://www.jianshu.com/p/c8e691a69086" target="_blank" rel="external">记一次Android内存泄漏的优化经历</a></li>
<li><a href="https://www.jianshu.com/p/9e9e902ea039" target="_blank" rel="external">Android P 兼容与适配</a></li>
<li><a href="https://www.jianshu.com/p/25688ed4777f" target="_blank" rel="external">项目模块重构分享与思考</a></li>
<li><a href="https://www.jianshu.com/p/6ae1e09ebbf5" target="_blank" rel="external">Android热修复技术，你会怎么选？</a></li>
<li><a href="https://www.jianshu.com/p/24eb823edebc" target="_blank" rel="external">APK瘦身三步曲</a></li>
</ul>
<h4 id="开源框架源码学习系列"><a href="#开源框架源码学习系列" class="headerlink" title="开源框架源码学习系列"></a>开源框架源码学习系列</h4><ul>
<li><a href="https://www.jianshu.com/p/72172703cc3f" target="_blank" rel="external">OkHttp源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/8b44a76197e1" target="_blank" rel="external">Retrofit源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/e01f68802604" target="_blank" rel="external">Glide源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/1b9671fb0ebe" target="_blank" rel="external">EventBus源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/ea075570dc3d" target="_blank" rel="external">leakcanary源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/5602ca1322b2" target="_blank" rel="external">blockcanary源码学习随笔</a></li>
<li><a href="https://www.jianshu.com/p/26b922d72d7b" target="_blank" rel="external">rxjava2.x源码学习随笔</a></li>
</ul>
<h4 id="博文地址"><a href="#博文地址" class="headerlink" title="博文地址"></a>博文地址</h4><ul>
<li><a href="https://www.jianshu.com/u/466f8b75f81c" target="_blank" rel="external">简书博客，https://www.jianshu.com/u/466f8b75f81c</a></li>
<li><a href="http://huangjunbin.com/" target="_blank" rel="external">github，http://huangjunbin.com/</a></li>
</ul>
<p>希望新的一年能够继续坚持学习，输出更多、更高质量的博文。</p>
<h3 id="极客时间"><a href="#极客时间" class="headerlink" title="极客时间"></a>极客时间</h3><p>2018知识付费的热潮，极客时间也是在此期间推出的一个知识付费的APP，以订阅专栏的形式提供。确实还是有蛮多的干货，下面列一下学习的一些专栏。</p>
<p>好多坑和问题都是前人已走过，多看看前人的处理方式及感悟，少走弯路。</p>
<blockquote>
<p>这里吐槽一下极客时间的Android版本，经常出现无响应的情况，要杀进程重新进入。一度用回小程序版本。</p>
</blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/104" target="_blank" rel="external">持续交付36讲</a></li>
<li><a href="https://time.geekbang.org/column/113" target="_blank" rel="external">技术管理实战36讲</a></li>
<li><a href="https://time.geekbang.org/column/111" target="_blank" rel="external">程序员进阶攻略</a></li>
<li><a href="https://time.geekbang.org/column/126" target="_blank" rel="external">数据结构与算法之美</a></li>
<li><a href="https://time.geekbang.org/column/79" target="_blank" rel="external">技术领导力300讲</a></li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h3 id="总结提炼"><a href="#总结提炼" class="headerlink" title="总结提炼"></a>总结提炼</h3><p>在研发的过程中，总会遇到一些疑难的问题或版本的里程碑。有时候停一停，进行梳理总结及输出，也是一种非常好的知识沉淀的方式。在18年，也将工作中的一些问题进行梳理总结，最后以博文的形式输出。</p>
<h3 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h3><p>技术都是通过业务来变现价值的。虽然各种新技术风起云涌，但是结合业务进行预研及应用，才能形成良好的闭环。否则只能当作知识储备，很容易随着时间的推移，慢慢就消之殆尽。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>不知不觉，宝宝也1岁多了。终于从晚上起来3-5次到现在睡整觉了。在这个期间还是非常感谢老婆与我妈妈的辛苦付出，让宝宝快乐成才。<br>感叹一下！当个程序员不容易，当个爸爸也不容易。</p>
<p>老婆整理的宝宝周岁相册集合-<a href="https://www.meipian.cn/1tpytehy?share_from=self&amp;v=4.7.2&amp;share_user_mpuuid=14b94e097cc76be42d48dcb2c961b192&amp;utm_source=singlemessage&amp;from=singlemessage&amp;user_id=59638444&amp;uuid=06bd0f920f7f912f18889de521653c9c&amp;utm_medium=meipian_android" target="_blank" rel="external">宝宝周岁 相册集合</a></p>
<h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>身体是革命的本钱，是一切的基础，一定要加强锻炼。我自己一直都是胖的体质。176的身高，87.5kg的体重。经过差不多2个多月的锻炼及饮食控制，目前维持在78kg左右。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-a6e9118030ef0228?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这里给一下心得</p>
<ul>
<li>7分吃3分练，要管好嘴，特别是主食</li>
<li>晚餐少吃、宵夜一定不要吃</li>
<li>设定目标、使用APP进行记录</li>
</ul>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>每个人都会遇到很多选择的机会。随着有了家庭，已不像刚走出学校那样随心所欲。做任何选择之前都需要先充分思考和平衡，不要轻易许下承诺。</p>
<p>珍惜每一次机会，也重视每次承诺。</p>
<h3 id="寒冬"><a href="#寒冬" class="headerlink" title="寒冬"></a>寒冬</h3><p>接近年末，没想到“寒冬”成了热词。其实互联网这个行业，瞬息万变。危机感应该实时具备，特别是当你感觉已经走入了一个舒适区。</p>
<p>没有一个企业会为了一个没有价值的员工支付报酬，所以唯有不断的提升自己的软硬技能，才能从容应对变化。</p>
<h1 id="展望2019"><a href="#展望2019" class="headerlink" title="展望2019"></a>展望2019</h1><p><img src="http://upload-images.jianshu.io/upload_images/5125122-603fb426dfe2a525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、形成知识技能树，有目标规划推进</p>
<p>2、学以致用、总结提炼、输出博文</p>
<p>3、深度沉淀、广度拓展，基础技能积累、核心技能深化</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/11/28/APK瘦身三步曲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/28/APK瘦身三步曲/" itemprop="url">
                  APK瘦身三步曲
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T15:26:37+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/28/APK瘦身三步曲/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/11/28/APK瘦身三步曲/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>115于2009年推出的网络数据在线存储服务，一直以来都有阶段性对应用进行安装包的体积优化，因为公司也没有硬性的指标规定，所以这块的重视程度也一直不高。对比了目前竞品的一个情况，如下：</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>版本号</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>115</td>
<td>V8.1.1</td>
<td>50.26M</td>
</tr>
<tr>
<td>微云</td>
<td>V6.6.4</td>
<td>37.67MB</td>
</tr>
<tr>
<td>百度云</td>
<td>V9.0.2</td>
<td>48.3MB</td>
</tr>
</tbody>
</table>
<p>使用Android Studio的APK Analyzer具体详细分析如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>115</th>
<th>微云</th>
<th>百度云</th>
</tr>
</thead>
<tbody>
<tr>
<td> res</td>
<td>31.8M</td>
<td>+assert 10.2M</td>
<td>+assert 17.4M</td>
</tr>
<tr>
<td>lib</td>
<td>7M</td>
<td>18.2M</td>
<td>13.1M</td>
</tr>
<tr>
<td>classes</td>
<td>7.3M</td>
<td>6.8M</td>
<td>13.9M</td>
</tr>
<tr>
<td>resource.arsc</td>
<td>1.9M</td>
<td>1.6M</td>
<td>2.2M</td>
</tr>
</tbody>
</table>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>虽然各个应用的功能集不一致，但是主要都是提供存储服务，这里的对比也是从某个层面进行比较。通过分析对比表可以得知。</p>
<ol>
<li>微云体积最少，百度云次之，115最大</li>
<li>115体积主要最大的地方在res图片资源这块</li>
<li>115的lib及classes是最小的</li>
</ol>
<p><strong>所以从分析的结果上来看，115的体积优化的主要方向要从res图片资源入手。</strong></p>
<h1 id="瘦身三步曲-删除、压缩、混淆"><a href="#瘦身三步曲-删除、压缩、混淆" class="headerlink" title="瘦身三步曲(删除、压缩、混淆)"></a>瘦身三步曲(删除、压缩、混淆)</h1><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除无用的代码"><a href="#删除无用的代码" class="headerlink" title="删除无用的代码"></a>删除无用的代码</h3><p>删除无用的代码，这个放在第一位是因为这个是问题的根源。</p>
<p>随着项目版本的迭代及业务快速的更迭，有时候为了赶时间，废弃的代码及资源都不会及时清理，日积月累的堆积，慢慢APK的体积就会越来越臃肿。</p>
<p>如果属于这种情况，应该先自己进行人工的整理及清除。这个时候可以先不管资源（后面用工具进行清理），但是类相关的调用及无用的类要及时进行清理。否则后面的图片及资源也会照样被识别为有引用，打包进APK。</p>
<h3 id="Lint工具检查"><a href="#Lint工具检查" class="headerlink" title="Lint工具检查"></a>Lint工具检查</h3><p>Android Studio给我们提供了强大的检查工具。只需要选中res目录，右键选择Refactor然后再选择Remove Unused Resources。<br>建议先使用Preview，然后再进行删除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4b0211c7d9dae8da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint使用"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-15d203966b219747?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint Preview"></p>
<blockquote>
<p>这里需要注意，特别有使用第三方的SDK，有些代码是在jar包里面，但是资源独立拷贝进工程，这样也会被识别成无引用的资源。但是这类资源一般都有特定的命名格式。</p>
</blockquote>
<h3 id="Grdle配置"><a href="#Grdle配置" class="headerlink" title="Grdle配置"></a>Grdle配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">        buildTypes &#123;</div><div class="line">            release &#123;</div><div class="line">                minifyEnabled true //是否开启混淆</div><div class="line">                shrinkResources true //压缩</div><div class="line">                zipAlignEnabled true ////去掉无用的resourse文件</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>启用shrinkResources，gradle在打包的时候会自动进行资源的清理。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="PNG压缩优化"><a href="#PNG压缩优化" class="headerlink" title="PNG压缩优化"></a>PNG压缩优化</h3><p>推荐使用<a href="https://tinypng.com/" target="_blank" rel="external">tinypng</a>。</p>
<p>tinypng通过合并图片中相似的颜色，通过将 24 位的 PNG 图片压缩成小得多的 8 位色值的图片，并且去掉了图片中不必要的 metadata（元数据，从 Photoshop 等工具中导出的图片都会带有此类信息），这种方式几乎能完美支持原图片的透明度。有部分文档指出tinypng同时采用了pngquant、optipng、advpng几种脚本。图片的压缩率能达到50%以上。</p>
<h3 id="webp使用"><a href="#webp使用" class="headerlink" title="webp使用"></a>webp使用</h3><p>WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。无损压缩比PNG文件小45%，即使PNG已经过其他的优化，也能达到28%。缺点，加载比PNG慢。</p>
<p>Android Studio自带了对WebP的转换支持。选中资源，右键Convert to WebP。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-237f41569728e956?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PNG 转 WebP"></p>
<p>通过删除及压缩前两步的操作，115的优化情况如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>115</th>
<th>115优化</th>
</tr>
</thead>
<tbody>
<tr>
<td> res</td>
<td>31.8M</td>
<td>26.1MM</td>
</tr>
<tr>
<td>lib</td>
<td>7M</td>
<td>7M </td>
</tr>
<tr>
<td>classes</td>
<td>7.3M</td>
<td>7.3M</td>
</tr>
<tr>
<td>resource.arsc</td>
<td>1.9M</td>
<td>1.8M</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>优化情况分析：优化后为44.46M，约节省5.8M，优化11%</strong></p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><h3 id="Proguard代码混淆"><a href="#Proguard代码混淆" class="headerlink" title="Proguard代码混淆"></a>Proguard代码混淆</h3><ol>
<li>删除注释和无用的代码</li>
<li>将java文件文件名及方法名改成短名 a.java </li>
</ol>
<p>支持的方式也很简单，Gradle默认支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">        buildTypes &#123;</div><div class="line">            release &#123;</div><div class="line">                minifyEnabled true //是否开启混淆</div><div class="line">                 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h3><p><a href="https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md" target="_blank" rel="external">AndResGuard</a>是一个帮助你缩小APK大小的工具，他的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a。</p>
<p>具体的原理可参看<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd" target="_blank" rel="external">安装包立减1M–微信Android资源混淆打包工具</a></p>
<p>集成也非常简单，详细参看Github中的使用说明则可。</p>
<p>通过资源混淆后，115的优化情况如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>115</th>
<th>115优化</th>
<th>115资源混淆</th>
</tr>
</thead>
<tbody>
<tr>
<td> res</td>
<td>31.8M</td>
<td>26.1MM</td>
<td>25.4M</td>
</tr>
<tr>
<td>lib</td>
<td>7M</td>
<td>7M</td>
<td>6.7M</td>
</tr>
<tr>
<td>classes</td>
<td>7.3M</td>
<td>7.3M</td>
<td>6.9M</td>
</tr>
<tr>
<td>resource.arsc</td>
<td>1.9M</td>
<td>1.8M</td>
<td>280.3KB</td>
</tr>
</tbody>
</table>
<p><strong>优化情况分析：优化后为41.32M，相比没做资源混淆，约节省3.14M，体积优化7%</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过瘦身三步曲的优化后，最终115应用的一个优化情况如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>115</th>
<th>115最终优化版本</th>
</tr>
</thead>
<tbody>
<tr>
<td> res</td>
<td>31.8M</td>
<td>25.4M</td>
</tr>
<tr>
<td>lib</td>
<td>7M</td>
<td>6.7M</td>
</tr>
<tr>
<td>classes</td>
<td>7.3M</td>
<td>6.9M</td>
</tr>
<tr>
<td>resource.arsc</td>
<td>1.9M</td>
<td>280.3KB</td>
</tr>
</tbody>
</table>
<p><strong>优化情况分析：优化后为41.32M，相比没做优化前，约节省8.94M，体积优化17.7%</strong></p>
<blockquote>
<p>115的APK体积优化，现阶段只能说是做了一个初步优化，特别是对于第一步的删除，由于历史的遗留原因。对于一些遗留的代码还待进一步的整理和清除，体积也是还有继续优化的空间。</p>
</blockquote>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>除了常规的瘦身三步曲，对于APK体积当然还有其他的方案。如：</p>
<ol>
<li>资源动态加载（如表情包动态下载）</li>
<li>插件化（动态加载）</li>
</ol>
<p>方案当然还有很多，本文只介绍常规使用的一些方法，有兴趣的伙伴可以继续深入了解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tinypng.com/" target="_blank" rel="external">tinypng</a></p>
<p><a href="https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md" target="_blank" rel="external">AndResGuard</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd" target="_blank" rel="external">安装包立减1M–微信Android资源混淆打包工具</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/09/21/Android热修复技术，你会怎么选？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/21/Android热修复技术，你会怎么选？/" itemprop="url">
                  Android热修复技术，你会怎么选？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T09:12:00+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/21/Android热修复技术，你会怎么选？/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/21/Android热修复技术，你会怎么选？/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前Android业内，热修复技术百花齐放，各大厂都推出了自己的热修复方案，使用的技术方案也各有所异，当然各个方案也都存在各自的局限性。在面对众多的方案，希望通过梳理这些热修复方案的对比及实现原理，掌握热修复技术的本质，同时也对项目接入做好准备。</p>
<h1 id="什么是热修复技术？"><a href="#什么是热修复技术？" class="headerlink" title="什么是热修复技术？"></a>什么是热修复技术？</h1><p>关于热修复这个名词，并不陌生。相信大家都有过更新window补丁的经历，通过补丁可以动态修复系统的漏洞，只不过这个过程对用户而言是可选及自行操作。</p>
<p>那么关于Android平台的热修复技术，简单来说，就是通过下发补丁包，让已安装的客户端动态更新，让用户可以不用重新安装APP，就能够修复软件缺陷的一种技术。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-50c2fb502983a3bb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>随着热修复技术的发展，不仅可以修复代码，同时可以修复资源文件及SO库。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-cb67bc0991f396fb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="为什么要使用热修复技术？"><a href="#为什么要使用热修复技术？" class="headerlink" title="为什么要使用热修复技术？"></a>为什么要使用热修复技术？</h1><p>在回答这个问题之前，我觉得应该先思考如下几个问题。</p>
<ol>
<li>开发上线的版本能保证不存在Bug么？</li>
<li>修复后的版本能保证用户都及时更新么？</li>
<li>如何最大化减少线上Bug对业务的影响？</li>
</ol>
<p>从这些角度来说，相信大家应该都能有所体会，热修复技术带来的优势不言而喻。</p>
<ol>
<li>可快速修复，避免线上Bug带来的业务损失，把损失降到最低。</li>
<li>保证客户端的更新率，无须用户进行版本升级安装</li>
<li>良好的用户体验，无感知修复异常。节省用户下载安装成本。</li>
</ol>
<h1 id="怎么选择热修复技术方案？"><a href="#怎么选择热修复技术方案？" class="headerlink" title="怎么选择热修复技术方案？"></a>怎么选择热修复技术方案？</h1><h2 id="国内主流的技术方案"><a href="#国内主流的技术方案" class="headerlink" title="国内主流的技术方案"></a>国内主流的技术方案</h2><p> 1、阿里系</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix </a></td>
<td>开源，实时生效</td>
</tr>
<tr>
<td><a href="http://baichuan.taobao.com/product/hotfix.htm?spm=a3c0d.7662652.1998907869.2.309abe485ZwUCh" target="_blank" rel="external">HotFix</a></td>
<td>阿里百川，未开源，免费、实时生效</td>
</tr>
<tr>
<td><a href="https://help.aliyun.com/product/51340.html?spm=a2c4g.11186623.6.540.61a72ef2DAZ30l" target="_blank" rel="external">Sophix</a></td>
<td>未开源，商业收费，实时生效/冷启动修复</td>
</tr>
</tbody>
</table>
<p>HotFix是AndFix的优化版本，Sophix是HotFix的优化版本。目前阿里系主推是Sophix。</p>
<p>2、腾讯系</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a" target="_blank" rel="external">Qzone超级补丁</a></td>
<td>QQ空间，未开源，冷启动修复</td>
</tr>
<tr>
<td><a href="https://github.com/alexclin0188/QFixPatch" target="_blank" rel="external">QFix</a></td>
<td>手Q团队，开源，冷启动修复</td>
</tr>
<tr>
<td><a href="http://www.tinkerpatch.com/Docs/intro" target="_blank" rel="external">Tinker</a></td>
<td>微信团队，开源，冷启动修复。提供分发管理，<a href="http://www.tinkerpatch.com/Price" target="_blank" rel="external">基础版免费</a></td>
</tr>
</tbody>
</table>
<p>3、其他<br>名称 | 说明<br>—|—<br><a href="https://github.com/Meituan-Dianping/Robust" target="_blank" rel="external">Robust </a>|美团， 开源，实时修复<br><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a> |大众点评，开源，冷启动修复<br><a href="https://github.com/eleme/Amigo" target="_blank" rel="external">Amigo</a>|饿了么，开源，冷启动修复</p>
<h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><table>
<thead>
<tr>
<th>方案对比</th>
<th>Sophix</th>
<th>Tinker</th>
<th>nuwa</th>
<th>AndFix</th>
<th>Robust</th>
<th>Amigo</th>
</tr>
</thead>
<tbody>
<tr>
<td>类替换</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>So替换</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>资源替换</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>全平台支持</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>即时生效</td>
<td>同时支持</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能损耗</td>
<td>较少</td>
<td>较小</td>
<td>较大</td>
<td>较小</td>
<td>较小</td>
<td>较小</td>
</tr>
<tr>
<td>补丁包大小</td>
<td>小</td>
<td>较小</td>
<td>较大</td>
<td>一般</td>
<td>一般</td>
<td>较大</td>
</tr>
<tr>
<td>开发透明</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>复杂度</td>
<td>傻瓜式接入</td>
<td>复杂</td>
<td>较低</td>
<td>复杂</td>
<td>复杂</td>
<td>较低</td>
</tr>
<tr>
<td>Rom体积</td>
<td>较小</td>
<td>Dalvik较大</td>
<td>较小</td>
<td>较小</td>
<td>较小</td>
<td>大</td>
</tr>
<tr>
<td>成功率</td>
<td>高</td>
<td>较高</td>
<td>较高</td>
<td>一般</td>
<td>最高</td>
<td>较高</td>
</tr>
<tr>
<td>热度</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>开源</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>收费</td>
<td>收费（设有免费阈值）</td>
<td>收费（基础版免费，但有限制）</td>
<td>免费</td>
<td>免费</td>
<td>免费</td>
<td>免费</td>
</tr>
<tr>
<td>监控</td>
<td>提供分发控制及监控</td>
<td>提供分发控制及监控</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考Tinker及Sophix官方对比</p>
</blockquote>
<p><a href="http://www.tinkerpatch.com/Docs/intro" target="_blank" rel="external">为什么使用 Tinker？</a></p>
<p><a href="https://help.aliyun.com/document_detail/51416.html?spm=a2c4g.11186623.6.543.6ed62ef2MAnXZM" target="_blank" rel="external">Sophix产品优势？</a></p>
<h2 id="怎么选？"><a href="#怎么选？" class="headerlink" title="怎么选？"></a>怎么选？</h2><p>怎么选？这个只能说一切看需求。如果公司综合实力强，完全考虑自研都没问题，但需要综合考虑成本及维护。下面给出2点建议，如下：</p>
<p>1、项目需求</p>
<ul>
<li>只需要简单的方法级别Bug修复？</li>
<li>需要资源及so库的修复？</li>
<li>对平台兼容性要求及成功率要求？</li>
<li>有需求对分发进行控制，对监控数据进行统计，补丁包进行管理？</li>
<li>公司资源是否支持商业付费？</li>
</ul>
<p>2、学习及使用成本</p>
<ul>
<li>集成难度</li>
<li>代码侵入性</li>
<li>调试维护</li>
</ul>
<p>3、选择大厂</p>
<ul>
<li>技术性能有保障</li>
<li>有专人维护</li>
<li>热度高，开源社区活跃</li>
</ul>
<p>如果考虑付费，推荐选择阿里的Sophix，Sophix是综合优化的产物，功能完善、开发简单透明、提供分发及监控管理。</p>
<p>如果不考虑付费，只需支持方法级别的Bug修复，不支持资源及so，推荐使用Robust。</p>
<p>如果考虑需要同时支持资源及so，推荐使用Tinker。</p>
<p>最后如果公司综合实力强，可考虑自研，灵活性及可控制最强。</p>
<blockquote>
<p>从Github上的热度及提交记录上看，nuwa、AndFix、Amigo等的提交都是2 years ago。</p>
</blockquote>
<h1 id="内业主要热修复技术方案原理？"><a href="#内业主要热修复技术方案原理？" class="headerlink" title="内业主要热修复技术方案原理？"></a>内业主要热修复技术方案原理？</h1><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-97e7a2b8568b2972?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="NativeHook-原理"><a href="#NativeHook-原理" class="headerlink" title="NativeHook 原理"></a>NativeHook 原理</h2><h2 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h2><p>NativeHook的原理是直接在native层进行方法的结构体信息对换，从而实现完美的方法新旧替换，从而实现热修复功能。<br>下面以AndFix的一段jni代码来进行说明，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void replace_6_0(JNIEnv* env, jobject src, jobject dest) &#123;</div><div class="line"></div><div class="line">    // 通过Method对象得到底层Java函数对应ArtMethod的真实地址</div><div class="line">	art::mirror::ArtMethod* smeth =</div><div class="line">			(art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(src);</div><div class="line"></div><div class="line">	art::mirror::ArtMethod* dmeth =</div><div class="line">			(art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(dest);</div><div class="line"></div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;class_loader_ =</div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;class_loader_; //for plugin classloader</div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;clinit_thread_id_ =</div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;clinit_thread_id_;</div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;status_ = reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;status_-1;</div><div class="line">    //for reflection invoke</div><div class="line">    reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;super_class_ = 0;</div><div class="line">    //把旧函数的所有成员变量都替换为新函数的</div><div class="line">    smeth-&gt;declaring_class_ = dmeth-&gt;declaring_class_;</div><div class="line">    smeth-&gt;dex_cache_resolved_methods_ = dmeth-&gt;dex_cache_resolved_methods_;</div><div class="line">    smeth-&gt;dex_cache_resolved_types_ = dmeth-&gt;dex_cache_resolved_types_;</div><div class="line">    smeth-&gt;access_flags_ = dmeth-&gt;access_flags_ | 0x0001;</div><div class="line">    smeth-&gt;dex_code_item_offset_ = dmeth-&gt;dex_code_item_offset_;</div><div class="line">    smeth-&gt;dex_method_index_ = dmeth-&gt;dex_method_index_;</div><div class="line">    smeth-&gt;method_index_ = dmeth-&gt;method_index_;</div><div class="line">    </div><div class="line">    smeth-&gt;ptr_sized_fields_.entry_point_from_interpreter_ =</div><div class="line">    dmeth-&gt;ptr_sized_fields_.entry_point_from_interpreter_;</div><div class="line">    </div><div class="line">    smeth-&gt;ptr_sized_fields_.entry_point_from_jni_ =</div><div class="line">    dmeth-&gt;ptr_sized_fields_.entry_point_from_jni_;</div><div class="line">    smeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_ =</div><div class="line">    dmeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_;</div><div class="line">    </div><div class="line">    LOGD(&quot;replace_6_0: %d , %d&quot;,</div><div class="line">         smeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_,</div><div class="line">         dmeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void setFieldFlag_6_0(JNIEnv* env, jobject field) &#123;</div><div class="line">	art::mirror::ArtField* artField =</div><div class="line">			(art::mirror::ArtField*) env-&gt;FromReflectedField(field);</div><div class="line">	artField-&gt;access_flags_ = artField-&gt;access_flags_ &amp; (~0x0002) | 0x0001;</div><div class="line">	LOGD(&quot;setFieldFlag_6_0: %d &quot;, artField-&gt;access_flags_);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每一个Java方法在art中都对应一个ArtMethod,ArtMethod记录了这个Java方法的所有信息，包括访问权限及代码执行地址等。通过env-&gt;FromReflectedMethod得到方法对应的ArtMethod的真正开始地址，然后强转为ArtMethod指针，从而对其所有成员进行修改。</p>
<p>这样以后调用这个方法时就会直接走到新方法的实现中，达到热修复的效果。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>即时生效</li>
<li>没有性能开销，不需要任何编辑器的插桩或代码改写</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>存在稳定及兼容性问题。ArtMethod的结构基本参考Google开源的代码，各大厂商的ROM都可能有所改动，可能导致结构不一致，修复失败。</li>
<li>无法增加变量及类，只能修复方法级别的Bug，无法做到新功能的发布</li>
</ul>
<h2 id="javaHook-原理"><a href="#javaHook-原理" class="headerlink" title="javaHook 原理"></a>javaHook 原理</h2><h2 id="原理及实现-1"><a href="#原理及实现-1" class="headerlink" title="原理及实现"></a>原理及实现</h2><p>以美团的Robust为例，Robust 的原理可以简单描述为：</p>
<p>1、打基础包时插桩，在每个方法前插入一段类型为 ChangeQuickRedirect 静态变量的逻辑，插入过程对业务开发是完全透明</p>
<p>2、加载补丁时，从补丁包中读取要替换的类及具体替换的方法实现，新建ClassLoader加载补丁dex。当changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-fc799bbd4a587560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Robust 官方介绍示例图"></p>
<p>下面通过Robust的源码来进行分析。<br>首先看一下打基础包是插入的代码逻辑，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static ChangeQuickRedirect u;</div><div class="line">protected void onCreate(Bundle bundle) &#123;</div><div class="line">        //为每个方法自动插入修复逻辑代码，如果ChangeQuickRedirect为空则不执行</div><div class="line">        if (u != null) &#123;</div><div class="line">            if (PatchProxy.isSupport(new Object[]&#123;bundle&#125;, this, u, false, 78)) &#123;</div><div class="line">                PatchProxy.accessDispatchVoid(new Object[]&#123;bundle&#125;, this, u, false, 78);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        super.onCreate(bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Robust的核心修复源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class PatchExecutor extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        ...</div><div class="line">        applyPatchList(patches);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 应用补丁列表</div><div class="line">     */</div><div class="line">    protected void applyPatchList(List&lt;Patch&gt; patches) &#123;</div><div class="line">        ...</div><div class="line">        for (Patch p : patches) &#123;</div><div class="line">            ...</div><div class="line">            currentPatchResult = patch(context, p);</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">     /**</div><div class="line">     * 核心修复源码</div><div class="line">     */</div><div class="line">    protected boolean patch(Context context, Patch patch) &#123;</div><div class="line">        ...</div><div class="line">        //新建ClassLoader</div><div class="line">        DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),</div><div class="line">                null, PatchExecutor.class.getClassLoader());</div><div class="line">        patch.delete(patch.getTempPath());</div><div class="line">        ...</div><div class="line">        try &#123;</div><div class="line">            patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());</div><div class="line">            patchesInfo = (PatchesInfo) patchsInfoClass.newInstance();</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">             ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        //通过遍历其中的类信息进而反射修改其中 ChangeQuickRedirect 对象的值</div><div class="line">        for (PatchedClassInfo patchedClassInfo : patchedClasses) &#123;</div><div class="line">            ...</div><div class="line">            try &#123;</div><div class="line">                oldClass = classLoader.loadClass(patchedClassName.trim());</div><div class="line">                Field[] fields = oldClass.getDeclaredFields();</div><div class="line">                for (Field field : fields) &#123;</div><div class="line">                    if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) &#123;</div><div class="line">                        changeQuickRedirectField = field;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                try &#123;</div><div class="line">                    patchClass = classLoader.loadClass(patchClassName);</div><div class="line">                    Object patchObject = patchClass.newInstance();</div><div class="line">                    changeQuickRedirectField.setAccessible(true);</div><div class="line">                    changeQuickRedirectField.set(null, patchObject);</div><div class="line">                    &#125; catch (Throwable t) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">                 ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>高兼容性（Robust只是在正常的使用DexClassLoader）、高稳定性，修复成功率高达99.9%</li>
<li>补丁实时生效，不需要重新启动</li>
<li>支持方法级别的修复，包括静态方法</li>
<li>支持增加方法和类</li>
<li>支持ProGuard的混淆、内联、优化等操作</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代码是侵入式的，会在原有的类中加入相关代码</li>
<li>so和资源的替换暂时不支持</li>
<li>会增大apk的体积，平均一个函数会比原来增加17.47个字节，10万个函数会增加1.67M</li>
</ul>
<h2 id="java-mulitdex-原理"><a href="#java-mulitdex-原理" class="headerlink" title="java mulitdex 原理"></a>java mulitdex 原理</h2><h2 id="原理及实现-2"><a href="#原理及实现-2" class="headerlink" title="原理及实现"></a>原理及实现</h2><p>Android内部使用的是BaseDexClassLoader、PathClassLoader、DexClassLoader三个类加载器实现从DEX文件中读取类数据，其中PathClassLoader和DexClassLoader都是继承自BaseDexClassLoader实现。dex文件转换成dexFile对象，存入Element[]数组，findclass顺序遍历Element数组获取DexFile，然后执行DexFile的findclass。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 加载名字为name的class对象</div><div class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</div><div class="line">    // 遍历从dexPath查询到的dex和资源Element</div><div class="line">    for (Element element : dexElements) &#123;</div><div class="line">        DexFile dex = element.dexFile;</div><div class="line">        // 如果当前的Element是dex文件元素</div><div class="line">        if (dex != null) &#123;</div><div class="line">            // 使用DexFile.loadClassBinaryName加载类</div><div class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</div><div class="line">            if (clazz != null) &#123;</div><div class="line">                return clazz;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (dexElementsSuppressedExceptions != null) &#123;</div><div class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以此方案的原理是Hook了ClassLoader.pathList.dexElements[]，将补丁的dex插入到数组的最前端。因为ClassLoader的findClass是通过遍历dexElements[]中的dex来寻找类的。所以会优先查找到修复的类。从而达到修复的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-07be03be319158d1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片引用自QQ空间热修复介绍"></p>
<p>下面使用Nuwa的关键实现源码进行说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public static void injectDexAtFirst(String dexPath, String defaultDexOptPath) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</div><div class="line">        //新建一个ClassLoader加载补丁Dex</div><div class="line">        DexClassLoader dexClassLoader = new DexClassLoader(dexPath, defaultDexOptPath, dexPath, getPathClassLoader());</div><div class="line">        //反射获取旧DexElements数组</div><div class="line">        Object baseDexElements = getDexElements(getPathList(getPathClassLoader()));</div><div class="line">        //反射获取补丁DexElements数组</div><div class="line">        Object newDexElements = getDexElements(getPathList(dexClassLoader));</div><div class="line">        //合并，将新数组的Element插入到最前面</div><div class="line">        Object allDexElements = combineArray(newDexElements, baseDexElements);</div><div class="line">        Object pathList = getPathList(getPathClassLoader());</div><div class="line">        //更新旧ClassLoader中的Element数组</div><div class="line">        ReflectionUtils.setField(pathList, pathList.getClass(), &quot;dexElements&quot;, allDexElements);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static PathClassLoader getPathClassLoader() &#123;</div><div class="line">        PathClassLoader pathClassLoader = (PathClassLoader) DexUtils.class.getClassLoader();</div><div class="line">        return pathClassLoader;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Object getDexElements(Object paramObject)</div><div class="line">            throws IllegalArgumentException, NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">        return ReflectionUtils.getField(paramObject, paramObject.getClass(), &quot;dexElements&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Object getPathList(Object baseDexClassLoader)</div><div class="line">            throws IllegalArgumentException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</div><div class="line">        return ReflectionUtils.getField(baseDexClassLoader, Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;), &quot;pathList&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Object combineArray(Object firstArray, Object secondArray) &#123;</div><div class="line">        Class&lt;?&gt; localClass = firstArray.getClass().getComponentType();</div><div class="line">        int firstArrayLength = Array.getLength(firstArray);</div><div class="line">        int allLength = firstArrayLength + Array.getLength(secondArray);</div><div class="line">        Object result = Array.newInstance(localClass, allLength);</div><div class="line">        for (int k = 0; k &lt; allLength; ++k) &#123;</div><div class="line">            if (k &lt; firstArrayLength) &#123;</div><div class="line">                Array.set(result, k, Array.get(firstArray, k));</div><div class="line">            &#125; else &#123;</div><div class="line">                Array.set(result, k, Array.get(secondArray, k - firstArrayLength));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>不需要考虑对dalvik虚拟机和art虚拟机做适配</li>
<li>代码是非侵入式的，对apk体积影响不大</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要下次启动才修复</li>
<li>性能损耗大，为了避免类被加上CLASS_ISPREVERIFIED，使用插桩，单独放一个帮助类在独立的dex中让其他类调用。</li>
</ul>
<h2 id="dex替换"><a href="#dex替换" class="headerlink" title="dex替换"></a>dex替换</h2><h2 id="原理及实现-3"><a href="#原理及实现-3" class="headerlink" title="原理及实现"></a>原理及实现</h2><p>为了避免dex插桩带来的性能损耗，dex替换采取另外的方式。原理是提供dex差量包，整体替换dex的方案。差量的方式给出patch.dex，然后将patch.dex与应用的classes.dex合并成一个完整的dex，完整dex加载得到dexFile对象作为参数构建一个Element对象然后整体替换掉旧的dex-Elements数组。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5125122-7026bc1d835a9f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片引用自TInker介绍"><br>)</p>
<p>这也是微信Tinker采用的方案，并且Tinker自研了DexDiff/DexMerge算法。Tinker还支持资源和So包的更新，So补丁包使用BsDiff来生成，资源补丁包直接使用文件md5对比来生成，针对资源比较大的（默认大于100KB属于大文件）会使用BsDiff来对文件生成差量补丁。</p>
<p>下面我们关键看看Tinker的实现源码，当然具体的实现算法很复杂，我们只看关键的实现，最后的修复在UpgradePatch中的tryPatch方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) &#123;</div><div class="line">      //省略一堆校验</div><div class="line">      ... ....</div><div class="line"></div><div class="line">      //下面是关键的diff算法及合并实现，实现相对复杂，感兴趣可以再仔细阅读源码</div><div class="line">      //we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</div><div class="line">      if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">          TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch dex failed&quot;);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">          TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch library failed&quot;);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">          TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch resource failed&quot;);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</div><div class="line">      if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</div><div class="line">          TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, check dex opt file failed&quot;);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</div><div class="line">          TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, rewrite patch info failed&quot;);</div><div class="line">          manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      TinkerLog.w(TAG, &quot;UpgradePatch tryPatch: done, it is ok&quot;);</div><div class="line">      return true;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>兼容性高</li>
<li>补丁小</li>
<li>开发透明，代码非侵入式</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>冷启动修复，下次启动修复</li>
<li>Dex合并内存消耗在vm head上，容易OOM，最后导致合并失败</li>
</ul>
<h2 id="资源修复原理"><a href="#资源修复原理" class="headerlink" title="资源修复原理"></a>资源修复原理</h2><h3 id="Instant-Run"><a href="#Instant-Run" class="headerlink" title="Instant Run"></a>Instant Run</h3><p>1、构建一个新的AssetManager，并通过反射调用addAssertPath，把这个完整的新资源包加入到AssetManager中。这样就得到一个含有所有新资源的AssetManager</p>
<p>2、找到所有值钱引用到原有AssetManager的地方，通过反射，把引用处替换为AssetManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">public static void monkeyPatchExistingResources(Context context,</div><div class="line">                                                   String externalResourceFile, Collection activities) &#123;</div><div class="line">       if (externalResourceFile == null) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       try &#123;</div><div class="line">           //反射一个新的   AssetManager</div><div class="line">           AssetManager newAssetManager = (AssetManager) AssetManager.class</div><div class="line">                   .getConstructor(new Class[0]).newInstance(new Object[0]);</div><div class="line">          //反射 addAssetPath 添加新的资源包</div><div class="line">           Method mAddAssetPath = AssetManager.class.getDeclaredMethod(&quot;addAssetPath&quot;, new Class[]&#123;String.class&#125;);</div><div class="line">           mAddAssetPath.setAccessible(true);</div><div class="line">           if (((Integer) mAddAssetPath.invoke(newAssetManager,</div><div class="line">                   new Object[]&#123;externalResourceFile&#125;)).intValue() == 0) &#123;</div><div class="line">               throw new IllegalStateException(</div><div class="line">                       &quot;Could not create new AssetManager&quot;);</div><div class="line">           &#125;</div><div class="line">           Method mEnsureStringBlocks = AssetManager.class.getDeclaredMethod(&quot;ensureStringBlocks&quot;, new Class[0]);</div><div class="line">           mEnsureStringBlocks.setAccessible(true);</div><div class="line">           mEnsureStringBlocks.invoke(newAssetManager, new Object[0]);</div><div class="line">           //反射得到Activity中AssetManager的引用处，全部换成刚新构建的AssetManager对象</div><div class="line">           if (activities != null) &#123;</div><div class="line">               for (Activity activity : activities) &#123;</div><div class="line">                   Resources resources = activity.getResources();</div><div class="line">                   try &#123;</div><div class="line">                       Field mAssets = Resources.class.getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                       mAssets.setAccessible(true);</div><div class="line">                       mAssets.set(resources, newAssetManager);</div><div class="line">                   &#125; catch (Throwable ignore) &#123;</div><div class="line">                       Field mResourcesImpl = Resources.class.getDeclaredField(&quot;mResourcesImpl&quot;);</div><div class="line">                       mResourcesImpl.setAccessible(true);</div><div class="line">                       Object resourceImpl = mResourcesImpl.get(resources);</div><div class="line">                       Field implAssets = resourceImpl.getClass().getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                       implAssets.setAccessible(true);</div><div class="line">                       implAssets.set(resourceImpl, newAssetManager);</div><div class="line">                   &#125;</div><div class="line">                   Resources.Theme theme = activity.getTheme();</div><div class="line">                   try &#123;</div><div class="line">                       try &#123;</div><div class="line">                           Field ma = Resources.Theme.class.getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                           ma.setAccessible(true);</div><div class="line">                           ma.set(theme, newAssetManager);</div><div class="line">                       &#125; catch (NoSuchFieldException ignore) &#123;</div><div class="line">                           Field themeField = Resources.Theme.class.getDeclaredField(&quot;mThemeImpl&quot;);</div><div class="line">                           themeField.setAccessible(true);</div><div class="line">                           Object impl = themeField.get(theme);</div><div class="line">                           Field ma = impl.getClass().getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                           ma.setAccessible(true);</div><div class="line">                           ma.set(impl, newAssetManager);</div><div class="line">                       &#125;</div><div class="line">                       Field mt = ContextThemeWrapper.class.getDeclaredField(&quot;mTheme&quot;);</div><div class="line">                       mt.setAccessible(true);</div><div class="line">                       mt.set(activity, null);</div><div class="line">                       Method mtm = ContextThemeWrapper.class.getDeclaredMethod(&quot;initializeTheme&quot;, new Class[0]);</div><div class="line">                       mtm.setAccessible(true);</div><div class="line">                       mtm.invoke(activity, new Object[0]);</div><div class="line">                       Method mCreateTheme = AssetManager.class.getDeclaredMethod(&quot;createTheme&quot;, new Class[0]);</div><div class="line">                       mCreateTheme.setAccessible(true);</div><div class="line">                       Object internalTheme = mCreateTheme.invoke(newAssetManager, new Object[0]);</div><div class="line">                       Field mTheme = Resources.Theme.class.getDeclaredField(&quot;mTheme&quot;);</div><div class="line">                       mTheme.setAccessible(true);</div><div class="line">                       mTheme.set(theme, internalTheme);</div><div class="line">                   &#125; catch (Throwable e) &#123;</div><div class="line">                       Log.e(&quot;InstantRun&quot;,</div><div class="line">                               &quot;Failed to update existing theme for activity &quot;</div><div class="line">                                       + activity, e);</div><div class="line">                   &#125;</div><div class="line">                   pruneResourceCaches(resources);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           Collection references;</div><div class="line">           if (Build.VERSION.SDK_INT &gt;= 19) &#123;</div><div class="line">               Class resourcesManagerClass = Class.forName(&quot;android.app.ResourcesManager&quot;);</div><div class="line">               Method mGetInstance = resourcesManagerClass.getDeclaredMethod(&quot;getInstance&quot;, new Class[0]);</div><div class="line">               mGetInstance.setAccessible(true);</div><div class="line">               Object resourcesManager = mGetInstance.invoke(null, new Object[0]);</div><div class="line">               try &#123;</div><div class="line">                   Field fMActiveResources = resourcesManagerClass.getDeclaredField(&quot;mActiveResources&quot;);</div><div class="line">                   fMActiveResources.setAccessible(true);</div><div class="line">                   ArrayMap  arrayMap = (ArrayMap) fMActiveResources.get(resourcesManager);</div><div class="line">                   references = arrayMap.values();</div><div class="line">               &#125; catch (NoSuchFieldException ignore) &#123;</div><div class="line">                   Field mResourceReferences = resourcesManagerClass.getDeclaredField(&quot;mResourceReferences&quot;);</div><div class="line">                   mResourceReferences.setAccessible(true);</div><div class="line">                   references = (Collection) mResourceReferences.get(resourcesManager);</div><div class="line">               &#125;</div><div class="line">           &#125; else &#123;</div><div class="line">               Class activityThread = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class="line">               Field fMActiveResources = activityThread.getDeclaredField(&quot;mActiveResources&quot;);</div><div class="line">               fMActiveResources.setAccessible(true);</div><div class="line">               Object thread = getActivityThread(context, activityThread);</div><div class="line">               HashMap  map = (HashMap) fMActiveResources.get(thread);</div><div class="line">               references = map.values();</div><div class="line">           &#125;</div><div class="line">           for (WeakReference wr : references) &#123;</div><div class="line">               Resources resources = (Resources) wr.get();</div><div class="line">               if (resources != null) &#123;</div><div class="line">                   try &#123;</div><div class="line">                       Field mAssets = Resources.class.getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                       mAssets.setAccessible(true);</div><div class="line">                       mAssets.set(resources, newAssetManager);</div><div class="line">                   &#125; catch (Throwable ignore) &#123;</div><div class="line">                       Field mResourcesImpl = Resources.class.getDeclaredField(&quot;mResourcesImpl&quot;);</div><div class="line">                       mResourcesImpl.setAccessible(true);</div><div class="line">                       Object resourceImpl = mResourcesImpl.get(resources);</div><div class="line">                       Field implAssets = resourceImpl.getClass().getDeclaredField(&quot;mAssets&quot;);</div><div class="line">                       implAssets.setAccessible(true);</div><div class="line">                       implAssets.set(resourceImpl, newAssetManager);</div><div class="line">                   &#125;</div><div class="line">                   resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; catch (Throwable e) &#123;</div><div class="line">           throw new IllegalStateException(e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="so修复原理"><a href="#so修复原理" class="headerlink" title="so修复原理"></a>so修复原理</h2><h3 id="接口调用替换"><a href="#接口调用替换" class="headerlink" title="接口调用替换"></a>接口调用替换</h3><p>sdk提供接口替换System默认加载so库的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SOPatchManger.loadLibrary(String libName)</div><div class="line">替换</div><div class="line">System.loadLibrary(String libName)</div></pre></td></tr></table></figure></p>
<p>SOPatchManger.loadLibrary接口加载so库的时候优先尝试去加载sdk指定目录下补丁的so。若不存在，则再去加载安装apk目录下的so库</p>
<p>优点：不需要对不同sdk版本进行兼容，所以sdk版本都是System.loadLibrary这个接口</p>
<p>缺点：需要侵入业务代码，替换掉System默认加载so库的接口</p>
<h3 id="反射注入"><a href="#反射注入" class="headerlink" title="反射注入"></a>反射注入</h3><p>采取类似类修复反射注入方式，只要把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public String findLibrary(String libraryName) &#123;</div><div class="line">        String fileName = System.mapLibraryName(libraryName);</div><div class="line"></div><div class="line">        for (NativeLibraryElement element : nativeLibraryPathElements) &#123;</div><div class="line">            String path = element.findNativeLibrary(fileName);</div><div class="line"></div><div class="line">            if (path != null) &#123;</div><div class="line">                return path;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>优点：不需侵入用户接口调用</p>
<p>缺点：需要做版本兼容控制，兼容性较差</p>
<h1 id="使用热修复技术有哪些需要注意的问题？"><a href="#使用热修复技术有哪些需要注意的问题？" class="headerlink" title="使用热修复技术有哪些需要注意的问题？"></a>使用热修复技术有哪些需要注意的问题？</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>使用热修复技术后由于发布流程的变化，肯定也需求采用相应的分支管理进行控制。</p>
<p>通常移动开发的分支管理采用特性分支，如下：</p>
<table>
<thead>
<tr>
<th>分支</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td>主分支（只能merge，不能commit，设置权限），用于管理线上版本，及时设置对应Tag</td>
</tr>
<tr>
<td>dev</td>
<td>开发分支，每个新版本的研发根据版本号基于主分支创建，测试通过验证后，上线合入master分支</td>
</tr>
<tr>
<td>function X</td>
<td>功能分支，按需求设定。基于开发分支创建，完成功能开发后合入dev开发分支</td>
</tr>
</tbody>
</table>
<p>接入热修复后，推荐可参考如下分支策略：<br>分支 | 描述<br>—|—<br>master | 主分支（只能merge，不能commit，设置权限），用于管理线上版本，及时设置对应Tag（一般3位版本号）<br>hot_fix | 热修复分支。基于master分支创建，修复紧急问题后，测试推送后，将hot_fix再合并到master分支。再次为master分支打tag。（一般4位版本号）<br>dev  | 开发分支，每个新版本的研发根据版本号基于主分支创建，测试通过验证后，上线合入master分支<br>function X|功能分支，按需求设定。基于开发分支创建，完成功能开发后合入dev开发分支</p>
<p>注意热修复分支的测试及发布流程应用正常版本流程一致，保证质量。</p>
<h2 id="分发监控"><a href="#分发监控" class="headerlink" title="分发监控"></a>分发监控</h2><p>目前主流的热修复方案，像Tinker及Sophix都会提供补丁的分发及监控。这也是我们选择热修复技术方案需要考虑的关键因素之一。毕竟为了保证线上版本的质量，分发控制及实时监测必不可少。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android热修复技术发展至今已经是百花齐放，各大厂也都推出了自己的技术框架。也有像阿里推出的《深入探索Android热修复技术原理》对热修复技术的深入解读。本文大部分总结也都参考这本经典。鉴于热修复技术的多种多样，所以才决定进行梳理，提供选择时的一些注意事项及参考建议，也加深自己对热修复技术的理解。总的来说，还是收获满满。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix源码</a></p>
<p><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa源码</a></p>
<p><a href="https://github.com/Tencent/tinker/wiki" target="_blank" rel="external">Tinker官方介绍</a></p>
<p><a href="http://w4lle.com/2017/03/31/robust-0/" target="_blank" rel="external">Android热补丁之Robust原理解析(一)</a></p>
<p><a href="https://www.cnblogs.com/popfisher/p/8543973.html" target="_blank" rel="external">Android热修复技术原理详解（最新最全版本）</a></p>
<p>《深入探索Android热修复技术原理》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/09/05/rxjava2-x源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/05/rxjava2-x源码学习随笔/" itemprop="url">
                  rxjava2.x源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T16:27:49+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/rxjava2-x源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/05/rxjava2-x源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="rxjava是什么？"><a href="#rxjava是什么？" class="headerlink" title="rxjava是什么？"></a>rxjava是什么？</h1><h2 id="ReactiveX"><a href="#ReactiveX" class="headerlink" title="ReactiveX"></a>ReactiveX</h2><p>ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET。</p>
<h2 id="rxjava"><a href="#rxjava" class="headerlink" title="rxjava"></a>rxjava</h2><p>rxjava是ReactiveX在java平台的一个实现。是一个编程模型，以观察者模式提供链式的接口调用，动态控制线程的切换，使得可以简便的处理异步数据流。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Github:<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">rxjava</a></p>
<p>中文文档：<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="external">ReactiveX/RxJava文档中文版</a></p>
<p>官网：<a href="http://reactivex.io/" target="_blank" rel="external">reactivex</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>链式调用，使用简单</li>
<li>简化逻辑</li>
<li>灵活的线程调度</li>
<li>提供完善的数据操作符，功能强大</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p> 观察者模式定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所以依赖于它的对象都会得到通知并被自动更新。rxjava的核心设计就是采用观察者模式。Observable是被观察者，Observer是观察者，通过subscribe方法进行订阅。</p>
<ul>
<li>优点</li>
</ul>
<p>观察者和被观察者之间是抽象解耦，应对业务变化</p>
<p>增强系统灵活性、可扩展性</p>
<p>具体代码示例可参考<a href="https://junbin1011.github.io/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-观察者模式</a></p>
<ul>
<li>缺点</li>
</ul>
<p>在应用观察者模式时需要考虑一下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式</p>
<h1 id="rxjava怎么用？"><a href="#rxjava怎么用？" class="headerlink" title="rxjava怎么用？"></a>rxjava怎么用？</h1><p>gradle引入版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">implementation &apos;io.reactivex.rxjava2:rxjava:2.2.0&apos;</div><div class="line">implementation &apos;io.reactivex.rxjava2:rxandroid:2.1.0&apos;</div></pre></td></tr></table></figure></p>
<p> 接着举一个常用的rxjava使用的例子，我们在项目经常需要请求服务端接口，然后获取数据，将数据进行缓存，然后处理ui上的显示。示例的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Response&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public void subscribe(ObservableEmitter&lt;Response&gt; e) throws Exception &#123;</div><div class="line">             //获取服务端的接口数据</div><div class="line">             Request.Builder builder = new Request.Builder()</div><div class="line">                     .url(&quot;http://xxx.com&quot;)</div><div class="line">                     .get();</div><div class="line">             Request request = builder.build();</div><div class="line">             Call call = new OkHttpClient().newCall(request);</div><div class="line">             Response response = call.execute();</div><div class="line">             e.onNext(response);</div><div class="line">         &#125;</div><div class="line">     &#125;).map(new Function&lt;Response, Model&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public Model apply( Response response) throws Exception &#123;</div><div class="line">             //将json数据转化为对应的Model</div><div class="line">             if (response.isSuccessful()) &#123;</div><div class="line">                 ResponseBody body = response.body();</div><div class="line">                 if (body != null) &#123;</div><div class="line">                     Log.e(TAG, &quot;map:转换前:&quot; + response.body());</div><div class="line">                     return new Gson().fromJson(body.string(), Model.class);</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             return null;</div><div class="line">         &#125;</div><div class="line">     &#125;).doOnNext(new Consumer&lt;Model&gt;() &#123;</div><div class="line">                 @Override</div><div class="line">                 public void accept( Model s) throws Exception &#123;</div><div class="line">                     //对数据进行其他缓存的处理</div><div class="line">                     Log.e(TAG, &quot;doOnNext: 保存网络加载的数据：&quot; + s.toString() + &quot;\n&quot;);</div><div class="line">                 &#125;</div><div class="line">             &#125;).subscribeOn(Schedulers.io())</div><div class="line">             .observeOn(AndroidSchedulers.mainThread())</div><div class="line">             .subscribe(new Consumer&lt;Model&gt;() &#123;</div><div class="line">                 @Override</div><div class="line">                 public void accept(Model model) throws Exception &#123;</div><div class="line">                     //刷新ui</div><div class="line">                     Log.e(TAG, &quot;成功刷新界面:&quot; + data.toString() + &quot;\n&quot;);</div><div class="line">                 &#125;</div><div class="line">             &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                 @Override</div><div class="line">                 public void accept(Throwable throwable) throws Exception &#123;</div><div class="line">                     //进行失败的异常提示</div><div class="line">                     Log.e(TAG, &quot;失败处理异常：&quot; + throwable.getMessage() + &quot;\n&quot;);</div><div class="line">                 &#125;</div><div class="line">             &#125;);</div></pre></td></tr></table></figure>
<p>本文主要对rxjava的源码进行梳理分析，关于rxjava操作符的使用，推荐参考中文的文档，以及下面的博文介绍。</p>
<p><a href="https://www.jianshu.com/p/0cd258eecf60" target="_blank" rel="external">这可能是最好的RxJava 2.x 教程（完结版）</a></p>
<h1 id="rxjava核心执行流程是怎样？"><a href="#rxjava核心执行流程是怎样？" class="headerlink" title="rxjava核心执行流程是怎样？"></a>rxjava核心执行流程是怎样？</h1><p>rxjava主要是采用观察者模式进行设计，当执行相关的操作符是会生成新的Observable及Observer。Observable会持有上游被观察者，Observer会持有下游的观察者。当执行subscribe订阅方法的时候，通过持有上游的被观察者对象，会往上游逐步执行订阅方法。当执行到起始的被观察者回调方法时，如果执行ObservableEmitter的onNext方法时，由于Observer会持有下游的Observer对象，会逐步调用下游的onNext方法，直到最终subscribe传入的观察者实例。这是rxjava链式调用的核心执行流程。</p>
<p>当然rxjava还涉及到线程的调度及数据的背压处理，关于这些实现的原理会再后续进行梳理。但rxjava的链式调用的核心执行流程都是一致。下面我们将通过2个部分来梳理rxjava的核心执行流程，包含一些关键类的说明，及通过示例的代码相关的执行流程图进行梳理。</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td> ObservableSource</td>
<td>接口类，只有一个subscribe方法，参数是Observer对象</td>
</tr>
<tr>
<td> Observer</td>
<td>接口类，观察者。有onSubscribe、onNext、onError、onComplete方法</td>
</tr>
<tr>
<td> Consumer</td>
<td>接口有，观察者。只有一个accept方法，在被订阅时最终也会转换成Observer，设计这个类是为了简化调用</td>
</tr>
<tr>
<td> Observable</td>
<td>抽象类，继承了ObservableSource接口，操作符的实现都是继承与它。内部封装了大量的操作符调用方法，主要是有一个核心的抽象方法abstract void subscribeActual(Observer&lt;? super T&gt; observer)，用于实现相关的订阅分发逻辑。</td>
</tr>
<tr>
<td> AbstractObservableWithUpstream</td>
<td>继承于Observable，构造方法需要传入ObservableSource<t> source对象，source是父被观察者。</t></td>
</tr>
<tr>
<td> ObservableCreate</td>
<td>继承于AbstractObservableWithUpstream，source为ObservableOnSubscribe。subscribeActual方法会实例化一个CreateEmitter对象，执行ObservableOnSubscribe的subscribe方法</td>
</tr>
<tr>
<td> ObservableMap</td>
<td>继承于AbstractObservableWithUpstream，订阅会新生产一个观察者MapObserver</td>
</tr>
<tr>
<td> MapObserver</td>
<td>ObservableMap的内部类，onNext方法会触发mapper.apply(t)回调，然后执行下游观察者的onNext方法</td>
</tr>
<tr>
<td> ObservableDoOnEach</td>
<td>继承于AbstractObservableWithUpstream，订阅会新生产一个观察者DoOnEachObserver</td>
</tr>
<tr>
<td> DoOnEachObserver</td>
<td>ObservableDoOnEach的内部类，onNext会执行onNext.accept(t)方法，然后执行下游观察者的onNext方法</td>
</tr>
<tr>
<td> ObservableSubscribeOn</td>
<td>继承于AbstractObservableWithUpstream，被观察者线程调度控制。subscribeActual会执行scheduler.scheduleDirect(new SubscribeTask(parent))，SubscribeTask的run方法会执行source.subscribe(parent)。ObservableSubscribeOn根据线程调度器的策略去执行上游的订阅方法实现。</td>
</tr>
<tr>
<td> ObservableObserveOn</td>
<td>继承于AbstractObservableWithUpstream，观察者线程调度控制。subscribeActual方法会判断scheduler是否为TrampolineScheduler。若是则执行下游的观察者，否会创建新的ObserveOnObserver，并传入schedule的work。</td>
</tr>
<tr>
<td> ObserveOnObserver</td>
<td>ObservableObserveOn内部类，onNext会触发执行schedule（）方法，根据worker去控制下游观察者的回调线程</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>首先我们根据上面demo例子，梳理出rxjava的简单执行流程，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/5125122-a863e73ba5777198?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>通过流程图可知，rxjava当执行相关的操作符是会生成新的Observable及Observer。Observable会持有上游被观察者，Observer会持有下游的观察者。当执行subscribe订阅方法的时候，通过持有上游的被观察者对象，会往上游逐步执行订阅方法。当执行到起始的被观察者回调方法时，如果执行ObservableEmitter的onNext方法时，由于Observer会持有下游的Observer对象，会逐步调用下游的onNext方法，直到最终subscribe传入的观察者实例。</p>
<p> 了解了rxjava大致的执行流程，下面我们来详细的看看源码的执行流程。首先还是先上一下整体的流程图，由于图片较大，建议结合上述的demo及rxjava的源码进行查看。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-844ed90793607aa1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>下面我们分配通过几个操作符来看看rxjava源码具体的实现。</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>create的操作符会返回一个ObservableCreate的被观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">      ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</div><div class="line">      return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>接下来看看ObservableCreate对象的关键实现代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//构造方法会传入ObservableOnSubscribe接口的引用，指定为该被观察者的source。</div><div class="line"> public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">       this.source = source;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> //核心的subscribeActual </div><div class="line">   @Override</div><div class="line">   protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">     //创建了CreateEmitter发射器</div><div class="line">       CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</div><div class="line">       observer.onSubscribe(parent);</div><div class="line"></div><div class="line">       try &#123;</div><div class="line">         //执行了ObservableOnSubscribe的subscribe回调方法，传入了CreateEmitter对象</div><div class="line">           source.subscribe(parent);</div><div class="line">       &#125; catch (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           parent.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>当我们在业务代码执行了ObservableEmitter的onNext方法，我们看一下CreateEmitter的onNext的实现代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> //持有下游的观察者引用</div><div class="line">CreateEmitter(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">         this.observer = observer;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     @Override</div><div class="line">     public void onNext(T t) &#123;</div><div class="line">         if (t == null) &#123;</div><div class="line">             onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">             return;</div><div class="line">         &#125;</div><div class="line">         //如果没有取消订阅，则会执行下游的观察者的onNext方法，达到链式调用的效果</div><div class="line">         if (!isDisposed()) &#123;</div><div class="line">             observer.onNext(t);</div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的操作符会返回一个ObservableMap的被观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@CheckReturnValue</div><div class="line">  @SchedulerSupport(SchedulerSupport.NONE)</div><div class="line">  public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123;</div><div class="line">      ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</div><div class="line">      return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>接下来看看ObservableMap对象的关键实现代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</div><div class="line">    //将上游的被观察者订阅MapObserver观察者</div><div class="line">    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来主要看看MapObserver的onNext方法，该方法会在ObservableEmitter的onNext方法触发后被调用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  //持有下游的观察者和回调函数mapper</div><div class="line">  MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123;</div><div class="line">           super(actual);</div><div class="line">           this.mapper = mapper;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">@Override</div><div class="line">       public void onNext(T t) &#123;</div><div class="line">           if (done) &#123;</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           if (sourceMode != NONE) &#123;</div><div class="line">               actual.onNext(null);</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           U v;</div><div class="line"></div><div class="line">           try &#123;</div><div class="line">             //map的核心执行代码，mapper.apply(t)会执行数据的转换，并将转换后的结果v继续交由下游的观察者执行</div><div class="line">               v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);</div><div class="line">           &#125; catch (Throwable ex) &#123;</div><div class="line">               fail(ex);</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">           //将转换后的结果v继续交由下游的观察者执行</div><div class="line">           actual.onNext(v);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h3><p>doOnNext的操作符会返回一个ObservableDoOnEach的被观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Observable&lt;T&gt; doOnEach(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) &#123;</div><div class="line">    ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</div><div class="line">    ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</div><div class="line">    ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</div><div class="line">    ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableDoOnEach&lt;T&gt;(this, onNext, onError, onComplete, onAfterTerminate));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看看ObservableDoOnEach对象的关键实现代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void subscribeActual(Observer&lt;? super T&gt; t) &#123;</div><div class="line">   //实例化一个DoOnEachObserver的观察者对象</div><div class="line">    source.subscribe(new DoOnEachObserver&lt;T&gt;(t, onNext, onError, onComplete, onAfterTerminate));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里核心我们还是要看DoOnEachObserver的onNext对于数据的处理，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">      public void onNext(T t) &#123;</div><div class="line">          if (done) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          try &#123;</div><div class="line">              //回调accept方法</div><div class="line">              onNext.accept(t);</div><div class="line">          &#125; catch (Throwable e) &#123;</div><div class="line">              Exceptions.throwIfFatal(e);</div><div class="line">              s.dispose();</div><div class="line">              onError(e);</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          //继续往下游调用观察者的onNext</div><div class="line">          actual.onNext(t);</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>subscribeOn的操作符会返回一个ObservableSubscribeOn的被观察者，并传入scheduler线程调度参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@CheckReturnValue</div><div class="line">@SchedulerSupport(SchedulerSupport.CUSTOM)</div><div class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看看ObservableSubscribeOn对象的关键实现代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123;</div><div class="line">    super(source);</div><div class="line">    this.scheduler = scheduler;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void subscribeActual(final Observer&lt;? super T&gt; s) &#123;</div><div class="line">    //创建了SubscribeOnObserver的观察者</div><div class="line">    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);</div><div class="line"></div><div class="line">    s.onSubscribe(parent);</div><div class="line">    </div><div class="line">    //这个是核心方法，调用了线程调度去的scheduleDirect方法，并传入SubscribeTask任务</div><div class="line">    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看看SubscribeTask的实现，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">final class SubscribeTask implements Runnable &#123;</div><div class="line">      private final SubscribeOnObserver&lt;T&gt; parent;</div><div class="line"></div><div class="line">      SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</div><div class="line">          this.parent = parent;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public void run() &#123;</div><div class="line">          //执行上游被观察的订阅方法，这里就是subscribeOn将上游的订阅方法控制在scheduler指定线程执行的核心</div><div class="line">          source.subscribe(parent);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最后看下SubscribeOnObserver的onNext方法，比较简单，直接执行下游观察者的onNext方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">     public void onNext(T t) &#123;</div><div class="line">         actual.onNext(t);</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>关于scheduler的具体实现，在后续的线程原理进行分析。这里我们只需要知道上游的被观察者的订阅在指定的scheduler线程策略中执行就可以了。</p>
<h3 id="observerOn"><a href="#observerOn" class="headerlink" title="observerOn"></a>observerOn</h3><p>observerOn 的操作符会返回一个ObservableObserveOn的被观察者，并传入scheduler线程调度参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> @CheckReturnValue</div><div class="line">@SchedulerSupport(SchedulerSupport.CUSTOM)</div><div class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</div><div class="line">    ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看看ObservableObserveOn对象的关键实现代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    //TrampolineScheduler 如果是当前的线程 则直接将下游的观察者与上游的被观察订阅</div><div class="line">     if (scheduler instanceof TrampolineScheduler) &#123;</div><div class="line">         source.subscribe(observer);</div><div class="line">     &#125; else &#123;</div><div class="line">         //其他线程策略</div><div class="line">         Scheduler.Worker w = scheduler.createWorker();</div><div class="line">         //将线程策略的worker传入ObserveOnObserver观察者</div><div class="line">         source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>接下来关键还是看ObserveOnObserver的实现，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onNext(T t) &#123;</div><div class="line">    // 上一级的模式如果不是异步的，加入队列</div><div class="line">    if (sourceMode != QueueDisposable.ASYNC) &#123;</div><div class="line">        queue.offer(t);</div><div class="line">    &#125;</div><div class="line">    //进行线程调度</div><div class="line">    schedule();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void schedule() &#123;</div><div class="line">    // 判断当前正在执行的任务数目</div><div class="line">    if (getAndIncrement() == 0) &#123;</div><div class="line">        worker.schedule(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ObserveOnObserver本身继承了Runnable接口，run方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    //输出结果是否融合</div><div class="line">    if (outputFused) &#123;</div><div class="line">        drainFused();</div><div class="line">    &#125; else &#123;</div><div class="line">        drainNormal();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先进入drainNormal方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void drainNormal() &#123;</div><div class="line">    int missed = 1;</div><div class="line">    final SimpleQueue&lt;T&gt; q = queue;</div><div class="line">    final Observer&lt;? super T&gt; a = actual;</div><div class="line">    //第一层循环</div><div class="line">    for (;;) &#123;</div><div class="line">        // 检查异常处理</div><div class="line">        if (checkTerminated(done, q.isEmpty(), a)) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //第二层循环</div><div class="line">        for (;;) &#123;</div><div class="line">            boolean d = done;</div><div class="line">            T v;</div><div class="line">            //从队列中获取数据</div><div class="line">            v = q.poll();</div><div class="line">            boolean empty = v == null;</div><div class="line">            // 检查异常</div><div class="line">            if (checkTerminated(d, empty, a)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            //如果没有数据了，跳出</div><div class="line">            if (empty) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            //执行下一次操作。</div><div class="line">            a.onNext(v);</div><div class="line">        &#125;</div><div class="line">        //减掉执行的次数，并获取剩于任务数量，然后再次循环</div><div class="line">        //直到获取剩余任务量为0，跳出循环</div><div class="line">        missed = addAndGet(-missed);</div><div class="line">        if (missed == 0) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于scheduler的具体实现，在后续的线程原理进行分析。这里我们只需要知道下游的观察者的onNext在指定的scheduler线程策略中执行就可以了。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@SchedulerSupport(SchedulerSupport.NONE)</div><div class="line">   @Override</div><div class="line">   public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">       ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</div><div class="line">       try &#123;</div><div class="line">           observer = RxJavaPlugins.onSubscribe(this, observer);</div><div class="line"></div><div class="line">           ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;);</div><div class="line"></div><div class="line">           subscribeActual(observer);</div><div class="line">       &#125; catch (NullPointerException e) &#123; // NOPMD</div><div class="line">           throw e;</div><div class="line">       &#125; catch (Throwable e) &#123;</div><div class="line">           Exceptions.throwIfFatal(e);</div><div class="line">           // can&apos;t call onError because no way to know if a Disposable has been set or not</div><div class="line">           // can&apos;t call onSubscribe because the call might have set a Subscription already</div><div class="line">           RxJavaPlugins.onError(e);</div><div class="line"></div><div class="line">           NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;);</div><div class="line">           npe.initCause(e);</div><div class="line">           throw npe;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 最后的订阅方法在做了非空检查后，会调用subscribeActual方法，开始往上游逐层执行订阅。</p>
<h1 id="被观察者Observable是如何发送数据？"><a href="#被观察者Observable是如何发送数据？" class="headerlink" title="被观察者Observable是如何发送数据？"></a>被观察者Observable是如何发送数据？</h1><p>通过上面的流程分析，我们可以知道。如果使用create创建了Observable，在ObservableOnSubscribe的subscribe方法中会通过ObservableEmitter的onNext去发送数据，onNext会触发开始往下游观察者传递数据。当然rxjava的创建型操作符还有很多，如just、from等，本质最后都是触发下游观察者的onNext进行数据的发送。</p>
<h1 id="观察者Observer是如何接收到数据的？"><a href="#观察者Observer是如何接收到数据的？" class="headerlink" title="观察者Observer是如何接收到数据的？"></a>观察者Observer是如何接收到数据的？</h1><p>通过源码分析，每一个链层的Observer都会持有相邻下游的Observer对象，当开始发送数据时，会依次链式执行Observer的onNext方法，最后执行到subscribe方法中创建的Observer对象。</p>
<h1 id="被观察者和观察者之间是如何实现订阅？"><a href="#被观察者和观察者之间是如何实现订阅？" class="headerlink" title="被观察者和观察者之间是如何实现订阅？"></a>被观察者和观察者之间是如何实现订阅？</h1><p>每一个链层的Observable 都会持有相邻上游的Observable对象，在subscribe方法开始调用后，最后会执行到subscribeActual方法，在subscribeActual方法中会将观察者与上游的被观察执行订阅。</p>
<h1 id="rxjava是如何进行线程的调度？"><a href="#rxjava是如何进行线程的调度？" class="headerlink" title="rxjava是如何进行线程的调度？"></a>rxjava是如何进行线程的调度？</h1><p>rxjava的Scheduler有很多种实现，下面我们介绍Scheduler的相关说明，然后通过最常用的.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())来分析具体的线程调度流程。</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p> 我们在调用subscribeOn与observeOn时，都会传入Scheduler对象，首先我们先看一下Scheduler的种类及其功能</p>
<table>
<thead>
<tr>
<th>Scheduler种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schedulers.io( )</td>
<td>用于IO密集型的操作，例如读写SD卡文件，查询数据库，访问网络等，具有线程缓存机制，在此调度器接收到任务后，先检查线程缓存池中，是否有空闲的线程，如果有，则复用，如果没有则创建新的线程，并加入到线程池中，如果每次都没有空闲线程使用，可以无上限的创建新线程</td>
</tr>
<tr>
<td>Schedulers.newThread( )</td>
<td>在每执行一个任务时创建一个新的线程，不具有线程缓存机制，因为创建一个新的线程比复用一个线程更耗时耗力，虽然使用Schedulers.io( )的地方，都可以使用Schedulers.newThread( )，但是，Schedulers.newThread( )的效率没有Schedulers.io( )高</td>
</tr>
<tr>
<td>Schedulers.computation()</td>
<td>用于CPU 密集型计算任务，即不会被 I/O 等操作限制性能的耗时操作，例如xml,json文件的解析，Bitmap图片的压缩取样等，具有固定的线程池，大小为CPU的核数。不可以用于I/O操作，因为I/O操作的等待时间会浪费CPU</td>
</tr>
<tr>
<td>Schedulers.trampoline()</td>
<td>在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行</td>
</tr>
<tr>
<td>Schedulers.single()</td>
<td>拥有一个线程单例，所有的任务都在这一个线程中执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行</td>
</tr>
<tr>
<td>Scheduler.from(Executor executor)</td>
<td>指定一个线程调度器，由此调度器来控制任务的执行策略</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>在Android UI线程中执行任务，为Android开发定制</td>
</tr>
</tbody>
</table>
<h2 id="subscribeOn-Schedulers-io"><a href="#subscribeOn-Schedulers-io" class="headerlink" title="subscribeOn(Schedulers.io())"></a>subscribeOn(Schedulers.io())</h2><p> 根据上面的分析，subscribeOn()方法最后会执行到subscribeActual方法，SubscribeTask上面分析了，继承了Runnable接口， run方法最后会执行source.subscribe(parent)方法。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void subscribeActual(final Observer&lt;? super T&gt; s) &#123;</div><div class="line">       final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);</div><div class="line"></div><div class="line">       s.onSubscribe(parent);</div><div class="line">       </div><div class="line">       parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>  这里我们主要要分析scheduler.scheduleDirect()方法。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@NonNull</div><div class="line"> public Disposable scheduleDirect(@NonNull Runnable run) &#123;</div><div class="line">     return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">  @NonNull</div><div class="line"> public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123;</div><div class="line">   //创建一个Worker对象</div><div class="line">     final Worker w = createWorker();</div><div class="line"></div><div class="line"></div><div class="line">     final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line">     </div><div class="line">     //DisposeTasky也是一个包装类 继承了Runnable接口</div><div class="line">     DisposeTask task = new DisposeTask(decoratedRun, w);</div><div class="line"></div><div class="line">     //这里是关键的实现，执行了worker的schedule方法</div><div class="line">     w.schedule(task, delay, unit);</div><div class="line"></div><div class="line">     return task;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  Worker的schedule是一个抽象的方法，Schedulers.io()对应的Worker实现为EventLoopWorker。我们看看EventLoopWorker的schedule实现如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">   static final class EventLoopWorker extends Scheduler.Worker &#123;</div><div class="line">    private final CompositeDisposable tasks;</div><div class="line">    private final CachedWorkerPool pool;</div><div class="line">    private final ThreadWorker threadWorker;</div><div class="line"></div><div class="line">    final AtomicBoolean once = new AtomicBoolean();</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        this.pool = pool;</div><div class="line">        this.tasks = new CompositeDisposable();</div><div class="line">        this.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void dispose() &#123;</div><div class="line">        if (once.compareAndSet(false, true)) &#123;</div><div class="line">            tasks.dispose();</div><div class="line"></div><div class="line">            // releasing the pool should be the last action</div><div class="line">            pool.release(threadWorker);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isDisposed() &#123;</div><div class="line">        return once.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @NonNull</div><div class="line">    @Override</div><div class="line">    public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123;</div><div class="line">        if (tasks.isDisposed()) &#123;</div><div class="line">            // don&apos;t schedule, we are unsubscribed</div><div class="line">            return EmptyDisposable.INSTANCE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  这里会执行到 threadWorker的scheduleActual方法，继续往下看<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123;</div><div class="line">     Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">     ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);</div><div class="line"></div><div class="line">     if (parent != null) &#123;</div><div class="line">         if (!parent.add(sr)) &#123;</div><div class="line">             return sr;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Future&lt;?&gt; f;</div><div class="line">     try &#123;</div><div class="line">         if (delayTime &lt;= 0) &#123;</div><div class="line">             f = executor.submit((Callable&lt;Object&gt;)sr);</div><div class="line">         &#125; else &#123;</div><div class="line">             f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</div><div class="line">         &#125;</div><div class="line">         sr.setFuture(f);</div><div class="line">     &#125; catch (RejectedExecutionException ex) &#123;</div><div class="line">         if (parent != null) &#123;</div><div class="line">             parent.remove(sr);</div><div class="line">         &#125;</div><div class="line">         RxJavaPlugins.onError(ex);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     return sr;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  在这里会使用executor最终去执行run方法。当然看到这里有一个疑问IoScheduler在这里是怎么实现线程的复用呢？我们看看threadWorker在IoScheduler中的线程的创建，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        this.pool = pool;</div><div class="line">        this.tasks = new CompositeDisposable();</div><div class="line">        this.threadWorker = pool.get();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>  这里会通过维护一个Worker的线程池来达到线程复用的效果，具体我们看看CachedWorkerPool的get方法，如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ThreadWorker get() &#123;</div><div class="line">      if (allWorkers.isDisposed()) &#123;</div><div class="line">          return SHUTDOWN_THREAD_WORKER;</div><div class="line">      &#125;</div><div class="line">      //从已经release的work线程队列中获取缓存</div><div class="line">      while (!expiringWorkerQueue.isEmpty()) &#123;</div><div class="line">          ThreadWorker threadWorker = expiringWorkerQueue.poll();</div><div class="line">          //如果找到，返回复用的线程</div><div class="line">          if (threadWorker != null) &#123;</div><div class="line">              return threadWorker;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 如果没有，则会创建一个新的ThreadWorker</div><div class="line">      ThreadWorker w = new ThreadWorker(threadFactory);</div><div class="line">      allWorkers.add(w);</div><div class="line">      return w;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="observeOn-AndroidSchedulers-mainThread"><a href="#observeOn-AndroidSchedulers-mainThread" class="headerlink" title="observeOn(AndroidSchedulers.mainThread())"></a>observeOn(AndroidSchedulers.mainThread())</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    //如果指定当前线程 则不进行调度</div><div class="line">    if (scheduler instanceof TrampolineScheduler) &#123;</div><div class="line">        source.subscribe(observer);</div><div class="line">    &#125; else &#123;</div><div class="line">        //创建Worker</div><div class="line">        Scheduler.Worker w = scheduler.createWorker();</div><div class="line">        //实例化ObserveOnObserver观察者并传入Worker</div><div class="line">        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这里我们主要需要分析ObserveOnObserver对象，onNext实现如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">      public void onNext(T t) &#123;</div><div class="line">          if (done) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (sourceMode != QueueDisposable.ASYNC) &#123;</div><div class="line">              queue.offer(t);</div><div class="line">          &#125;</div><div class="line">          schedule();</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">       void schedule() &#123;</div><div class="line">          if (getAndIncrement() == 0) &#123;</div><div class="line">              worker.schedule(this);</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p> 关键还是执行了worker的schedule，AndroidSchedulers的实现主要为HandlerScheduler，HandlerScheduler中关于Worker的实现为HandlerWorker，我们看下schedule的实现如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123;</div><div class="line">           if (run == null) throw new NullPointerException(&quot;run == null&quot;);</div><div class="line">           if (unit == null) throw new NullPointerException(&quot;unit == null&quot;);</div><div class="line"></div><div class="line">           if (disposed) &#123;</div><div class="line">               return Disposables.disposed();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           run = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">           ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);</div><div class="line"></div><div class="line">           Message message = Message.obtain(handler, scheduled);</div><div class="line">           message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.</div><div class="line"></div><div class="line">           if (async) &#123;</div><div class="line">               message.setAsynchronous(true);</div><div class="line">           &#125;</div><div class="line">           //通过handler发送消息执行run接口</div><div class="line">           handler.sendMessageDelayed(message, unit.toMillis(delay));</div><div class="line"></div><div class="line">           // Re-check disposed state for removing in case we were racing a call to dispose().</div><div class="line">           if (disposed) &#123;</div><div class="line">               handler.removeCallbacks(scheduled);</div><div class="line">               return Disposables.disposed();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           return scheduled;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p> 关于handler的实例，我们看AndroidSchedulers中的创建如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static final class MainHolder &#123;</div><div class="line">       static final Scheduler DEFAULT</div><div class="line">           = new HandlerScheduler(new Handler(Looper.getMainLooper()), false);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p> 综上可知AndroidSchedulers.mainThread()是通过消息将run方法的实现交由主线程Looper进行处理，达到将观察者的数据处理在主线程中执行的效果</p>
<h1 id="rxjava背压策略实现原理是怎样的？"><a href="#rxjava背压策略实现原理是怎样的？" class="headerlink" title="rxjava背压策略实现原理是怎样的？"></a>rxjava背压策略实现原理是怎样的？</h1><h2 id="背压（backpressure）"><a href="#背压（backpressure）" class="headerlink" title="背压（backpressure）"></a>背压（backpressure）</h2><p>当上下游在不同的线程中，通过Observable发射，处理，响应数据流时，如果上游发射数据的速度快于下游接收处理数据的速度，这样对于那些没来及处理的数据就会造成积压，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是响应式编程中的背压（backpressure）问题。</p>
<h2 id="背压处理机制"><a href="#背压处理机制" class="headerlink" title="背压处理机制"></a>背压处理机制</h2><p>rxjava2.x使用Flowable来支持背压的机制，调用create方法时需要传入BackpressureStrategy策略。</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>MISSING</td>
<td>此策略表示，通过Create方法创建的Flowable没有指定背压策略，不会对通过OnNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略</td>
</tr>
<tr>
<td>ERROR</td>
<td>在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常</td>
</tr>
<tr>
<td>BUFFER</td>
<td>此策略下，Flowable的异步缓存池同Observable的一样，没有固定大小，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM</td>
</tr>
<tr>
<td>DROP</td>
<td>在此策略下，如果Flowable的异步缓存池满了，会丢掉上游发送的数据</td>
</tr>
<tr>
<td>LATEST</td>
<td>与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，LATEST都会将最后一条数据强行放入缓存池中</td>
</tr>
</tbody>
</table>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先看看Flowable的create实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) &#123;</div><div class="line">       ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</div><div class="line">       ObjectHelper.requireNonNull(mode, &quot;mode is null&quot;);</div><div class="line">       return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里会创建一个FlowableCreate对象，并传入指定的BackpressureStrategy策略。接着看看FlowableCreate的订阅方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void subscribeActual(Subscriber&lt;? super T&gt; t) &#123;</div><div class="line">       BaseEmitter&lt;T&gt; emitter;</div><div class="line">       //根据不同的策略初始化不同的数据发射器</div><div class="line">       switch (backpressure) &#123;</div><div class="line">       case MISSING: &#123;</div><div class="line">           emitter = new MissingEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case ERROR: &#123;</div><div class="line">           emitter = new ErrorAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case DROP: &#123;</div><div class="line">           emitter = new DropAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case LATEST: &#123;</div><div class="line">           emitter = new LatestAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       default: &#123;</div><div class="line">           emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       t.onSubscribe(emitter);</div><div class="line">       try &#123;</div><div class="line">           source.subscribe(emitter);</div><div class="line">       &#125; catch (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           emitter.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="BaseEmitter"><a href="#BaseEmitter" class="headerlink" title="BaseEmitter"></a>BaseEmitter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">abstract static class BaseEmitter&lt;T&gt;</div><div class="line">    extends AtomicLong</div><div class="line">    implements FlowableEmitter&lt;T&gt;, Subscription &#123;</div><div class="line">        private static final long serialVersionUID = 7326289992464377023L;</div><div class="line"></div><div class="line">        final Subscriber&lt;? super T&gt; actual;</div><div class="line"></div><div class="line">        final SequentialDisposable serial;</div><div class="line"></div><div class="line">        BaseEmitter(Subscriber&lt;? super T&gt; actual) &#123;</div><div class="line">            this.actual = actual;</div><div class="line">            this.serial = new SequentialDisposable();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    //这里需要注意的是，Request最终会把n负责给AtomicLong</div><div class="line">   @Override</div><div class="line">        public final void request(long n) &#123;</div><div class="line">            if (SubscriptionHelper.validate(n)) &#123;</div><div class="line">                BackpressureHelper.add(this, n);</div><div class="line">                onRequested();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">//省略其他若干方法</div></pre></td></tr></table></figure>
<p>通过上面的结束我们知道Flowable有一个缓冲池，那个这个大小是多少，在哪里进行复制给发射器呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//长度是128</div><div class="line">  static final int BUFFER_SIZE;</div><div class="line">  static &#123;</div><div class="line">      BUFFER_SIZE = Math.max(1, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"> public static int bufferSize() &#123;</div><div class="line">      return BUFFER_SIZE;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //在调用observeOn时，会将长度最后传给emitter发射器，具体可以打断的追踪查看调用链</div><div class="line">  public final Flowable&lt;T&gt; observeOn(Scheduler scheduler) &#123;</div><div class="line">      return observeOn(scheduler, false, bufferSize());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="MissingEmitter"><a href="#MissingEmitter" class="headerlink" title="MissingEmitter"></a>MissingEmitter</h3><p>不会对通过OnNext发射的数据做缓存或丢弃处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">     public void onNext(T t) &#123;</div><div class="line">         if (isCancelled()) &#123;</div><div class="line">             return;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         if (t != null) &#123;</div><div class="line">             actual.onNext(t);</div><div class="line">         &#125; else &#123;</div><div class="line">             onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">             return;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         for (;;) &#123;</div><div class="line">             long r = get();</div><div class="line">             if (r == 0L || compareAndSet(r, r - 1)) &#123;</div><div class="line">                 return;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="NoOverflowBaseAsyncEmitter"><a href="#NoOverflowBaseAsyncEmitter" class="headerlink" title="NoOverflowBaseAsyncEmitter"></a>NoOverflowBaseAsyncEmitter</h3><p>DropAsyncEmitter和ErrorAsyncEmitter继承了NoOverflowBaseAsyncEmitter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">      public final void onNext(T t) &#123;</div><div class="line">          if (isCancelled()) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (t == null) &#123;</div><div class="line">              onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          //如果数量不为0则减1，通过上面的Request，可以知道get（）为Flowable的BUFFER_SIZE 128</div><div class="line">          if (get() != 0) &#123;</div><div class="line">              actual.onNext(t);</div><div class="line">              BackpressureHelper.produced(this, 1);</div><div class="line">          &#125; else &#123;</div><div class="line">              //超出阈值 执行onOverflow</div><div class="line">              onOverflow();</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<h3 id="DropAsyncEmitter"><a href="#DropAsyncEmitter" class="headerlink" title="DropAsyncEmitter"></a>DropAsyncEmitter</h3><p>如果Flowable的异步缓存池满了，会丢掉上游发送的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static final class DropAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; &#123;</div><div class="line"></div><div class="line"></div><div class="line">      private static final long serialVersionUID = 8360058422307496563L;</div><div class="line"></div><div class="line">      DropAsyncEmitter(Subscriber&lt;? super T&gt; actual) &#123;</div><div class="line">          super(actual);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      void onOverflow() &#123;</div><div class="line">          // nothing to do</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="ErrorAsyncEmitter"><a href="#ErrorAsyncEmitter" class="headerlink" title="ErrorAsyncEmitter"></a>ErrorAsyncEmitter</h3><p>如果Flowable的异步缓存池满了，会抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static final class ErrorAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private static final long serialVersionUID = 338953216916120960L;</div><div class="line"></div><div class="line">    ErrorAsyncEmitter(Subscriber&lt;? super T&gt; actual) &#123;</div><div class="line">        super(actual);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void onOverflow() &#123;</div><div class="line">        onError(new MissingBackpressureException(&quot;create: could not emit value due to lack of requests&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="BufferAsyncEmitter"><a href="#BufferAsyncEmitter" class="headerlink" title="BufferAsyncEmitter"></a>BufferAsyncEmitter</h3><p>Flowable的异步缓存池同Observable的一样，没有固定大小，可以无限制向里添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void onNext(T t) &#123;</div><div class="line">      if (done || isCancelled()) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (t == null) &#123;</div><div class="line">          onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      //加入队列 queue为SpscLinkedArrayQueue队列</div><div class="line">      queue.offer(t);</div><div class="line">      //通知消费</div><div class="line">      drain();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="LatestAsyncEmitter"><a href="#LatestAsyncEmitter" class="headerlink" title="LatestAsyncEmitter"></a>LatestAsyncEmitter</h3><p>Flowable的异步缓存池同Observable的一样，没有固定大小，可以无限制向里添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void onNext(T t) &#123;</div><div class="line">     if (done || isCancelled()) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (t == null) &#123;</div><div class="line">          onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      //进行覆盖 queue为AtomicReference</div><div class="line">      queue.set(t);</div><div class="line">       //通知消费</div><div class="line">      drain();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本文主要对rxjava的链式执行流程、线程调度以及背压机制进行梳理分析。rxjava的库还有非常多的操作符及功能,希望后续有时间继续进行分析。rxjava的源码及一些概念命名还是相对比较复杂，前前后后大约花了2周的时间进行源码的学习，坚持下来了，还是收获满满。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://www.jianshu.com/p/0cd258eecf60" target="_blank" rel="external">这可能是最好的RxJava 2.x 教程（完结版）</a></p>
<p> <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html" target="_blank" rel="external">ReactiveX中文文档</a></p>
<p> <a href="https://www.jianshu.com/p/ff8167c1d191/" target="_blank" rel="external">Rxjava2入门教程五：Flowable背压支持——对Flowable最全面而详细的讲解</a></p>
<p> <a href="https://www.jianshu.com/p/fae1af7732ef" target="_blank" rel="external">RxJava2 源码解析——线程调度 Scheduler</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/23/blockcanary源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/23/blockcanary源码学习随笔/" itemprop="url">
                  blockcanary源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T16:40:26+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/23/blockcanary源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/23/blockcanary源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="blockcanary是什么？"><a href="#blockcanary是什么？" class="headerlink" title="blockcanary是什么？"></a>blockcanary是什么？</h1><p>blockcanary是国内开发者<a href="https://github.com/markzhai" target="_blank" rel="external">MarkZhai</a>开发的一套性能监控组件，它对主线程操作进行了完全透明的监控，并能输出有效的信息，帮助开发分析、定位到问题所在，迅速优化应用</p>
<blockquote>
<p>下图为官方原理介绍示例图：</p>
</blockquote>
<p> <img src="https://upload-images.jianshu.io/upload_images/5125122-acf032fbb605a40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Github地址:<a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">blockcanary</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>非侵入式</li>
<li>使用简单</li>
<li>实时监控</li>
<li>提供完善的堆栈及内存信息</li>
</ul>
<h2 id="Android渲染机制"><a href="#Android渲染机制" class="headerlink" title="Android渲染机制"></a>Android渲染机制</h2><p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。如果超过了16ms那么可能就出现丢帧的情况。</p>
<p>本文主要对blockcanary的原理进行分析，关于渲染的详细机制及优化，推荐参考如下文章：</p>
<p><a href="https://www.jianshu.com/p/3474a769f170" target="_blank" rel="external">Android性能优化-渲染优化</a></p>
<h1 id="blockcanary怎么用？"><a href="#blockcanary怎么用？" class="headerlink" title="blockcanary怎么用？"></a>blockcanary怎么用？</h1><p>1、gradle引入库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">debugImplementation &apos;com.github.markzhai:blockcanary-android:1.5.0&apos;</div><div class="line">releaseImplementation &apos;com.github.markzhai:blockcanary-no-op:1.5.0&apos;</div></pre></td></tr></table></figure>
<p>2、自定义Application并且在onCreate中进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ExampleApplication extends Application &#123;</div><div class="line"></div><div class="line">    @Override public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        BlockCanary.install(this, new BlockCanaryContext()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="blockcanary核心执行流程是怎样？"><a href="#blockcanary核心执行流程是怎样？" class="headerlink" title="blockcanary核心执行流程是怎样？"></a>blockcanary核心执行流程是怎样？</h1><p>blockcanary的核心原理是通过自定义一个Printer，设置到主线程ActivityThread的MainLooper中。MainLooper在dispatch消息前后都会调用Printer进行打印。从而获取前后执行的时间差值，判断是否超过设置的阈值。如果超过，则会将记录的栈信息及cpu信息发通知到前台。</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td> BlockCanary</td>
<td>外观类，提供初始化及开始、停止监听</td>
</tr>
<tr>
<td> BlockCanaryContext</td>
<td>配置上下文，可配置id、当前网络信息、卡顿阈值、log保存路径等</td>
</tr>
<tr>
<td> BlockCanaryInternals</td>
<td>blockcanary核心的调度类，内部包含了monitor（设置到MainLooper的printer）、stackSampler（栈信息处理器）、cpuSampler（cpu信息处理器）、mInterceptorChain（注册的拦截器）、以及onBlockEvent的回调及拦截器的分发</td>
</tr>
<tr>
<td> LooperMonitor</td>
<td>继承了Printer接口，用于设置到MainLooper中。通过复写println的方法来获取MainLooper的dispatch前后的执行时间差，并控制stackSampler和cpuSampler的信息采集。</td>
</tr>
<tr>
<td> StackSampler</td>
<td>用于获取线程的栈信息，将采集的栈信息存储到一个以key为时间戳的LinkHashMap中。通过mCurrentThread.getStackTrace()获取当前线程的StackTraceElement</td>
</tr>
<tr>
<td> CpuSampler</td>
<td>用于获取cpu信息，将采集的cpu信息存储到一个以key为时间戳的LinkHashMap中。通过读取/proc/stat文件获取cpu的信息</td>
</tr>
<tr>
<td> DisplayService</td>
<td>继承了BlockInterceptor拦截器，onBlock回调会触发发送前台通知</td>
</tr>
<tr>
<td> DisplayActivity</td>
<td>用于显示记录的异常信息Activity</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>  leakcanary的核心流程主要包含3个步骤。</p>
<p> 1、init-初始化</p>
<p> 2、monitor-监听MainLooper的dispatch时间差，推送前台通知</p>
<p> 3、dump-采集线程栈信息及cpu信息</p>
<p> 这里先上一下整体的流程图，建议结合源码进行查看。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-c9cc07935c67c8c6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> 下面我们通过上述3个步骤相关的源码来进行分析。</p>
<h3 id="1、init"><a href="#1、init" class="headerlink" title="1、init"></a>1、init</h3><p>根据Application中的使用，我们首先看install方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123;</div><div class="line">      //BlockCanaryContext.init会将保存应用的applicationContext和用户设置的配置参数</div><div class="line">      BlockCanaryContext.init(context, blockCanaryContext);</div><div class="line">      //etEnabled将根据用户的通知栏消息配置开启</div><div class="line">      setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());</div><div class="line">      return get();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>接着看get方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用单例创建了一个BlockCanary对象</div><div class="line">public static BlockCanary get() &#123;</div><div class="line">    if (sInstance == null) &#123;</div><div class="line">        synchronized (BlockCanary.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                sInstance = new BlockCanary();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们看BlockCanary的对象的构造方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private BlockCanary() &#123;</div><div class="line">        //初始化lockCanaryInternals调度类</div><div class="line">        BlockCanaryInternals.setContext(BlockCanaryContext.get());</div><div class="line">        mBlockCanaryCore = BlockCanaryInternals.getInstance();</div><div class="line">        //为BlockCanaryInternals添加拦截器（责任链）BlockCanaryContext对BlockInterceptor是空实现</div><div class="line">        mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());</div><div class="line">        if (!BlockCanaryContext.get().displayNotification()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //DisplayService只在开启通知栏消息的时候添加，当卡顿发生时将通过DisplayService发起通知栏消息</div><div class="line">        mBlockCanaryCore.addBlockInterceptor(new DisplayService());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>接着我们看BlockCanaryInternals的构造方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public BlockCanaryInternals() &#123;</div><div class="line">        //初始化栈采集器</div><div class="line">        stackSampler = new StackSampler(</div><div class="line">                Looper.getMainLooper().getThread(),</div><div class="line">                sContext.provideDumpInterval());</div><div class="line">        //初始化cpu采集器</div><div class="line">        cpuSampler = new CpuSampler(sContext.provideDumpInterval());</div><div class="line"></div><div class="line">        //初始化LooperMonitor，并实现了onBlockEvent的回调，该回调会在触发阈值后被调用</div><div class="line">        setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onBlockEvent(long realTimeStart, long realTimeEnd,</div><div class="line">                                     long threadTimeStart, long threadTimeEnd) &#123;</div><div class="line">                ArrayList&lt;String&gt; threadStackEntries = stackSampler</div><div class="line">                        .getThreadStackEntries(realTimeStart, realTimeEnd);</div><div class="line">                if (!threadStackEntries.isEmpty()) &#123;</div><div class="line">                    BlockInfo blockInfo = BlockInfo.newInstance()</div><div class="line">                            .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</div><div class="line">                            .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</div><div class="line">                            .setRecentCpuRate(cpuSampler.getCpuRateInfo())</div><div class="line">                            .setThreadStackEntries(threadStackEntries)</div><div class="line">                            .flushString();</div><div class="line">                    LogWriter.save(blockInfo.toString());</div><div class="line"></div><div class="line">                    if (mInterceptorChain.size() != 0) &#123;</div><div class="line">                        for (BlockInterceptor interceptor : mInterceptorChain) &#123;</div><div class="line">                            interceptor.onBlock(getContext().provideContext(), blockInfo);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</div><div class="line"></div><div class="line">        LogWriter.cleanObsolete();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="2、monitor"><a href="#2、monitor" class="headerlink" title="2、monitor"></a>2、monitor</h3><p>首先我们先看下系统的Looper的loop()方法中对于printer的使用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">for (;;) &#123;</div><div class="line">         Message msg = queue.next(); // might block</div><div class="line">         if (msg == null) &#123;</div><div class="line">             // No message indicates that the message queue is quitting.</div><div class="line">             return;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // 执行dispatchMessage前，执行Printer的println方法</div><div class="line">         final Printer logging = me.mLogging;</div><div class="line">         if (logging != null) &#123;</div><div class="line">             logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                     msg.callback + &quot;: &quot; + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         final long traceTag = me.mTraceTag;</div><div class="line">         long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</div><div class="line">         long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</div><div class="line">         if (thresholdOverride &gt; 0) &#123;</div><div class="line">             slowDispatchThresholdMs = thresholdOverride;</div><div class="line">             slowDeliveryThresholdMs = thresholdOverride;</div><div class="line">         &#125;</div><div class="line">         final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</div><div class="line">         final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</div><div class="line"></div><div class="line">         final boolean needStartTime = logSlowDelivery || logSlowDispatch;</div><div class="line">         final boolean needEndTime = logSlowDispatch;</div><div class="line"></div><div class="line">         if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">             Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</div><div class="line">         final long dispatchEnd;</div><div class="line">         try &#123;</div><div class="line">             msg.target.dispatchMessage(msg);</div><div class="line">             dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</div><div class="line">         &#125; finally &#123;</div><div class="line">             if (traceTag != 0) &#123;</div><div class="line">                 Trace.traceEnd(traceTag);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         if (logSlowDelivery) &#123;</div><div class="line">             if (slowDeliveryDetected) &#123;</div><div class="line">                 if ((dispatchStart - msg.when) &lt;= 10) &#123;</div><div class="line">                     Slog.w(TAG, &quot;Drained&quot;);</div><div class="line">                     slowDeliveryDetected = false;</div><div class="line">                 &#125;</div><div class="line">             &#125; else &#123;</div><div class="line">                 if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</div><div class="line">                         msg)) &#123;</div><div class="line">                     // Once we write a slow delivery log, suppress until the queue drains.</div><div class="line">                     slowDeliveryDetected = true;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         if (logSlowDispatch) &#123;</div><div class="line">             showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</div><div class="line">         &#125;</div><div class="line">       // 执行dispatchMessage后，执行Printer的println方法</div><div class="line">         if (logging != null) &#123;</div><div class="line">             logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // Make sure that during the course of dispatching the</div><div class="line">         // identity of the thread wasn&apos;t corrupted.</div><div class="line">         final long newIdent = Binder.clearCallingIdentity();</div><div class="line">         if (ident != newIdent) &#123;</div><div class="line">             Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                     + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                     + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                     + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                     + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.recycleUnchecked();</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>当install进行初始化完成后，接着会调用start()方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">      if (!mMonitorStarted) &#123;</div><div class="line">          mMonitorStarted = true;</div><div class="line">          //把mBlockCanaryCore中的monitor设置MainLooper中进行监听</div><div class="line">          Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>当MainLooper执行dispatch的前后会调用printer的println方法，所以这里我们看LooperMonitor对println方法的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">    public void println(String x) &#123;</div><div class="line">        //如果再debug模式，不执行监听</div><div class="line">        if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mPrintingStarted) &#123;//dispatchMesage前执行的println</div><div class="line">            //记录开始时间</div><div class="line">            mStartTimestamp = System.currentTimeMillis();</div><div class="line">            mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();</div><div class="line">            mPrintingStarted = true;</div><div class="line">            //开始采集栈及cpu信息</div><div class="line">            startDump();</div><div class="line">        &#125; else &#123;//dispatchMesage后执行的println</div><div class="line">            //获取结束时间</div><div class="line">            final long endTime = System.currentTimeMillis();</div><div class="line">            mPrintingStarted = false;</div><div class="line">            //判断耗时是否超过阈值</div><div class="line">            if (isBlock(endTime)) &#123;</div><div class="line">                notifyBlockEvent(endTime);</div><div class="line">            &#125;</div><div class="line">            stopDump();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> //判断是否超过阈值</div><div class="line"> private boolean isBlock(long endTime) &#123;</div><div class="line">        return endTime - mStartTimestamp &gt; mBlockThresholdMillis;</div><div class="line">    &#125;</div><div class="line">//回调监听</div><div class="line"> private void notifyBlockEvent(final long endTime) &#123;</div><div class="line">        final long startTime = mStartTimestamp;</div><div class="line">        final long startThreadTime = mStartThreadTimestamp;</div><div class="line">        final long endThreadTime = SystemClock.currentThreadTimeMillis();</div><div class="line">        HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当发现时间差超过阈值后，会回调onBlockEvent。具体的实现在BlockCanaryInternals的构造方法中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onBlockEvent(long realTimeStart, long realTimeEnd,</div><div class="line">                                    long threadTimeStart, long threadTimeEnd) &#123;</div><div class="line">               //根据开始及结束时间，从栈的map当中获取记录信息</div><div class="line">               ArrayList&lt;String&gt; threadStackEntries = stackSampler</div><div class="line">                       .getThreadStackEntries(realTimeStart, realTimeEnd);</div><div class="line">               if (!threadStackEntries.isEmpty()) &#123;</div><div class="line">                   //构建 BlockInfo对象，设置相关的信息</div><div class="line">                   BlockInfo blockInfo = BlockInfo.newInstance()</div><div class="line">                           .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</div><div class="line">                           .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</div><div class="line">                           .setRecentCpuRate(cpuSampler.getCpuRateInfo())</div><div class="line">                           .setThreadStackEntries(threadStackEntries)</div><div class="line">                           .flushString();</div><div class="line">                   //记录信息</div><div class="line">                   LogWriter.save(blockInfo.toString());</div><div class="line">                   //遍历拦截器，通知</div><div class="line">                   if (mInterceptorChain.size() != 0) &#123;</div><div class="line">                       for (BlockInterceptor interceptor : mInterceptorChain) &#123;</div><div class="line">                           interceptor.onBlock(getContext().provideContext(), blockInfo);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</div></pre></td></tr></table></figure></p>
<p>最后我们看拦截器的实现DisplayService，会发送前台的通知，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void onBlock(Context context, BlockInfo blockInfo) &#123;</div><div class="line">      Intent intent = new Intent(context, DisplayActivity.class);</div><div class="line">      intent.putExtra(&quot;show_latest&quot;, blockInfo.timeStart);</div><div class="line">      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</div><div class="line">      PendingIntent pendingIntent = PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);</div><div class="line">      String contentTitle = context.getString(R.string.block_canary_class_has_blocked, blockInfo.timeStart);</div><div class="line">      String contentText = context.getString(R.string.block_canary_notification_message);</div><div class="line">      show(context, contentTitle, contentText, pendingIntent);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3、dump"><a href="#3、dump" class="headerlink" title="3、dump"></a>3、dump</h3><p>从上面的流程我们可以知道，当dispatchMessage前的println触发时，会执行dump的start方法，当dispatchMessage后的println触发时，会执行dump的stop方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void startDump() &#123;</div><div class="line">       if (null != BlockCanaryInternals.getInstance().stackSampler) &#123;</div><div class="line">           BlockCanaryInternals.getInstance().stackSampler.start();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123;</div><div class="line">           BlockCanaryInternals.getInstance().cpuSampler.start();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void stopDump() &#123;</div><div class="line">       if (null != BlockCanaryInternals.getInstance().stackSampler) &#123;</div><div class="line">           BlockCanaryInternals.getInstance().stackSampler.stop();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123;</div><div class="line">           BlockCanaryInternals.getInstance().cpuSampler.stop();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>下面我们分Stacksampler和CpuSampler进行介绍。</p>
<p>1、Stacksampler</p>
<p>start()的执行流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">       if (mShouldSample.get()) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       mShouldSample.set(true);</div><div class="line"></div><div class="line">       HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);</div><div class="line">       //通过一个HandlerThread延时执行了mRunnable</div><div class="line">       HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable,</div><div class="line">               BlockCanaryInternals.getInstance().getSampleDelay());</div><div class="line">   &#125;</div><div class="line">  //mRunnable在基类AbstractSampler中定义</div><div class="line"> private Runnable mRunnable = new Runnable() &#123;</div><div class="line">       @Override</div><div class="line">       public void run() &#123;</div><div class="line">           //抽象方法</div><div class="line">           doSample();</div><div class="line">           //继续执行采集</div><div class="line">           if (mShouldSample.get()) &#123;</div><div class="line">               HandlerThreadFactory.getTimerThreadHandler()</div><div class="line">                       .postDelayed(mRunnable, mSampleInterval);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">//Stacksampler的doSample()实现</div><div class="line"> @Override</div><div class="line">   protected void doSample() &#123;</div><div class="line">       StringBuilder stringBuilder = new StringBuilder();</div><div class="line">       //通过mCurrentThread.getStackTrace()获取StackTraceElement，加入到StringBuilder</div><div class="line">       for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123;</div><div class="line">           stringBuilder</div><div class="line">                   .append(stackTraceElement.toString())</div><div class="line">                   .append(BlockInfo.SEPARATOR);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       synchronized (sStackMap) &#123;</div><div class="line">       //Lru算法，控制LinkHashMap的长度</div><div class="line">           if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123;</div><div class="line">               sStackMap.remove(sStackMap.keySet().iterator().next());</div><div class="line">           &#125;</div><div class="line">           //加入到map中</div><div class="line">           sStackMap.put(System.currentTimeMillis(), stringBuilder.toString());</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>stop()的执行流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void stop() &#123;</div><div class="line">       if (!mShouldSample.get()) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       //设置控制变量</div><div class="line">       mShouldSample.set(false);</div><div class="line">       //取消handler消息</div><div class="line">       HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>2、CpuSampler</p>
<p>其他执行流程均与StackSampler一致，这里主要分析doSample的实现，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//主要通过获取/proc/stat文件 去获取cpu的信息</div><div class="line"> protected void doSample() &#123;</div><div class="line">       BufferedReader cpuReader = null;</div><div class="line">       BufferedReader pidReader = null;</div><div class="line"></div><div class="line">       try &#123;</div><div class="line">           cpuReader = new BufferedReader(new InputStreamReader(</div><div class="line">                   new FileInputStream(&quot;/proc/stat&quot;)), BUFFER_SIZE);</div><div class="line">           String cpuRate = cpuReader.readLine();</div><div class="line">           if (cpuRate == null) &#123;</div><div class="line">               cpuRate = &quot;&quot;;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           if (mPid == 0) &#123;</div><div class="line">               mPid = android.os.Process.myPid();</div><div class="line">           &#125;</div><div class="line">           pidReader = new BufferedReader(new InputStreamReader(</div><div class="line">                   new FileInputStream(&quot;/proc/&quot; + mPid + &quot;/stat&quot;)), BUFFER_SIZE);</div><div class="line">           String pidCpuRate = pidReader.readLine();</div><div class="line">           if (pidCpuRate == null) &#123;</div><div class="line">               pidCpuRate = &quot;&quot;;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           parse(cpuRate, pidCpuRate);</div><div class="line">       &#125; catch (Throwable throwable) &#123;</div><div class="line">           Log.e(TAG, &quot;doSample: &quot;, throwable);</div><div class="line">       &#125; finally &#123;</div><div class="line">           try &#123;</div><div class="line">               if (cpuReader != null) &#123;</div><div class="line">                   cpuReader.close();</div><div class="line">               &#125;</div><div class="line">               if (pidReader != null) &#123;</div><div class="line">                   pidReader.close();</div><div class="line">               &#125;</div><div class="line">           &#125; catch (IOException exception) &#123;</div><div class="line">               Log.e(TAG, &quot;doSample: &quot;, exception);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h1 id="blockcanary是如何进行卡顿的判定？"><a href="#blockcanary是如何进行卡顿的判定？" class="headerlink" title="blockcanary是如何进行卡顿的判定？"></a>blockcanary是如何进行卡顿的判定？</h1><p> blockcanary的核心原理是通过自定义一个Printer，设置到主线程ActivityThread的MainLooper中。MainLooper在dispatch消息前后都会调用Printer进行打印。从而获取前后执行的时间差值，判断是否超过设置的阈值。如果超过，则判定为卡顿。</p>
<h1 id="leakcanary是如何获取线程的堆栈信息？"><a href="#leakcanary是如何获取线程的堆栈信息？" class="headerlink" title="leakcanary是如何获取线程的堆栈信息？"></a>leakcanary是如何获取线程的堆栈信息？</h1><p> 通过mCurrentThread.getStackTrace()方法，遍历获取StackTraceElement，转化为一个StringBuilder的value，并存储到一个key为时间戳的LinkHashMap中。</p>
<h1 id="leakcanary是如何获取cpu的信息？"><a href="#leakcanary是如何获取cpu的信息？" class="headerlink" title="leakcanary是如何获取cpu的信息？"></a>leakcanary是如何获取cpu的信息？</h1><p> 通过读取/proc/stat文件，获取所有CPU活动的信息来计算CPU使用率。解析出信息后，转化为一个StringBuilder的value，并存储到一个key为时间戳的LinkHashMap中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>blockcanary充分的利用了Loop的机制，在MainLooper的loop方法中执行dispatchMessage前后都会执行printer的println进行输出，并且提供了方法设置printer。通过分析前后打印的时差与阈值进行比对，从而判定是否卡顿。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://www.jianshu.com/p/3474a769f170" target="_blank" rel="external">Android性能优化-渲染优化</a></p>
<p> <a href="https://www.jianshu.com/p/e58992439793" target="_blank" rel="external">Android UI卡顿监测框架BlockCanary原理分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/21/leakcanary源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/21/leakcanary源码学习随笔/" itemprop="url">
                  leakcanary源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T14:06:55+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/21/leakcanary源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/21/leakcanary源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="leakcanary是什么？"><a href="#leakcanary是什么？" class="headerlink" title="leakcanary是什么？"></a>leakcanary是什么？</h1><p>leakcanary是Square开源的一个内存泄露自动探测神器，它是一个Android和Java的内存泄露检测库，可以大幅度减少了开发中遇到的OOM问题。</p>
<blockquote>
<p>下图为官方应用图标：</p>
</blockquote>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-3d09326827f97519?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Github地址:<a href="https://github.com/square/leakcanary" target="_blank" rel="external">leakcanary</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>使用简单</li>
<li>实时检测</li>
<li>及时的消息提醒及log日志</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>本文主要介绍leakcanary的实现及原理。关于内存泄漏的定义及Android常见的内存泄漏及解决方法，推荐参考如下文章：</p>
<p><a href="https://www.jianshu.com/p/402225fce4b2" target="_blank" rel="external">Android性能优化-内存泄漏（上）</a></p>
<p><a href="https://www.jianshu.com/p/2c9fc4e871a4" target="_blank" rel="external">Android性能优化-内存泄漏（下）</a></p>
<h1 id="leakcanary怎么用？"><a href="#leakcanary怎么用？" class="headerlink" title="leakcanary怎么用？"></a>leakcanary怎么用？</h1><p>1、gradle引入库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.1&apos;</div><div class="line">releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.1&apos;</div><div class="line">// Optional, if you use support library fragments:</div><div class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.1&apos;</div></pre></td></tr></table></figure></p>
<p>2、自定义Application并且在onCreate中进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ExampleApplication extends Application &#123;</div><div class="line"></div><div class="line">  @Override public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</div><div class="line">      // This process is dedicated to LeakCanary for heap analysis.</div><div class="line">      // You should not init your app in this process.</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    LeakCanary.install(this);</div><div class="line">    // Normal app init code...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="leakcanary核心执行流程是怎样？"><a href="#leakcanary核心执行流程是怎样？" class="headerlink" title="leakcanary核心执行流程是怎样？"></a>leakcanary核心执行流程是怎样？</h1><p>leakcanary主要是通过弱引用持有监听的实例对象，每个弱引用生成唯一的id，内部维护一个retainedKeys。通过触发gc，循环获取ReferenceQueue中的对象，若已被gc回收，则把id从keys中移除，最后keys维护了一个内存泄漏的实例集合。接着通过dump堆内存信息，用Square的haha库对hprof文件进行解析，最终获取内存泄漏实例的引用链，推送到前台通知。</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td> LeakCanary</td>
<td>外观模式，统一的注册类，install会返回RefWatcher对象，用于监听内存泄漏</td>
</tr>
<tr>
<td> RefWatcher</td>
<td>用于整体调度监听对象的内存泄漏，是核心的类。内部维护了watchExecutor（异步分析线程池）、debuggerControl（用于判断是否debug模式）、gcTrigger（触发gc）、heapDumper（实现为AndroidHeapDumper，用于dump内存堆快照信息）、retainedKeys（用于记录内存泄漏的对象）、queue（弱引用被gc回收会加入到该队列）；提供watch()方法对对象进行内存泄漏的判断分析。</td>
</tr>
<tr>
<td>ActivityRefWatcher</td>
<td>用于监听Activity的生命周期、执行watch()</td>
</tr>
<tr>
<td>FragmentRefWatcher</td>
<td>用于监听Fragment的生命周期、执行watch()</td>
</tr>
<tr>
<td> KeyedWeakReference</td>
<td>将检测的对象转换为虚引用持有，便于监听GC的回收，内部维护了一个key属性，用作唯一的标识(UUID.randomUUID()生成)</td>
</tr>
<tr>
<td> DebuggerControl</td>
<td>实现为AndroidDebuggerControl，用于判断是否属于调试模式（Debug.isDebuggerConnected()）</td>
</tr>
<tr>
<td> GcTrigger</td>
<td>用于触发GC操作，（Runtime.getRuntime().gc()）</td>
</tr>
<tr>
<td> HeapDump</td>
<td>堆内存信息的包装类,包含heapDumpFile、excludedRefs、referenceKey等对象</td>
</tr>
<tr>
<td> ExcludedRefs</td>
<td>用于排除一些已知的系统内存泄漏问题，避免再次提醒</td>
</tr>
<tr>
<td> HeapAnalyzerService</td>
<td>IntentService，用于开始执行内存泄漏的堆信息分析</td>
</tr>
<tr>
<td> HeapAnalyzer</td>
<td>堆内存分析器，用于堆信息分析的整体调度</td>
</tr>
<tr>
<td> HprofParser</td>
<td>haha库中用于解析hprof文件</td>
</tr>
<tr>
<td> Snapshot</td>
<td>haha库中，堆信息内存快照</td>
</tr>
<tr>
<td> AnalysisResult</td>
<td>分析结果包装类，包含className、leakTrace（泄漏的引用链）、retainedHeapSize（内存泄漏的大小）等</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>  leakcanary的核心流程主要包含5个步骤。</p>
<p> 1、install-注册</p>
<p> 2、bind-设置监听</p>
<p> 3、watch-触发监听，分析泄漏</p>
<p> 4、dump-堆内存信息</p>
<p> 5、analyze-分析，获取引用链</p>
<p> 这里先上一下整体的流程图，建议结合源码进行查看。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-bfc80c2b9a3ddcc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> 下面我们通过上诉5个步骤相关的源码来进行分析。</p>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p> 我们知道，使用leakcanary主要在application中进行注册，调用LeakCanary.install(this)。相关的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static RefWatcher install(Application application) &#123;</div><div class="line">   //创建了RefWatcher（也就是检测内存泄漏的类）</div><div class="line">   return refWatcher(application)</div><div class="line">       //设置了内存泄漏的通知Service（通知）</div><div class="line">       .listenerServiceClass(DisplayLeakService.class)</div><div class="line">       //设置了需要忽略的已知的系统级别的内存泄漏(可以自定义)</div><div class="line">       .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</div><div class="line">       //开始监听</div><div class="line">       .buildAndInstall();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>leakcanary主要是监听应用的Activity、Fragment的内存泄漏。那么bind的这个环节，主要是通过监听Activity、Fragment相关的生命周期，当对象onDestry的时候，开始执行watch操作。<br>首先我们先看buildAndInstall()方法，实现如下：</p>
<p>1、buildAndInstall</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public RefWatcher buildAndInstall() &#123;</div><div class="line">    if (LeakCanaryInternals.installedRefWatcher != null) &#123;</div><div class="line">      throw new UnsupportedOperationException(&quot;buildAndInstall() should only be called once.&quot;);</div><div class="line">    &#125;</div><div class="line">    //初始化RefWatcher对象</div><div class="line">    RefWatcher refWatcher = build();</div><div class="line">    if (refWatcher != DISABLED) &#123;</div><div class="line">      if (watchActivities) &#123;//默认true</div><div class="line">        //开始绑定Activity的监听</div><div class="line">        ActivityRefWatcher.install(context, refWatcher);</div><div class="line">      &#125;</div><div class="line">      if (watchFragments) &#123;//默认true</div><div class="line">         //开始绑定Fragment的监听</div><div class="line">        FragmentRefWatcher.Helper.install(context, refWatcher);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    LeakCanaryInternals.installedRefWatcher = refWatcher;</div><div class="line">    return refWatcher;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2、ActivityRefWatcher.install(context, refWatcher)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void install(Context context, RefWatcher refWatcher) &#123;</div><div class="line">  Application application = (Application) context.getApplicationContext();</div><div class="line">  ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);</div><div class="line">  //通过Application的ActivityLifecycleCallbacks监听Activity的生命周期</div><div class="line">  application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =</div><div class="line">    new ActivityLifecycleCallbacksAdapter() &#123;</div><div class="line">      @Override public void onActivityDestroyed(Activity activity) &#123;</div><div class="line">        //当Activity销毁的时候，开始触发watch进行分析</div><div class="line">        refWatcher.watch(activity);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>3、 FragmentRefWatcher.Helper.install(context, refWatcher)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public static void install(Context context, RefWatcher refWatcher) &#123;</div><div class="line">       //初始化FragmentRefWatcher对象及集合</div><div class="line">     List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;();</div><div class="line">       </div><div class="line">     if (SDK_INT &gt;= O) &#123;</div><div class="line">       fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     try &#123;</div><div class="line">       Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);</div><div class="line">       Constructor&lt;?&gt; constructor =</div><div class="line">           fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);</div><div class="line">       FragmentRefWatcher supportFragmentRefWatcher =</div><div class="line">           (FragmentRefWatcher) constructor.newInstance(refWatcher);</div><div class="line">       fragmentRefWatchers.add(supportFragmentRefWatcher);</div><div class="line">     &#125; catch (Exception ignored) &#123;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (fragmentRefWatchers.size() == 0) &#123;</div><div class="line">       return;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Helper helper = new Helper(fragmentRefWatchers);</div><div class="line">    //首先开始监听Activity的生命周期</div><div class="line">     Application application = (Application) context.getApplicationContext();</div><div class="line">     application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =</div><div class="line">       new ActivityLifecycleCallbacksAdapter() &#123;</div><div class="line">         @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</div><div class="line">          //当Activity创建的时候，进行Fragment的绑定监听</div><div class="line">           for (FragmentRefWatcher watcher : fragmentRefWatchers) &#123;</div><div class="line">             watcher.watchFragments(activity);</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;;</div><div class="line">       </div><div class="line"> @Override public void watchFragments(Activity activity) &#123;</div><div class="line">   if (activity instanceof FragmentActivity) &#123;</div><div class="line">     FragmentManager supportFragmentManager =</div><div class="line">         ((FragmentActivity) activity).getSupportFragmentManager();</div><div class="line">    //通过FragmentManager注册FragmentLifecycleCallbacks，监听Fragment的生命周期</div><div class="line">     supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);</div><div class="line">   &#125;</div><div class="line"> &#125; </div><div class="line"> </div><div class="line">private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =</div><div class="line">     new FragmentManager.FragmentLifecycleCallbacks() &#123;</div><div class="line">       @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) &#123;</div><div class="line">       //当Fragment销毁的时候，开始触发watch进行分析</div><div class="line">         refWatcher.watch(fragment);</div><div class="line">       &#125;</div><div class="line">     &#125;;</div></pre></td></tr></table></figure>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch主要是通过弱引用持有监听的实例对象，每个弱引用生成唯一的id，内部维护一个retainedKeys。通过触发gc，循环获取ReferenceQueue中的对象，若已被gc回收，则把id从keys中移除，最后keys维护了一个内存泄漏的实例集合。触发下一步dump操作。关键的实现代码如下：</p>
<p>1、watch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void watch(Object watchedReference, String referenceName) &#123;</div><div class="line">  if (this == DISABLED) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  checkNotNull(watchedReference, &quot;watchedReference&quot;);</div><div class="line">  checkNotNull(referenceName, &quot;referenceName&quot;);</div><div class="line">  final long watchStartNanoTime = System.nanoTime();</div><div class="line">  //生成唯一的key</div><div class="line">  String key = UUID.randomUUID().toString();</div><div class="line">  retainedKeys.add(key);</div><div class="line">  //生成虚引用</div><div class="line">  final KeyedWeakReference reference =</div><div class="line">      new KeyedWeakReference(watchedReference, key, referenceName, queue);</div><div class="line">  //开始触发线程进行分析</div><div class="line">  ensureGoneAsync(watchStartNanoTime, reference);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、ensureGone<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"> private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123;</div><div class="line">    watchExecutor.execute(new Retryable() &#123;</div><div class="line">      @Override public Retryable.Result run() &#123;</div><div class="line">        return ensureGone(reference, watchStartNanoTime);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123;</div><div class="line">    long gcStartNanoTime = System.nanoTime();</div><div class="line">    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</div><div class="line">    //刷新keys</div><div class="line">    removeWeaklyReachableReferences();</div><div class="line">    //判断是否在debug模式</div><div class="line">    if (debuggerControl.isDebuggerAttached()) &#123;</div><div class="line">      // The debugger can create false leaks.</div><div class="line">      return RETRY;</div><div class="line">    &#125;</div><div class="line">    //如果已回收不用处理</div><div class="line">    if (gone(reference)) &#123;</div><div class="line">      return DONE;</div><div class="line">    &#125;</div><div class="line">    //没回收，触发gc，提高准确性</div><div class="line">    gcTrigger.runGc();</div><div class="line">    //再次刷新keys</div><div class="line">    removeWeaklyReachableReferences();</div><div class="line">    //如果keys中还是存在该虚引用，则判定为内存泄漏</div><div class="line">    if (!gone(reference)) &#123;</div><div class="line">      long startDumpHeap = System.nanoTime();</div><div class="line">      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</div><div class="line">      File heapDumpFile = heapDumper.dumpHeap();</div><div class="line">      if (heapDumpFile == RETRY_LATER) &#123;</div><div class="line">        // Could not dump the heap.</div><div class="line">        return RETRY;</div><div class="line">      &#125;</div><div class="line">      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</div><div class="line"></div><div class="line">      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</div><div class="line">          .referenceName(reference.name)</div><div class="line">          .watchDurationMs(watchDurationMs)</div><div class="line">          .gcDurationMs(gcDurationMs)</div><div class="line">          .heapDumpDurationMs(heapDumpDurationMs)</div><div class="line">          .build();</div><div class="line"></div><div class="line">      heapdumpListener.analyze(heapDump);</div><div class="line">    &#125;</div><div class="line">    return DONE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> //判断对象是否已被gc回收</div><div class="line"> private boolean gone(KeyedWeakReference reference) &#123;</div><div class="line">    return !retainedKeys.contains(reference.key);</div><div class="line">  &#125;</div><div class="line"> //循环获取ReferenceQueue中的对象，若被gc回收，从keys中移除</div><div class="line"> private void removeWeaklyReachableReferences() &#123;</div><div class="line">    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly</div><div class="line">    // reachable. This is before finalization or garbage collection has actually happened.</div><div class="line">    KeyedWeakReference ref;</div><div class="line">    while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123;</div><div class="line">      retainedKeys.remove(ref.key);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><p>在watch中的ensureGone方法中，当监听到内存泄漏的方法时，会开始执行dump，下载堆内存快照文件。具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//如果keys中还是存在该虚引用，则判定为内存泄漏</div><div class="line">if (!gone(reference)) &#123;</div><div class="line">  long startDumpHeap = System.nanoTime();</div><div class="line">  long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</div><div class="line">  //下载对内存文件</div><div class="line">  File heapDumpFile = heapDumper.dumpHeap();</div><div class="line">  if (heapDumpFile == RETRY_LATER) &#123;</div><div class="line">    // Could not dump the heap.</div><div class="line">    return RETRY;</div><div class="line">  &#125;</div><div class="line">  long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</div><div class="line"> //构建堆内存包装类</div><div class="line">  HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</div><div class="line">      .referenceName(reference.name)</div><div class="line">      .watchDurationMs(watchDurationMs)</div><div class="line">      .gcDurationMs(gcDurationMs)</div><div class="line">      .heapDumpDurationMs(heapDumpDurationMs)</div><div class="line">      .build();</div><div class="line"></div><div class="line">  heapdumpListener.analyze(heapDump);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键的heapDumper.dumpHeap()实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public File dumpHeap() &#123;</div><div class="line">    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();</div><div class="line"></div><div class="line">    if (heapDumpFile == RETRY_LATER) &#123;</div><div class="line">      return RETRY_LATER;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FutureResult&lt;Toast&gt; waitingForToast = new FutureResult&lt;&gt;();</div><div class="line">    //显示冻结弹层</div><div class="line">    showToast(waitingForToast);</div><div class="line"></div><div class="line">    if (!waitingForToast.wait(5, SECONDS)) &#123;</div><div class="line">      CanaryLog.d(&quot;Did not dump heap, too much time waiting for Toast.&quot;);</div><div class="line">      return RETRY_LATER;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Notification.Builder builder = new Notification.Builder(context)</div><div class="line">        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));</div><div class="line">    Notification notification = LeakCanaryInternals.buildNotification(context, builder);</div><div class="line">    NotificationManager notificationManager =</div><div class="line">        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</div><div class="line">    int notificationId = (int) SystemClock.uptimeMillis();</div><div class="line">    notificationManager.notify(notificationId, notification);</div><div class="line"></div><div class="line">    Toast toast = waitingForToast.get();</div><div class="line">    try &#123;</div><div class="line">        //关键的实现，dump堆内存信息</div><div class="line">      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</div><div class="line">      //隐藏冻结弹层</div><div class="line">      cancelToast(toast);</div><div class="line">      notificationManager.cancel(notificationId);</div><div class="line">      return heapDumpFile;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">      CanaryLog.d(e, &quot;Could not dump heap&quot;);</div><div class="line">      // Abort heap dump</div><div class="line">      return RETRY_LATER;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h3><p>当dump堆内存信息成功后，会执行如下方法heapdumpListener.analyze(heapDump)，开始执行分析，具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override public void analyze(HeapDump heapDump) &#123;</div><div class="line">  checkNotNull(heapDump, &quot;heapDump&quot;);</div><div class="line">  HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</div><div class="line">&#125;</div><div class="line"></div><div class="line">  public static void runAnalysis(Context context, HeapDump heapDump,</div><div class="line">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123;</div><div class="line">  setEnabledBlocking(context, HeapAnalyzerService.class, true);</div><div class="line">  setEnabledBlocking(context, listenerServiceClass, true);</div><div class="line">  Intent intent = new Intent(context, HeapAnalyzerService.class);</div><div class="line">  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</div><div class="line">  intent.putExtra(HEAPDUMP_EXTRA, heapDump);</div><div class="line">  ContextCompat.startForegroundService(context, intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可知，会开启一个IntentService进行分析的操作。接下来看，HeapAnalyzerService的onHandleIntentInForeground实现，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override protected void onHandleIntentInForeground(@Nullable Intent intent) &#123;</div><div class="line">  if (intent == null) &#123;</div><div class="line">    CanaryLog.d(&quot;HeapAnalyzerService received a null intent, ignoring.&quot;);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</div><div class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</div><div class="line">  //构建了堆解析器</div><div class="line">  HeapAnalyzer heapAnalyzer =</div><div class="line">      new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);</div><div class="line"> //开始执行分析</div><div class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</div><div class="line">      heapDump.computeRetainedHeapSize);</div><div class="line">  AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是使用了Square的开源库haha去分析hprof文件，获取泄漏对象的引用链，相关的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey,</div><div class="line">     boolean computeRetainedSize) &#123;</div><div class="line">   long analysisStartNanoTime = System.nanoTime();</div><div class="line"></div><div class="line">   if (!heapDumpFile.exists()) &#123;</div><div class="line">     Exception exception = new IllegalArgumentException(&quot;File does not exist: &quot; + heapDumpFile);</div><div class="line">     return failure(exception, since(analysisStartNanoTime));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   try &#123;</div><div class="line">     listener.onProgressUpdate(READING_HEAP_DUMP_FILE);</div><div class="line">     HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);</div><div class="line">     HprofParser parser = new HprofParser(buffer);</div><div class="line">     listener.onProgressUpdate(PARSING_HEAP_DUMP);</div><div class="line">     Snapshot snapshot = parser.parse();</div><div class="line">     listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);</div><div class="line">     deduplicateGcRoots(snapshot);</div><div class="line">     listener.onProgressUpdate(FINDING_LEAKING_REF);</div><div class="line">     Instance leakingRef = findLeakingReference(referenceKey, snapshot);</div><div class="line"></div><div class="line">     // False alarm, weak reference was cleared in between key check and heap dump.</div><div class="line">     if (leakingRef == null) &#123;</div><div class="line">       return noLeak(since(analysisStartNanoTime));</div><div class="line">     &#125;</div><div class="line">     return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);</div><div class="line">   &#125; catch (Throwable e) &#123;</div><div class="line">     return failure(e, since(analysisStartNanoTime));</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,</div><div class="line">     Instance leakingRef, boolean computeRetainedSize) &#123;</div><div class="line"></div><div class="line">   listener.onProgressUpdate(FINDING_SHORTEST_PATH);</div><div class="line">   ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);</div><div class="line">   ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);</div><div class="line"></div><div class="line">   // False alarm, no strong reference path to GC Roots.</div><div class="line">   if (result.leakingNode == null) &#123;</div><div class="line">     return noLeak(since(analysisStartNanoTime));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   listener.onProgressUpdate(BUILDING_LEAK_TRACE);</div><div class="line">   LeakTrace leakTrace = buildLeakTrace(result.leakingNode);</div><div class="line"></div><div class="line">   String className = leakingRef.getClassObj().getClassName();</div><div class="line"></div><div class="line">   long retainedSize;</div><div class="line">   if (computeRetainedSize) &#123;</div><div class="line"></div><div class="line">     listener.onProgressUpdate(COMPUTING_DOMINATORS);</div><div class="line">     // Side effect: computes retained size.</div><div class="line">     snapshot.computeDominators();</div><div class="line"></div><div class="line">     Instance leakingInstance = result.leakingNode.instance;</div><div class="line"></div><div class="line">     retainedSize = leakingInstance.getTotalRetainedSize();</div><div class="line"></div><div class="line">     // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer</div><div class="line">     if (SDK_INT &lt;= N_MR1) &#123;</div><div class="line">       listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);</div><div class="line">       retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);</div><div class="line">     &#125;</div><div class="line">   &#125; else &#123;</div><div class="line">     retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,</div><div class="line">       since(analysisStartNanoTime));</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>关于haha库的具体实现，可参考如下链接。</p>
<p><a href="https://github.com/square/haha" target="_blank" rel="external">haha github</a></p>
<p>最后在onHandleIntentInForeground的方法最后，会执行AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);将最终分析的结果推送到前台的通知。这就完成了leakcanary对于内存泄漏的关键步骤分析。</p>
<h1 id="leakcanary是如何进行内存泄漏的监听？"><a href="#leakcanary是如何进行内存泄漏的监听？" class="headerlink" title="leakcanary是如何进行内存泄漏的监听？"></a>leakcanary是如何进行内存泄漏的监听？</h1><p>leakcanary的内存泄漏监听包含2个方面，一个是对Activity的监听，一个是对Fragment的监听。</p>
<p>1、 Activity内存泄漏监听</p>
<p>通过上述的流程分析，我们可知。leakcanary通过对 application注册ActivityLifecycleCallbacks的监听，当回调onDestroy的时候，开始对Activity进行watch操作</p>
<p>2、Fragment内存泄漏监听</p>
<p>通过上述的流程分析，我们可知。leakcanary通过对 application注册ActivityLifecycleCallbacks的监听，当回调onActivityCreate的时候，通过FragmentManager注册FragmentLifecycleCallbacks的监听，当回调onDestroy的时候，开始对Fragment进行watch操作</p>
<h1 id="leakcanary是如何进行内存泄漏的分析？"><a href="#leakcanary是如何进行内存泄漏的分析？" class="headerlink" title="leakcanary是如何进行内存泄漏的分析？"></a>leakcanary是如何进行内存泄漏的分析？</h1><p>leakcanary主要是通过监听Activity及Fragment的生命周期，当对象onDestroy的时候，使用弱引用持有该实例对象，每个弱引用生成唯一的id，内部维护一个retainedKeys。通过触发gc，循环获取ReferenceQueue中的对象，若已被gc回收，则把id从keys中移除，表示已正常被gc回收，最后keys维护了一个内存泄漏的集合。主要是通过弱引用和ReferenceQueue机制来进行内存泄漏的分析。</p>
<h1 id="leakcanary是如何dump内存信息？"><a href="#leakcanary是如何dump内存信息？" class="headerlink" title="leakcanary是如何dump内存信息？"></a>leakcanary是如何dump内存信息？</h1><p>通过上述的dump流程，leakcanary主要是通过Android系统提供的api进行堆内存信息的保存。具体的api如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</div></pre></td></tr></table></figure>
<h1 id="leakcanary是如何进行堆信息的分析？"><a href="#leakcanary是如何进行堆信息的分析？" class="headerlink" title="leakcanary是如何进行堆信息的分析？"></a>leakcanary是如何进行堆信息的分析？</h1><p>leakcanary主要是使用haha库对hprof的文件进行解析，最后分析出内存泄漏对象的引用链，及泄漏的内存大小。关于haha库的详细使用，可参考：</p>
<p><a href="https://github.com/square/haha" target="_blank" rel="external">haha github</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Square真是一家牛逼的公司，而且热衷于对开源社区的贡献。在Android的生态中，贡献了诸如okhttp、picasso、leakcanary、javapoet、retrofit等主流的框架。</p>
<p><a href="https://github.com/square" target="_blank" rel="external">Squaregithub</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/402225fce4b2" target="_blank" rel="external">Android性能优化-内存泄漏（上）</a></p>
<p><a href="https://www.jianshu.com/p/2c9fc4e871a4" target="_blank" rel="external">Android性能优化-内存泄漏（下）</a></p>
<p><a href="https://www.jianshu.com/p/02614aa6162e" target="_blank" rel="external">LeakCanary源码解析-很值得我们学习的一款框架</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/17/EventBus源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/17/EventBus源码学习随笔/" itemprop="url">
                  EventBus源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T11:24:17+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/17/EventBus源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/17/EventBus源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EventBus是什么？"><a href="#EventBus是什么？" class="headerlink" title="EventBus是什么？"></a>EventBus是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> EventBus是Android和Java的开源库，它使用发布者/订阅者模式进行松散耦合。EventBus使用了总线控制，能够用几行代码解耦类及简化代码，消除依赖关系，加速应用程序开发。</p>
<blockquote>
<p>下图为官方示例图：</p>
</blockquote>
<p> <img src="http://upload-images.jianshu.io/upload_images/5125122-1c24556c251ba7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方示例图"></p>
<p>官网网址：<a href="http://greenrobot.org/eventbus/" target="_blank" rel="external">EventBus官网</a></p>
<p>Github地址:<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>简化组件之间的通信</li>
<li>发送者和接收者高度解耦</li>
<li>性能高效，社区活跃</li>
<li>库文件很小（&lt;50KB）</li>
<li>具有简便配置线程、优先级等高级特性</li>
</ul>
<h1 id="EventBus怎么用？"><a href="#EventBus怎么用？" class="headerlink" title="EventBus怎么用？"></a>EventBus怎么用？</h1><p>1、gradle引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</div></pre></td></tr></table></figure>
<p>2、注册与取消注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//注册</div><div class="line">EventBus.getDefault().register(this);</div><div class="line"></div><div class="line">//取消注册</div><div class="line">EventBus.getDefault().unregister(this);</div></pre></td></tr></table></figure></p>
<p>3、事件定义与发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//定义</div><div class="line">public class MessageEvent &#123;</div><div class="line">&#125;</div><div class="line">//发送</div><div class="line">EventBus.getDefault().post(new MessageEvent());</div></pre></td></tr></table></figure></p>
<p>4、事件接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Subscribe(threadMode = ThreadMode.POSTING)</div><div class="line">   public void onEventMainThread(MessageEvent event) &#123;</div><div class="line">       // doSomeThing()；</div><div class="line">   &#125;;</div></pre></td></tr></table></figure></p>
<h1 id="EventBus核心执行流程是怎样？"><a href="#EventBus核心执行流程是怎样？" class="headerlink" title="EventBus核心执行流程是怎样？"></a>EventBus核心执行流程是怎样？</h1><p>EventBus的使用包含注册、取消注册、事件定义发送及事件接收。当用户进行注册时，会通过反射获取实例中定义事件方法集合，然后将事件方法集合及订阅者加入到Map中，当执行post时，会根据事件类型，从集合中获取对应的订阅集合，通过配置的threadMode，使用对应的Poster调用订阅者的事件，最后通过反射method的invoke执行事件。</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>EventBus</td>
<td>总线调度类，getDefault()为单例模式。内部持有订阅者及事件集合。还有各事件的发送器。eventTypesCache（缓存所有粘性事件的集合）、subscriptionsByEventType（key为事件，value为订阅者集合的Map）、typesBySubscriber（key为订阅者，value为事件集合的Map）、currentPostingThreadState（ThreadLocal，当前线程的事件集合）、mainThreadPoster（主线程的post）、backgroundPoster（后台线程的post）、asyncPoster（异步线程的post）、subscriberMethodFinder（获取订阅者中的事件）</td>
</tr>
<tr>
<td>SubscriberMethod</td>
<td>订阅方法的类，包含Method、ThreadMode、priority等配置属性</td>
</tr>
<tr>
<td>Subscription</td>
<td>订阅者类，包含subscriber的Object实例、subscriberMethod</td>
</tr>
<tr>
<td>PostingThreadState</td>
<td>存储当前线程的事件集合</td>
</tr>
<tr>
<td>SubscriberMethodFinder</td>
<td>用于获取订阅中的定义的事件接收方法</td>
</tr>
<tr>
<td>PendingPost</td>
<td>subscription与event的包装类，内部维护一个pendingPostPool，当池中有PendingPost实例，会进行复用</td>
</tr>
<tr>
<td>PendingPostQueue</td>
<td>内部维护了一个head、tail的PendingPost实例，提供enqueue及poll操作</td>
</tr>
<tr>
<td>HandlerPoster</td>
<td>用于处理主线程的事件执行</td>
</tr>
<tr>
<td>BackgroundPoster</td>
<td>用于处理后台线程的事件执行</td>
</tr>
<tr>
<td>AsyncPoster</td>
<td>用于执行异步线程的事件执行</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><h3 id="注册-register"><a href="#注册-register" class="headerlink" title="注册-register"></a>注册-register</h3><p>注册主要是通过反射获取订阅者中定义的事件方法集合，将订阅者和事件集合加入对应的Map，然后会判断是否支持粘性事件，将之前发送的粘性事件缓存发送给订阅者。</p>
<p>1、 源码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public void register(Object subscriber) &#123;</div><div class="line">        //获取注册的Object的Class</div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">        //通过subscriberMethodFinder获取该Object中所有的订阅方法（SubscriberMethod集合）</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">        synchronized (this) &#123;</div><div class="line">            //遍历事件集合</div><div class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">                subscribe(subscriber, subscriberMethod);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</div><div class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">        //生成Subscription对象（SubscriberMethod的包装类）</div><div class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</div><div class="line">        //获取subscriptionsByEventType集合（key为事情，value为订阅集合）</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        if (subscriptions == null) &#123;</div><div class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (subscriptions.contains(newSubscription)) &#123;</div><div class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</div><div class="line">                        + eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int size = subscriptions.size();</div><div class="line">        for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">                subscriptions.add(i, newSubscription);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //获取typesBySubscriber集合（key为订阅者，value为事件集合）</div><div class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">        if (subscribedEvents == null) &#123;</div><div class="line">            subscribedEvents = new ArrayList&lt;&gt;();</div><div class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">        &#125;</div><div class="line">        //将所有的事件，根据订阅者key加入到事件集合中</div><div class="line">        subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">        //事件方法是否支持（粘性事情）</div><div class="line">        if (subscriberMethod.sticky) &#123;</div><div class="line">            //事件方法是否支持（继承事件）</div><div class="line">            if (eventInheritance) &#123;</div><div class="line">            </div><div class="line">                //遍历stickyEvents，找出所有继承于事件的父事件</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        //给订阅者发送之前缓存的粘性事件</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                        //给订阅者发送之前缓存的粘性事件</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>2、 流程图 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5dbe34abe0a49492?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="发送-post"><a href="#发送-post" class="headerlink" title="发送-post"></a>发送-post</h3><p>1、 源码实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"> public void post(Object event) &#123;</div><div class="line">        //获取当前线程的PostingThreadState</div><div class="line">        PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">        //获取事件队列postingState.eventQueue</div><div class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">        //添加事件</div><div class="line">        eventQueue.add(event);</div><div class="line">        //是否正在发送</div><div class="line">        if (!postingState.isPosting) &#123;</div><div class="line">            postingState.isMainThread = isMainThread();</div><div class="line">            postingState.isPosting = true;</div><div class="line">            if (postingState.canceled) &#123;</div><div class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</div><div class="line">            &#125;</div><div class="line">            //循环获取eventQueue中的事件</div><div class="line">            try &#123;</div><div class="line">                while (!eventQueue.isEmpty()) &#123;</div><div class="line">                    //获取集合数据并移除，然后发送事件</div><div class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                postingState.isPosting = false;</div><div class="line">                postingState.isMainThread = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</div><div class="line">        Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">        boolean subscriptionFound = false;</div><div class="line">        //事件是否支持继承</div><div class="line">        if (eventInheritance) &#123;</div><div class="line">            //找出所有继承事件</div><div class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">            int countTypes = eventTypes.size();</div><div class="line">            //遍历集合</div><div class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</div><div class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">                //发送</div><div class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">           //发送</div><div class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">        &#125;</div><div class="line">           //如果没有订阅者会发送一个NoSubscriberEvent事件</div><div class="line">        if (!subscriptionFound) &#123;</div><div class="line">            if (logNoSubscriberMessages) &#123;</div><div class="line">                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</div><div class="line">            &#125;</div><div class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">                post(new NoSubscriberEvent(this, event));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"> private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            //根据事件获取所有订阅者subscriptions</div><div class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">        &#125;</div><div class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">            //遍历所有订阅者</div><div class="line">            for (Subscription subscription : subscriptions) &#123;</div><div class="line">                postingState.event = event;</div><div class="line">                postingState.subscription = subscription;</div><div class="line">                boolean aborted = false;</div><div class="line">                try &#123;</div><div class="line">                    //发送事件</div><div class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                    aborted = postingState.canceled;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    postingState.event = null;</div><div class="line">                    postingState.subscription = null;</div><div class="line">                    postingState.canceled = false;</div><div class="line">                &#125;</div><div class="line">                if (aborted) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</div><div class="line">        //根据对应的threadMode，使用对应的post进行事件的处理</div><div class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">            case POSTING:</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">                break;</div><div class="line">            case MAIN:</div><div class="line">                if (isMainThread) &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case MAIN_ORDERED:</div><div class="line">                if (mainThreadPoster != null) &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // temporary: technically not correct as poster not decoupled from subscriber</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case BACKGROUND:</div><div class="line">                if (isMainThread) &#123;</div><div class="line">                    backgroundPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case ASYNC:</div><div class="line">                asyncPoster.enqueue(subscription, event);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> void invokeSubscriber(Subscription subscription, Object event) &#123;</div><div class="line">        try &#123;</div><div class="line">            //最后通过反射执行事件方法</div><div class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">        &#125; catch (InvocationTargetException e) &#123;</div><div class="line">            handleSubscriberException(subscription, event, e.getCause());</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>2、 流程图<br><img src="http://upload-images.jianshu.io/upload_images/5125122-dd82d1afbb47f75d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="取消注册-unregister"><a href="#取消注册-unregister" class="headerlink" title="取消注册-unregister"></a>取消注册-unregister</h3><p>1、 源码实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public synchronized void unregister(Object subscriber) &#123;</div><div class="line">//根据subscriber从typesBySubscriber获取事件集合</div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    if (subscribedTypes != null) &#123;</div><div class="line">        //遍历订阅者的事件</div><div class="line">        for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        //typesBySubscriber移除subscriber</div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; else &#123;</div><div class="line">        logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</div><div class="line">    //根据eventType从subscriptionsByEventType获取订阅集合</div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    if (subscriptions != null) &#123;</div><div class="line">        int size = subscriptions.size();</div><div class="line">        for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            if (subscription.subscriber == subscriber) &#123;</div><div class="line">                //遍历集合移除当前的subscriber</div><div class="line">                subscription.active = false;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i--;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、 流程图 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-b427caacfba85654?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="EventBus如何识别类中定义的接收方法？"><a href="#EventBus如何识别类中定义的接收方法？" class="headerlink" title="EventBus如何识别类中定义的接收方法？"></a>EventBus如何识别类中定义的接收方法？</h1><p>EventBus之所以如此流行，一个很重要的地方就是使用非常简便。我们只需要在类中定义好方法接收对应的事件、配置好相关的标注就可以。那么怎么获取到订阅者的事件方法集合，就是EventBus设计的一个精髓的地方。通过上面的注册方法，我们知道主要是通过下面的方法来获取，下面我们主要分析一下具体的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div></pre></td></tr></table></figure></p>
<p>接着看findSubscriberMethods的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</div><div class="line">       //定义了缓存Map，避免每次都执行反射获取，提高性能</div><div class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">       if (subscriberMethods != null) &#123;</div><div class="line">           return subscriberMethods;</div><div class="line">       &#125;</div><div class="line">       if (ignoreGeneratedIndex) &#123;</div><div class="line">           //通过反射获取</div><div class="line">           subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">       &#125; else &#123;</div><div class="line">           //通过索引获取</div><div class="line">           subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">       &#125;</div><div class="line">       if (subscriberMethods.isEmpty()) &#123;</div><div class="line">           throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</div><div class="line">                   + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</div><div class="line">       &#125; else &#123;</div><div class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">           return subscriberMethods;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>最后会执行indUsingReflection去获取，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123;</div><div class="line">        //FindState 用来做订阅方法的校验和保存</div><div class="line">       FindState findState = prepareFindState();</div><div class="line">       findState.initForSubscriber(subscriberClass);</div><div class="line">       while (findState.clazz != null) &#123;</div><div class="line">           //通过反射来获得订阅方法信息</div><div class="line">           findUsingReflectionInSingleClass(findState);</div><div class="line">           //查找父类的订阅方法</div><div class="line">           findState.moveToSuperclass();</div><div class="line">       &#125;</div><div class="line">       return getMethodsAndRelease(findState);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>关键的实现在findUsingReflectionInSingleClass方法中，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</div><div class="line">        Method[] methods;</div><div class="line">        try &#123;</div><div class="line">            // //通过反射得到方法数组</div><div class="line">            methods = findState.clazz.getDeclaredMethods();</div><div class="line">        &#125; catch (Throwable th) &#123;</div><div class="line">            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</div><div class="line">            methods = findState.clazz.getMethods();</div><div class="line">            findState.skipSuperClasses = true;</div><div class="line">        &#125;</div><div class="line">        //遍历Method</div><div class="line">        for (Method method : methods) &#123;</div><div class="line">            int modifiers = method.getModifiers();</div><div class="line">            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</div><div class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">                ////保证必须只有一个事件参数</div><div class="line">                if (parameterTypes.length == 1) &#123;</div><div class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                    //得到注解</div><div class="line">                    if (subscribeAnnotation != null) &#123;</div><div class="line">                        Class&lt;?&gt; eventType = parameterTypes[0];</div><div class="line">                        //校验是否添加该方法</div><div class="line">                        if (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                            //实例化SubscriberMethod对象并添加</div><div class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</div><div class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</div><div class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</div><div class="line">                &#125;</div><div class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</div><div class="line">                throw new EventBusException(methodName +</div><div class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>总结一下，EventBus是通过反射getDeclaredMethods()获取类的方法集合，然后遍历方法集合，将符合事件定义的方法（public、只有一个事件参数、有Subcribe的注解等）加入到集合中。从而达到识别订阅者中定义的事件方法。</p>
</blockquote>
<h1 id="EventBus中的线程调度机制是怎么样的？"><a href="#EventBus中的线程调度机制是怎么样的？" class="headerlink" title="EventBus中的线程调度机制是怎么样的？"></a>EventBus中的线程调度机制是怎么样的？</h1><p>我们知道，EventBus可以通过定义threadMode来指定事件回调的执行线程。主要的配置如下：</p>
<ul>
<li><p>ThreadMode: POSTING：默认的，在同一个线程中执行。</p>
</li>
<li><p>ThreadMode: MAIN ：主线程执行</p>
</li>
<li><p>ThreadMode: MAIN_ORDERED： 主线程执行，不过需要排队，如果前一个也是main_ordered 需要等前一个执行完成后才执行，在主线程中执行，可以处理更新ui的操作。</p>
</li>
<li><p>ThreadMode: BACKGROUND ：后台进程，处理如保存到数据库等操作。</p>
</li>
<li><p>ThreadMode: ASYNC ：异步执行，另起线程操作。</p>
</li>
</ul>
<p>通过上面的流程分析在post的过程中，最后都是通过postToSubscription执行，在这里面判断了threadMode的类型，具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</div><div class="line">        //根据对应的threadMode，使用对应的post进行事件的处理</div><div class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">            case POSTING:</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">                break;</div><div class="line">            case MAIN:</div><div class="line">                if (isMainThread) &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case MAIN_ORDERED:</div><div class="line">                if (mainThreadPoster != null) &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // temporary: technically not correct as poster not decoupled from subscriber</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case BACKGROUND:</div><div class="line">                if (isMainThread) &#123;</div><div class="line">                    backgroundPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case ASYNC:</div><div class="line">                asyncPoster.enqueue(subscription, event);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>1、POSTING模式，直接执行invokeSubscriber。</p>
<p>2、MAIN模式，如果判断当前线程是主线程则执行invokeSubscriber，否则会使用mainThreadPoster执行enqueue方法。mainThreadPoster为HandlerPoster的实例，继承了Handler，是使用了MainLooper进行创建，也就是其的handleMessage在主线程中执行。<br>我们看具体的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public void enqueue(Subscription subscription, Object event) &#123;</div><div class="line">       //构建PendingPost对象</div><div class="line">       PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">       synchronized (this) &#123;</div><div class="line">         //加入队列</div><div class="line">           queue.enqueue(pendingPost);</div><div class="line">           //如果没有激活hander</div><div class="line">           if (!handlerActive) &#123;</div><div class="line">               handlerActive = true;</div><div class="line">               //发送消息</div><div class="line">               if (!sendMessage(obtainMessage())) &#123;</div><div class="line">                   throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">     @Override</div><div class="line">   public void handleMessage(Message msg) &#123;</div><div class="line">       boolean rescheduled = false;</div><div class="line">       try &#123;</div><div class="line">           long started = SystemClock.uptimeMillis();</div><div class="line">           while (true) &#123;</div><div class="line">              //循环获取队列中的所有pendingPost</div><div class="line">               PendingPost pendingPost = queue.poll();</div><div class="line">               if (pendingPost == null) &#123;</div><div class="line">                   synchronized (this) &#123;</div><div class="line">                       pendingPost = queue.poll();</div><div class="line">                       if (pendingPost == null) &#123;</div><div class="line">                         //如果已没有数据，更新 handlerActive</div><div class="line">                           handlerActive = false;</div><div class="line">                           return;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">              //在主线程中实现事件的方法</div><div class="line">               eventBus.invokeSubscriber(pendingPost);</div><div class="line">               long timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">               if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">                   if (!sendMessage(obtainMessage())) &#123;</div><div class="line">                       throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">                   &#125;</div><div class="line">                   rescheduled = true;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; finally &#123;</div><div class="line">           handlerActive = rescheduled;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>HandlerPoster会通过主线程的Handler去执行队列中的所有事件方法。</p>
<p>3、MAIN_ORDERED模式 优先主线程队列执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (mainThreadPoster != null) &#123;</div><div class="line">                   mainThreadPoster.enqueue(subscription, event);</div><div class="line">               &#125; else &#123;</div><div class="line">                   // temporary: technically not correct as poster not decoupled from subscriber</div><div class="line">                   invokeSubscriber(subscription, event);</div><div class="line">               &#125;</div></pre></td></tr></table></figure></p>
<p>4、BACKGROUND模式 如果再主线程则执行后台线程执行，否则使用当前线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (isMainThread) &#123;</div><div class="line">                    backgroundPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们主要看backgroundPoster的实现，BackgroundPoster继承了Runnable,实现线程池执行run方法，通过executorRunning控制不会每次都启动一个新任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public void enqueue(Subscription subscription, Object event) &#123;</div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        synchronized (this) &#123;</div><div class="line">            //加入队列</div><div class="line">            queue.enqueue(pendingPost);</div><div class="line">            //变量标识，不要每次都执行</div><div class="line">            if (!executorRunning) &#123;</div><div class="line">                executorRunning = true;</div><div class="line">                //线程池执行</div><div class="line">                eventBus.getExecutorService().execute(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            try &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    //循环间隔1s获取事件</div><div class="line">                    PendingPost pendingPost = queue.poll(1000);</div><div class="line">                    if (pendingPost == null) &#123;</div><div class="line">                        synchronized (this) &#123;</div><div class="line">                            // Check again, this time in synchronized</div><div class="line">                            pendingPost = queue.poll();</div><div class="line">                            if (pendingPost == null) &#123;</div><div class="line">                                //如果已没有任务，更新变量</div><div class="line">                                executorRunning = false;</div><div class="line">                                return;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    //在异步线程执行了事件方法</div><div class="line">                    eventBus.invokeSubscriber(pendingPost);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            executorRunning = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>backgroundPoster会开启一个线程去执行当前所有队列中的事件方法。</p>
<p>5、ASYNC 模式 主要使用了AsyncPoster，也继承了run接口。实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void enqueue(Subscription subscription, Object event) &#123;</div><div class="line">       PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">       queue.enqueue(pendingPost);</div><div class="line">       eventBus.getExecutorService().execute(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void run() &#123;</div><div class="line">       PendingPost pendingPost = queue.poll();</div><div class="line">       if(pendingPost == null) &#123;</div><div class="line">           throw new IllegalStateException(&quot;No pending post available&quot;);</div><div class="line">       &#125;</div><div class="line">       eventBus.invokeSubscriber(pendingPost);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>AsyncPoster每一个事件都会开启一个异步任务，通过线程池去执行。</p>
<blockquote>
<p>总结一下<br>EventBus通过配置threadMode，控制事件在不同的线程中去执行。总归有5种模式，分别为POSTING、MAIN、MAIN_ORDERED、BACKGROUND、ASYNC。主要是通过HandlerPoster、backgroundPoster、AsyncPoster来实现线程的切换。</p>
<ul>
<li>HandlerPoster会通过主线程的Handler开启循环去执行队列中的所有事件方法。</li>
<li>backgroundPoster会开启一个线程循环执行当前所有队列中的事件方法。</li>
<li>AsyncPoster每一个事件都会开启一个异步任务，通过线程池去执行。</li>
</ul>
</blockquote>
<h1 id="EventBus的事件发送和接收的原理是什么？"><a href="#EventBus的事件发送和接收的原理是什么？" class="headerlink" title="EventBus的事件发送和接收的原理是什么？"></a>EventBus的事件发送和接收的原理是什么？</h1><p> EventBus主要是通过观察者模式来实现事件的发送和接收。使用register后，会将订阅者及定义的事件接收方法加入到Map中，当在任意地方执行post时，会对事件类型进行匹配，找出所有的订阅者，根据配置的threadMode，使用不同的poster通过反射去执行事件方法。当使用unregister后，会将订阅者在Map中移除，进行取消注册。</p>
<h1 id="EventBus中代码运用了那些设计模式，有什么巧妙的设计？"><a href="#EventBus中代码运用了那些设计模式，有什么巧妙的设计？" class="headerlink" title="EventBus中代码运用了那些设计模式，有什么巧妙的设计？"></a>EventBus中代码运用了那些设计模式，有什么巧妙的设计？</h1><p>1、单例模式 </p>
<p>EventBus.getDefault()使用了懒汉的单例模式。</p>
<p>2、外观模式 </p>
<p>EventBus对外提供了统一的调度，屏蔽了内部的实现。</p>
<p>3、建造者模式  </p>
<p>Event对象的创建使用EventBusBuilder进行创建，将复杂对象的创建和表示分离，调用者不需要知道复杂的创建过程，使用Build的相关方法进行配置创建对象。</p>
<p>4、策略模式</p>
<p>根据threadMode的设置，使用不同Poster的实现策略来执行事件方法</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 1、框架的设计不在复杂而在精巧</p>
<p> 2、使用反射和标注可以简化很多实现</p>
<p> 3、EventBus的使用要注意避免大量的滥用，将导致逻辑的分散，出现问题后很难定位</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/13/Glide源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/13/Glide源码学习随笔/" itemprop="url">
                  Glide源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:23:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/13/Glide源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/13/Glide源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Glide是什么？"><a href="#Glide是什么？" class="headerlink" title="Glide是什么？"></a>Glide是什么？</h1><p>Glide是一个Android的图片加载和缓存库，它主要专注于大量图片的流畅加载。是google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方App。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WIKI地址：<a href="https://github.com/bumptech/glide/wiki" target="_blank" rel="external">WIKI官网</a></p>
<p>Github地址:<a href="https://github.com/bumptech/glide" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、多样化媒体加载</p>
<p>Glide 不仅是一个图片缓存，它支持 Gif、WebP等格式</p>
<p>2、生命周期集成</p>
<p>我们可以更加高效的使用Glide提供的方式进行绑定，这样可以更好的让加载图片的请求的生命周期动态管理起来</p>
<p>3、高效的缓存策略</p>
<ul>
<li>支持Memory和Disk图片缓存</li>
<li>根据 ImageView 的大小来缓存相应大小的图片尺寸</li>
<li>内存开销小，默认的 Bitmap 格式是 RGB_565 格式</li>
</ul>
<p>4、 提供丰富的图片转换Api，支持圆形裁剪、平滑显示等特性</p>
<h1 id="Glide怎么用？"><a href="#Glide怎么用？" class="headerlink" title="Glide怎么用？"></a>Glide怎么用？</h1><p> 1、gradle引入库，implementation ‘com.github.bumptech.glide:glide:4.7.1’</p>
<p> 2、配置Glide的with load apply into等方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public void loadImageView(ImageView view,String url)&#123;</div><div class="line">      //属性的配置</div><div class="line">      RequestOptions options = new RequestOptions()</div><div class="line">              //加载成功之前占位图</div><div class="line">              .placeholder(R.mipmap.ic_launcher)</div><div class="line">              //加载错误之后的错误图</div><div class="line">              .error(R.mipmap.ic_launcher)</div><div class="line">              //指定图片的尺寸</div><div class="line">              .override(1000,800)</div><div class="line">              //指定图片的缩放类型为fitCenter （等比例缩放图片，宽或者是高等于ImageView的宽或者是高。）</div><div class="line">              .fitCenter()</div><div class="line">              //指定图片的缩放类型为centerCrop （等比例缩放图片，直到图片的狂高都大于等于ImageView的宽度，然后截取中间的显示。）</div><div class="line">              .centerCrop()</div><div class="line">              .circleCrop()//指定图片的缩放类型为centerCrop （圆形）</div><div class="line">              //跳过内存缓存</div><div class="line">              .skipMemoryCache(true)</div><div class="line">              //缓存所有版本的图像</div><div class="line">              .diskCacheStrategy(DiskCacheStrategy.ALL)</div><div class="line">              //跳过磁盘缓存</div><div class="line">              .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">              //只缓存原来分辨率的图片</div><div class="line">              .diskCacheStrategy(DiskCacheStrategy.DATA)</div><div class="line">              //只缓存最终的图片</div><div class="line">              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)</div><div class="line">              .priority(Priority.HIGH)</div><div class="line">              ;</div><div class="line">      //加载图片</div><div class="line">      Glide.with(getApplicationContext())</div><div class="line">              .load(url)</div><div class="line">              .apply(options)</div><div class="line">              .into(view);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>3、执行ImageView的加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadImageView(ivPic,&quot;http://b.hiphotos.baidu.com/image/pic/item/d52a2834349b033bda94010519ce36d3d439bdd5.jpg&quot;);</div></pre></td></tr></table></figure>
<p>详细的使用教程及option的配置，推荐参考</p>
<p><a href="https://blog.csdn.net/guolin_blog/article/details/78582548" target="_blank" rel="external">Android图片加载框架最全解析（八），带你全面了解Glide 4的用法</a></p>
<h1 id="Glide核心执行流程是怎样？"><a href="#Glide核心执行流程是怎样？" class="headerlink" title="Glide核心执行流程是怎样？"></a>Glide核心执行流程是怎样？</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data</td>
<td>代表原始的，未修改过的资源，对应dataClass</td>
</tr>
<tr>
<td>Resource</td>
<td>修改过的资源，对应resourceClass</td>
</tr>
<tr>
<td>Transcoder</td>
<td>资源转换器，比如BitmapBytesTranscoder（Bitmap转换为Bytes），GifDrawableBytesTranscoder</td>
</tr>
<tr>
<td>ResourceEncoder</td>
<td>持久化数据的接口，注意，该类并不与decoder相对应，而是用于本地缓存的接口</td>
</tr>
<tr>
<td>ResourceDecoder</td>
<td>数据解码器,比如ByteBufferGifDecoder（将ByteBuffer转换为Gif），StreamBitmapDecoder（Stream转换为Bitmap）</td>
</tr>
<tr>
<td>ResourceTranscoder</td>
<td>资源转换器，将给定的资源类型，转换为另一种资源类型，比如将Bitmap转换为Drawable，Bitmap转换为Bytes</td>
</tr>
<tr>
<td>Transformation</td>
<td>比如对图片进行FitCenter，CircleCrop，CenterCrop的transformation，或者根据给定宽高对Bitmap进行处理的BitmapDrawableTransformation</td>
</tr>
<tr>
<td>Target</td>
<td>request的载体，各种资源对应的加载类，含有生命周期的回调方法，方便开发人员进行相应的准备以及资源回收工作</td>
</tr>
</tbody>
</table>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-b89371e35681b7ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、构建Request，实现类为SingleRequest，用于发起一个加载的请求</p>
<p>2、通过EngineJob和DecodeJob负责任务创建，发起，回调，资源的管理</p>
<p>3、根据请求的资源类型，最后匹配对应的DateFetcher进行Data数据的获取</p>
<p>4、获取数据进行相应的缓存配置</p>
<p>5、根据原始数据Data进行解码及转换，生成最终需要显示的Resource</p>
<p>6、通过回调Target对应的方法，最后进行图片的显示</p>
<h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Glide</td>
<td>向外暴露单例静态接口，构建Request，配置资源类型，缓存策略，图片处理等，可以直接通过该类完成简单的图片请求和填充。内部持有一些内存变量BitmapPool，MemoryCache，ByteArrayPool，便于低内存情况时自动清理内存</td>
</tr>
<tr>
<td>RequestManagerRetriever</td>
<td>用于创建RequestManager对象，并与Context做相应的生命周期绑定</td>
</tr>
<tr>
<td>RequestManagerFragment</td>
<td>Glide向Activity或Fragment中添加的空Fragment，用于控制绑定生命周期</td>
</tr>
<tr>
<td>LifecycleListener</td>
<td>用于监听Activity或者Fragment的生命周期方法的接口</td>
</tr>
<tr>
<td>RequestManager</td>
<td>用户管理及发起请求，支持resume、pause、clear等操作</td>
</tr>
<tr>
<td>RequestBuilder</td>
<td>创建请求，资源类型配置，缩略图配置，以及通过BaseRequestOptions进行一些默认图，图片处理的配置</td>
</tr>
<tr>
<td>Engine</td>
<td>任务创建，发起，回调，管理存活和缓存的资源</td>
</tr>
<tr>
<td>EngineJob</td>
<td>调度DecodeJob，添加，移除资源回调，并notify回调</td>
</tr>
<tr>
<td>DecodeJob</td>
<td>实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</td>
</tr>
<tr>
<td>ResourceCacheGenerator</td>
<td>尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</td>
</tr>
<tr>
<td>DataCacheGenerator</td>
<td>尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</td>
</tr>
<tr>
<td>SourceGenerator</td>
<td>从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源</td>
</tr>
<tr>
<td>DataFetcher</td>
<td>数据加载接口，通过loadData加载数据并执行对应的回调</td>
</tr>
<tr>
<td>LoadPath</td>
<td>根据给定的数据类型的DataFetcher尝试获取数据，然后尝试通过一个或多个decodePath进行decode</td>
</tr>
<tr>
<td>DecodePath</td>
<td>根据指定的数据类型对resource进行decode和transcode</td>
</tr>
<tr>
<td>Registry</td>
<td>管理组件（数据类型＋数据处理）的注册</td>
</tr>
<tr>
<td>ModelLoaderRegistry</td>
<td>注册所有数据加载的loader</td>
</tr>
<tr>
<td>ResourceDecoderRegistry</td>
<td>注册所有资源转换的decoder</td>
</tr>
<tr>
<td>TranscoderRegistry</td>
<td>注册所有对decoder之后进行特殊处理的transcoder</td>
</tr>
<tr>
<td>ResourceEncoderRegistry</td>
<td>注册所有持久化resource（处理过的资源）数据的encoder</td>
</tr>
<tr>
<td>EncoderRegistry</td>
<td>注册所有的持久化原始数据的encoder</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>先贴一下流程图，建议通过源码结合流程图进行分析，下面再分步骤进行分析。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-53e1cf2300e601e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>下面主要从with()、load()、into()3个方法进行分析。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with()"></a>with()</h3><p>1、with()方法，最后会返回一个RequestManger对象用于发起Request。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static RequestManager with(@NonNull Context context) &#123;</div><div class="line">   return getRetriever(context).get(context);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>2、getRetriever(context),最后返回一个RequestManagerRetriever对象用于生成RequestManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</div><div class="line">   // Context could be null for other reasons (ie the user passes in null), but in practice it will</div><div class="line">   // only occur due to errors with the Fragment lifecycle.</div><div class="line">   Preconditions.checkNotNull(</div><div class="line">       context,</div><div class="line">       &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</div><div class="line">           + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</div><div class="line">           + &quot;is attached or after the Fragment is destroyed).&quot;);</div><div class="line">   return Glide.get(context).getRequestManagerRetriever();</div></pre></td></tr></table></figure></p>
<p>这里Glide.get(contenxt),会对glide进行初始化，模块扫描、组件注册等工作。</p>
<p>3、RequestManagerRetriever的get(context)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public RequestManager get(@NonNull Context context) &#123;</div><div class="line">   if (context == null) &#123;</div><div class="line">     throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</div><div class="line">   &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</div><div class="line">     if (context instanceof FragmentActivity) &#123;</div><div class="line">       return get((FragmentActivity) context);</div><div class="line">     &#125; else if (context instanceof Activity) &#123;</div><div class="line">       return get((Activity) context);</div><div class="line">     &#125; else if (context instanceof ContextWrapper) &#123;</div><div class="line">       return get(((ContextWrapper) context).getBaseContext());</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return getApplicationManager(context);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里主要根据context的类型，去创建不同的RequestManager的对象，绑定生命周期。<br>如果context是Application对象的话，则调用,绑定了ApplicationLifecycle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private RequestManager getApplicationManager(@NonNull Context context) &#123;</div><div class="line">   // Either an application context or we&apos;re on a background thread.</div><div class="line">   if (applicationManager == null) &#123;</div><div class="line">     synchronized (this) &#123;</div><div class="line">       if (applicationManager == null) &#123;</div><div class="line">         // Normally pause/resume is taken care of by the fragment we add to the fragment or</div><div class="line">         // activity. However, in this case since the manager attached to the application will not</div><div class="line">         // receive lifecycle events, we must force the manager to start resumed using</div><div class="line">         // ApplicationLifecycle.</div><div class="line"></div><div class="line">         // TODO(b/27524013): Factor out this Glide.get() call.</div><div class="line">         Glide glide = Glide.get(context.getApplicationContext());</div><div class="line">         applicationManager =</div><div class="line">             factory.build(</div><div class="line">                 glide,</div><div class="line">                 new ApplicationLifecycle(),</div><div class="line">                 new EmptyRequestManagerTreeNode(),</div><div class="line">                 context.getApplicationContext());</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>4、如果context是Activity或Fragment的话，则会调用supportFragmentGet、FragmentGetd方法，创建RequestManagerFragment进行生命周期绑定ActivityFragmentLifecycle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private RequestManager fragmentGet(@NonNull Context context,</div><div class="line">    @NonNull android.app.FragmentManager fm,</div><div class="line">    @Nullable android.app.Fragment parentHint,</div><div class="line">    boolean isParentVisible) &#123;</div><div class="line">  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</div><div class="line">  RequestManager requestManager = current.getRequestManager();</div><div class="line">  if (requestManager == null) &#123;</div><div class="line">    // TODO(b/27524013): Factor out this Glide.get() call.</div><div class="line">    Glide glide = Glide.get(context);</div><div class="line">    requestManager =</div><div class="line">        factory.build(</div><div class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</div><div class="line">    current.setRequestManager(requestManager);</div><div class="line">  &#125;</div><div class="line">  return requestManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结一下：with()方法，最后会返回一个根据context类型绑定生命周期的RequestManger对象。</p>
<h3 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h3><p>1.load()方法最后会生成一个RequestBuilder对象，用于构建Request，并执行请求操作.。首先会通过as方法生成一个RequestBuilder对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(</div><div class="line">    @NonNull Class&lt;ResourceType&gt; resourceClass) &#123;</div><div class="line">  return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、执行load()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) &#123;</div><div class="line">  return loadGeneric(string);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、执行loadGeneric方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;</div><div class="line">   this.model = model;</div><div class="line">   isModelSet = true;</div><div class="line">   return this;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>保存load传进行的参数，并设置isModelSet为true</p>
<p>4、设置请求的配置参数，apply(RequestOptions requestOptions)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;TranscodeType&gt; apply(@NonNull RequestOptions requestOptions) &#123;</div><div class="line">  Preconditions.checkNotNull(requestOptions);</div><div class="line">  this.requestOptions = getMutableOptions().apply(requestOptions);</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结一下load()方法，最后会返回一个RequestBuilder对象，通过apply设置请求的参数，用于构建Request。</p>
<h3 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h3><p>into()是整个过程最复杂的一步，简单来说就是通过缓存策略及注册的Moderload，最终去加载源数据Data，并进行转换为配置的Resource，最后显示再Target上。</p>
<p>1、RequestBuilder的into方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(</div><div class="line">     @NonNull Y target,</div><div class="line">     @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</div><div class="line">     @NonNull RequestOptions options) &#123;</div><div class="line">   Util.assertMainThread();</div><div class="line">   Preconditions.checkNotNull(target);</div><div class="line">   if (!isModelSet) &#123;</div><div class="line">     throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   options = options.autoClone();</div><div class="line">   Request request = buildRequest(target, targetListener, options);</div><div class="line"></div><div class="line">   Request previous = target.getRequest();</div><div class="line">   if (request.isEquivalentTo(previous)</div><div class="line">       &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</div><div class="line">     request.recycle();</div><div class="line">     // If the request is completed, beginning again will ensure the result is re-delivered,</div><div class="line">     // triggering RequestListeners and Targets. If the request is failed, beginning again will</div><div class="line">     // restart the request, giving it another chance to complete. If the request is already</div><div class="line">     // running, we can let it continue running without interruption.</div><div class="line">     if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</div><div class="line">       // Use the previous request rather than the new one to allow for optimizations like skipping</div><div class="line">       // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</div><div class="line">       // that are done in the individual Request.</div><div class="line">       previous.begin();</div><div class="line">     &#125;</div><div class="line">     return target;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   requestManager.clear(target);</div><div class="line">   target.setRequest(request);</div><div class="line">   requestManager.track(target, request);</div><div class="line"></div><div class="line">   return target;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>2、会执行BuildRequest()生成Request对象。经过一系列的调用，最后执行的方法如下，会返回一个SingleRequest对象实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private Request obtainRequest(</div><div class="line">     Target&lt;TranscodeType&gt; target,</div><div class="line">     RequestListener&lt;TranscodeType&gt; targetListener,</div><div class="line">     RequestOptions requestOptions,</div><div class="line">     RequestCoordinator requestCoordinator,</div><div class="line">     TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,</div><div class="line">     Priority priority,</div><div class="line">     int overrideWidth,</div><div class="line">     int overrideHeight) &#123;</div><div class="line">   return SingleRequest.obtain(</div><div class="line">       context,</div><div class="line">       glideContext,</div><div class="line">       model,</div><div class="line">       transcodeClass,</div><div class="line">       requestOptions,</div><div class="line">       overrideWidth,</div><div class="line">       overrideHeight,</div><div class="line">       priority,</div><div class="line">       target,</div><div class="line">       targetListener,</div><div class="line">       requestListener,</div><div class="line">       requestCoordinator,</div><div class="line">       glideContext.getEngine(),</div><div class="line">       transitionOptions.getTransitionFactory());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>3、接着会调用 requestManager.track(target, request);实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) &#123;</div><div class="line">  targetTracker.track(target);</div><div class="line">  requestTracker.runRequest(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4、这里涉及到一个新类RequestTracker，用于管理Request的生命周期。runRequest实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void runRequest(@NonNull Request request) &#123;</div><div class="line">   requests.add(request);</div><div class="line">   if (!isPaused) &#123;</div><div class="line">     request.begin();</div><div class="line">   &#125; else &#123;</div><div class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">       Log.v(TAG, &quot;Paused, delaying request&quot;);</div><div class="line">     &#125;</div><div class="line">     pendingRequests.add(request);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>5、最后会调用Request的begin()方法开始执行请求，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public void begin() &#123;</div><div class="line">   assertNotCallingCallbacks();</div><div class="line">   stateVerifier.throwIfRecycled();</div><div class="line">   startTime = LogTime.getLogTime();</div><div class="line">   if (model == null) &#123;</div><div class="line">     if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">       width = overrideWidth;</div><div class="line">       height = overrideHeight;</div><div class="line">     &#125;</div><div class="line">     // Only log at more verbose log levels if the user has set a fallback drawable, because</div><div class="line">     // fallback Drawables indicate the user expects null models occasionally.</div><div class="line">     int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;</div><div class="line">     onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel);</div><div class="line">     return;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (status == Status.RUNNING) &#123;</div><div class="line">     throw new IllegalArgumentException(&quot;Cannot restart a running request&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (status == Status.COMPLETE) &#123;</div><div class="line">     onResourceReady(resource, DataSource.MEMORY_CACHE);</div><div class="line">     return;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Restarts for requests that are neither complete nor running can be treated as new requests</div><div class="line">   // and can run again from the beginning.</div><div class="line"></div><div class="line">   status = Status.WAITING_FOR_SIZE;</div><div class="line">   if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">     onSizeReady(overrideWidth, overrideHeight);</div><div class="line">   &#125; else &#123;</div><div class="line">     target.getSize(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</div><div class="line">       &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class="line">     target.onLoadStarted(getPlaceholderDrawable());</div><div class="line">   &#125;</div><div class="line">   if (IS_VERBOSE_LOGGABLE) &#123;</div><div class="line">     logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里主要会根据status进行判断，如果COMPLETE已完成，则直接回调 onResourceReady，如果是WAITING_FOR_SIZE，则会执行onSizeReady方法，我们都知道Glide会根据实际显示的View宽高去生成最后的Resource进行显示。</p>
<p>6、onResourceReady实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public void onSizeReady(int width, int height) &#123;</div><div class="line">  stateVerifier.throwIfRecycled();</div><div class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</div><div class="line">    logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">  &#125;</div><div class="line">  if (status != Status.WAITING_FOR_SIZE) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  status = Status.RUNNING;</div><div class="line"></div><div class="line">  float sizeMultiplier = requestOptions.getSizeMultiplier();</div><div class="line">  this.width = maybeApplySizeMultiplier(width, sizeMultiplier);</div><div class="line">  this.height = maybeApplySizeMultiplier(height, sizeMultiplier);</div><div class="line"></div><div class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</div><div class="line">    logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">  &#125;</div><div class="line">  loadStatus = engine.load(</div><div class="line">      glideContext,</div><div class="line">      model,</div><div class="line">      requestOptions.getSignature(),</div><div class="line">      this.width,</div><div class="line">      this.height,</div><div class="line">      requestOptions.getResourceClass(),</div><div class="line">      transcodeClass,</div><div class="line">      priority,</div><div class="line">      requestOptions.getDiskCacheStrategy(),</div><div class="line">      requestOptions.getTransformations(),</div><div class="line">      requestOptions.isTransformationRequired(),</div><div class="line">      requestOptions.isScaleOnlyOrNoTransform(),</div><div class="line">      requestOptions.getOptions(),</div><div class="line">      requestOptions.isMemoryCacheable(),</div><div class="line">      requestOptions.getUseUnlimitedSourceGeneratorsPool(),</div><div class="line">      requestOptions.getUseAnimationPool(),</div><div class="line">      requestOptions.getOnlyRetrieveFromCache(),</div><div class="line">      this);</div><div class="line"></div><div class="line">  // This is a hack that&apos;s only useful for testing right now where loads complete synchronously</div><div class="line">  // even though under any executor running on any thread but the main thread, the load would</div><div class="line">  // have completed asynchronously.</div><div class="line">  if (status != Status.RUNNING) &#123;</div><div class="line">    loadStatus = null;</div><div class="line">  &#125;</div><div class="line">  if (IS_VERBOSE_LOGGABLE) &#123;</div><div class="line">    logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终会通过engine的load方法去执行请求，后续的缓存策略、数据加载、图片转换都是在下面步骤执行</p>
<p>7、具体看Engine的load方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public &lt;R&gt; LoadStatus load(</div><div class="line">    GlideContext glideContext,</div><div class="line">    Object model,</div><div class="line">    Key signature,</div><div class="line">    int width,</div><div class="line">    int height,</div><div class="line">    Class&lt;?&gt; resourceClass,</div><div class="line">    Class&lt;R&gt; transcodeClass,</div><div class="line">    Priority priority,</div><div class="line">    DiskCacheStrategy diskCacheStrategy,</div><div class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</div><div class="line">    boolean isTransformationRequired,</div><div class="line">    boolean isScaleOnlyOrNoTransform,</div><div class="line">    Options options,</div><div class="line">    boolean isMemoryCacheable,</div><div class="line">    boolean useUnlimitedSourceExecutorPool,</div><div class="line">    boolean useAnimationPool,</div><div class="line">    boolean onlyRetrieveFromCache,</div><div class="line">    ResourceCallback cb) &#123;</div><div class="line">  Util.assertMainThread();</div><div class="line">  long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;</div><div class="line"></div><div class="line">  EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</div><div class="line">      resourceClass, transcodeClass, options);</div><div class="line"></div><div class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class="line">  if (active != null) &#123;</div><div class="line">    cb.onResourceReady(active, DataSource.MEMORY_CACHE);</div><div class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class="line">  if (cached != null) &#123;</div><div class="line">    cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</div><div class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</div><div class="line">  if (current != null) &#123;</div><div class="line">    current.addCallback(cb);</div><div class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return new LoadStatus(cb, current);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  EngineJob&lt;R&gt; engineJob =</div><div class="line">      engineJobFactory.build(</div><div class="line">          key,</div><div class="line">          isMemoryCacheable,</div><div class="line">          useUnlimitedSourceExecutorPool,</div><div class="line">          useAnimationPool,</div><div class="line">          onlyRetrieveFromCache);</div><div class="line"></div><div class="line">  DecodeJob&lt;R&gt; decodeJob =</div><div class="line">      decodeJobFactory.build(</div><div class="line">          glideContext,</div><div class="line">          model,</div><div class="line">          key,</div><div class="line">          signature,</div><div class="line">          width,</div><div class="line">          height,</div><div class="line">          resourceClass,</div><div class="line">          transcodeClass,</div><div class="line">          priority,</div><div class="line">          diskCacheStrategy,</div><div class="line">          transformations,</div><div class="line">          isTransformationRequired,</div><div class="line">          isScaleOnlyOrNoTransform,</div><div class="line">          onlyRetrieveFromCache,</div><div class="line">          options,</div><div class="line">          engineJob);</div><div class="line"></div><div class="line">  jobs.put(key, engineJob);</div><div class="line"></div><div class="line">  engineJob.addCallback(cb);</div><div class="line">  engineJob.start(decodeJob);</div><div class="line"></div><div class="line">  if (VERBOSE_IS_LOGGABLE) &#123;</div><div class="line">    logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</div><div class="line">  &#125;</div><div class="line">  return new LoadStatus(cb, engineJob);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里首先通过构建EngineKey，判断内存缓存中是否命中。接着判断jobs队列中是否已存在该任务。否则会构建EngineJob、DecodeJob，并通过engineJob.start(decodeJob)，通过线程池去执行DecodeJob任务。DecodeJob实现了Runnable接口，所以我们接着分析DecodeJob的run方法</p>
<p>8、DecodeJob的run方法最后执行了runWrapped方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void runWrapped() &#123;</div><div class="line">    switch (runReason) &#123;</div><div class="line">      case INITIALIZE:</div><div class="line">        stage = getNextStage(Stage.INITIALIZE);</div><div class="line">        currentGenerator = getNextGenerator();</div><div class="line">        runGenerators();</div><div class="line">        break;</div><div class="line">      case SWITCH_TO_SOURCE_SERVICE:</div><div class="line">        runGenerators();</div><div class="line">        break;</div><div class="line">      case DECODE_DATA:</div><div class="line">        decodeFromRetrievedData();</div><div class="line">        break;</div><div class="line">      default:</div><div class="line">        throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>根据不同的runReason执行不同的任务，共两种任务类型：</p>
<p>runGenerators():load数据</p>
<p>decodeFromRetrievedData()：处理已经load到的数据</p>
<p>RunReason再次执行任务的原因，三种枚举值：<br>INITIALIZE:第一次调度任务</p>
<p>WITCH_TO_SOURCE_SERVICE:本地缓存策略失败，尝试重新获取数据，两种情况；当stage为Stage.SOURCE，或者获取数据失败并且执行和回调发生在了不同的线程</p>
<p>DECODE_DATA:获取数据成功，但执行和回调不在同一线程，希望回到自己的线程去处理数据。</p>
<p>9、getNextStage()是获取加载资源的策略，一共5种策略：<br>INITIALIZE，RESOURCE_CACHE，DATA_CACHE，SOURCE，FINISHED</p>
<p>其中加载数据的策略有三种：<br>RESOURCE_CACHE，DATA_CACHE，SOURCE，<br>分别对应的Generator:</p>
<p>ResourceCacheGenerator ：尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</p>
<p>DataCacheGenerator ：尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</p>
<p>SourceGenerator ：从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源<br>策略的配置在DiskCacheStrategy。开发者可通过BaseRequestOptions设置：<br>ALL<br>NONE<br>DATA<br>RESOURCE<br>AUTOMATIC（默认方式，依赖于DataFetcher的数据源和ResourceEncoder的EncodeStrategy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private Stage getNextStage(Stage current) &#123;</div><div class="line">    switch (current) &#123;</div><div class="line">      case INITIALIZE:</div><div class="line">        return diskCacheStrategy.decodeCachedResource()</div><div class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">        return diskCacheStrategy.decodeCachedData()</div><div class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</div><div class="line">      case DATA_CACHE:</div><div class="line">        // Skip loading from source if the user opted to only retrieve the resource from cache.</div><div class="line">        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</div><div class="line">      case SOURCE:</div><div class="line">      case FINISHED:</div><div class="line">        return Stage.FINISHED;</div><div class="line">      default:</div><div class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>10、getNextGenerator，根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void runGenerators() &#123;</div><div class="line">  currentThread = Thread.currentThread();</div><div class="line">  startFetchTime = LogTime.getLogTime();</div><div class="line">  boolean isStarted = false;</div><div class="line">  while (!isCancelled &amp;&amp; currentGenerator != null</div><div class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</div><div class="line">    stage = getNextStage(stage);</div><div class="line">    currentGenerator = getNextGenerator();</div><div class="line"></div><div class="line">    if (stage == Stage.SOURCE) &#123;</div><div class="line">      reschedule();</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  // We&apos;ve run out of stages and generators, give up.</div><div class="line">  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</div><div class="line">    notifyFailed();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Otherwise a generator started a new load and we expect to be called back in</div><div class="line">  // onDataFetcherReady.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>11、这里我们分析最后SourceGenerator的startNext的执行，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public boolean startNext() &#123;</div><div class="line">  if (dataToCache != null) &#123;</div><div class="line">    Object data = dataToCache;</div><div class="line">    dataToCache = null;</div><div class="line">    cacheData(data);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  sourceCacheGenerator = null;</div><div class="line"></div><div class="line">  loadData = null;</div><div class="line">  boolean started = false;</div><div class="line">  while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</div><div class="line">    if (loadData != null</div><div class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</div><div class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</div><div class="line">      started = true;</div><div class="line">      loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return started;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后会通过Glide初始化时，Register注册的ModelLoader去执行对应的loadData方法，最后回调onDataFetcherReady(),获取得到DataSource，并将 runReason = RunReason.DECODE_DATA。触发调用decodeFromRetrievedData()进行源数据的转换</p>
<p>12、decodeFromRetrievedData，获取数据成功后，进行处理，内部调用的是runLoadPath(Data data, DataSource dataSource,LoadPath<data, resourcetype,="" r=""> path),decode完成后的回调，对decode的资源进行transform。</data,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void decodeFromRetrievedData() &#123;</div><div class="line">   if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">     logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,</div><div class="line">         &quot;data: &quot; + currentData</div><div class="line">             + &quot;, cache key: &quot; + currentSourceKey</div><div class="line">             + &quot;, fetcher: &quot; + currentFetcher);</div><div class="line">   &#125;</div><div class="line">   Resource&lt;R&gt; resource = null;</div><div class="line">   try &#123;</div><div class="line">     resource = decodeFromData(currentFetcher, currentData, currentDataSource);</div><div class="line">   &#125; catch (GlideException e) &#123;</div><div class="line">     e.setLoggingDetails(currentAttemptingKey, currentDataSource);</div><div class="line">     throwables.add(e);</div><div class="line">   &#125;</div><div class="line">   if (resource != null) &#123;</div><div class="line">     notifyEncodeAndRelease(resource, currentDataSource);</div><div class="line">   &#125; else &#123;</div><div class="line">     runGenerators();</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">   @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)</div><div class="line">     throws GlideException &#123;</div><div class="line">   LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</div><div class="line">   return runLoadPath(data, dataSource, path);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>13、decodeFromRetrievedData()中，数据decode和transform后会执行notifyEncodeAndRelease方法，在该方法中调用 notifyComplete(result, dataSource)，接着调用callback.onResourceReady，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onResourceReady(Resource&lt;R&gt; resource, DataSource dataSource) &#123;</div><div class="line">  this.resource = resource;</div><div class="line">  this.dataSource = dataSource;</div><div class="line">  MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>14、通过Handler将回调切换到主线程， 最后调用EngineJob的handleResultOnMainThread方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void handleResultOnMainThread() &#123;</div><div class="line">    stateVerifier.throwIfRecycled();</div><div class="line">    if (isCancelled) &#123;</div><div class="line">      resource.recycle();</div><div class="line">      release(false /*isRemovedFromQueue*/);</div><div class="line">      return;</div><div class="line">    &#125; else if (cbs.isEmpty()) &#123;</div><div class="line">      throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;);</div><div class="line">    &#125; else if (hasResource) &#123;</div><div class="line">      throw new IllegalStateException(&quot;Already have resource&quot;);</div><div class="line">    &#125;</div><div class="line">    engineResource = engineResourceFactory.build(resource, isCacheable);</div><div class="line">    hasResource = true;</div><div class="line"></div><div class="line">    // Hold on to resource for duration of request so we don&apos;t recycle it in the middle of</div><div class="line">    // notifying if it synchronously released by one of the callbacks.</div><div class="line">    engineResource.acquire();</div><div class="line">    listener.onEngineJobComplete(this, key, engineResource);</div><div class="line"></div><div class="line">    //noinspection ForLoopReplaceableByForEach to improve perf</div><div class="line">    for (int i = 0, size = cbs.size(); i &lt; size; i++) &#123;</div><div class="line">      ResourceCallback cb = cbs.get(i);</div><div class="line">      if (!isInIgnoredCallbacks(cb)) &#123;</div><div class="line">        engineResource.acquire();</div><div class="line">        cb.onResourceReady(engineResource, dataSource);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // Our request is complete, so we can release the resource.</div><div class="line">    engineResource.release();</div><div class="line"></div><div class="line">    release(false /*isRemovedFromQueue*/);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>15、进行相关的资源清理后，最后调用SingleRequest的onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) 方法，最后调用target.onResourceReady(result, animation)方法，实现资源的显示，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123;</div><div class="line">  // We must call isFirstReadyResource before setting status.</div><div class="line">  boolean isFirstResource = isFirstReadyResource();</div><div class="line">  status = Status.COMPLETE;</div><div class="line">  this.resource = resource;</div><div class="line"></div><div class="line">  if (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;</div><div class="line">    Log.d(GLIDE_TAG, &quot;Finished loading &quot; + result.getClass().getSimpleName() + &quot; from &quot;</div><div class="line">        + dataSource + &quot; for &quot; + model + &quot; with size [&quot; + width + &quot;x&quot; + height + &quot;] in &quot;</div><div class="line">        + LogTime.getElapsedMillis(startTime) + &quot; ms&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  isCallingCallbacks = true;</div><div class="line">  try &#123;</div><div class="line">    if ((requestListener == null</div><div class="line">        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))</div><div class="line">        &amp;&amp; (targetListener == null</div><div class="line">        || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) &#123;</div><div class="line">      Transition&lt;? super R&gt; animation =</div><div class="line">          animationFactory.build(dataSource, isFirstResource);</div><div class="line">      target.onResourceReady(result, animation);</div><div class="line">    &#125;</div><div class="line">  &#125; finally &#123;</div><div class="line">    isCallingCallbacks = false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notifyLoadSuccess();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Glide是如何与Activity及Fragment等的生命周期绑定？"><a href="#Glide是如何与Activity及Fragment等的生命周期绑定？" class="headerlink" title="Glide是如何与Activity及Fragment等的生命周期绑定？"></a>Glide是如何与Activity及Fragment等的生命周期绑定？</h1><p> Glide在执行with的阶段，会根据context的类型，将Glide的Request请求与context类型进行绑定。Application类型为整个应用的生命周期。Fragment及Activity类型，通过巧妙的设计一个RequestManagerFragment,加入到Activity或Fragment当中，从而实现生命周期的监听。</p>
<p> 1、Application的绑定为ApplicationLifecycle，与App的生命周期一致<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">public void addListener(@NonNull LifecycleListener listener) &#123;</div><div class="line">  listener.onStart();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void removeListener(@NonNull LifecycleListener listener) &#123;</div><div class="line">  // Do nothing.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、Activity或Fragment的绑定为ActivityFragmentLifecycle，与宿主对应的生命周期一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public interface LifecycleListener &#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Callback for when &#123;@link android.app.Fragment#onStart()&#125;&#125; or &#123;@link</div><div class="line">   * android.app.Activity#onStart()&#125; is called.</div><div class="line">   */</div><div class="line">  void onStart();</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Callback for when &#123;@link android.app.Fragment#onStop()&#125;&#125; or &#123;@link</div><div class="line">   * android.app.Activity#onStop()&#125;&#125; is called.</div><div class="line">   */</div><div class="line">  void onStop();</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Callback for when &#123;@link android.app.Fragment#onDestroy()&#125;&#125; or &#123;@link</div><div class="line">   * android.app.Activity#onDestroy()&#125; is called.</div><div class="line">   */</div><div class="line">  void onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、在RequestManger中实现了监听接口的注册，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private final Runnable addSelfToLifecycle = new Runnable() &#123;</div><div class="line">  @Override</div><div class="line">  public void run() &#123;</div><div class="line">    lifecycle.addListener(RequestManager.this);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里注意，一个页面拥有一个RequestManagerFragment，RequestManagerFragment会持有RequestManger的引用。一个页面发起多个Glide显示图片请求，会优先从Fragment中获取RequestManger,不会重复创建多个RequestManger对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private RequestManager fragmentGet(@NonNull Context context,</div><div class="line">      @NonNull android.app.FragmentManager fm,</div><div class="line">      @Nullable android.app.Fragment parentHint,</div><div class="line">      boolean isParentVisible) &#123;</div><div class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</div><div class="line">    RequestManager requestManager = current.getRequestManager();</div><div class="line">    if (requestManager == null) &#123;</div><div class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</div><div class="line">      Glide glide = Glide.get(context);</div><div class="line">      requestManager =</div><div class="line">          factory.build(</div><div class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</div><div class="line">      current.setRequestManager(requestManager);</div><div class="line">    &#125;</div><div class="line">    return requestManager;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>4、RequestManger中绑定的回调执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Lifecycle callback that registers for connectivity events (if the</div><div class="line"> * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused</div><div class="line"> * requests.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void onStart() &#123;</div><div class="line">  resumeRequests();</div><div class="line">  targetTracker.onStart();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Lifecycle callback that unregisters for connectivity events (if the</div><div class="line"> * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void onStop() &#123;</div><div class="line">  pauseRequests();</div><div class="line">  targetTracker.onStop();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Lifecycle callback that cancels all in progress requests and clears and recycles resources for</div><div class="line"> * all completed requests.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void onDestroy() &#123;</div><div class="line">  targetTracker.onDestroy();</div><div class="line">  for (Target&lt;?&gt; target : targetTracker.getAll()) &#123;</div><div class="line">    clear(target);</div><div class="line">  &#125;</div><div class="line">  targetTracker.clear();</div><div class="line">  requestTracker.clearRequests();</div><div class="line">  lifecycle.removeListener(this);</div><div class="line">  lifecycle.removeListener(connectivityMonitor);</div><div class="line">  mainHandler.removeCallbacks(addSelfToLifecycle);</div><div class="line">  glide.unregisterRequestManager(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从实现可知，当Activity或Fragment退到后台时，会调用pauseRequests()暂停请求，回到前台时会重新执行请求，当页面销毁时，会进行对应的资源清理及回收。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-4cc50012bc64e4ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="Glide的缓存实现原理是怎样的？"><a href="#Glide的缓存实现原理是怎样的？" class="headerlink" title="Glide的缓存实现原理是怎样的？"></a>Glide的缓存实现原理是怎样的？</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-6656137177d24574?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Glide的缓存使用内存缓存及硬盘缓存进行处理。</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ActiveResources</td>
<td>ActiveResources是一个以弱引用资源为value。用于缓存正在使用的资源</td>
</tr>
<tr>
<td>MemoryCache</td>
<td>MemoryCache是使用LruResourceCache实现,用于缓存非正在使用的资源</td>
</tr>
<tr>
<td>DiskCache</td>
<td>进行资源磁盘缓存</td>
</tr>
<tr>
<td>Http</td>
<td>通过网络地址，从服务端加载资源文件</td>
</tr>
</tbody>
</table>
<p>假如用户配置了使用内存缓存及磁盘缓存，则主要的加载实现流程如下:</p>
<p>1、当发起Request时，首先会从ActiveResources中进行缓存查找。如果命中则返回显示，如果不命中，则从MemoryCache中获取。当资源从ActiveResources中移除后，加入到MemoryCache中</p>
<p>2、当在MemoryCache中命中时，则会将资源加入到ActiveResources中，并在该Cache中移除，如果不命中则会尝试从磁盘缓存中进行加载</p>
<p>3、根据用于配置的策略，如果在磁盘缓存中命中，则会返回，并将资源缓存到ActiveResources当中，如果不命中，则会将进行网络的请求</p>
<p>4、根据ModelLoader的配置实现，从网络中加载资源，并根据配置，缓存到磁盘及内存缓存中</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>根据流程分析，我们知道Key的生成在Engine的load方法中，具体的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</div><div class="line">       resourceClass, transcodeClass, options);</div></pre></td></tr></table></figure>
<p>可见为了兼容复杂的资源转换，保证key的唯一性，包含了非常多的参数进行构建。主要有model（目标地址）、signature（设置的签名）、图片的width、heigh、资源的转换配置等。</p>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>根据上面的简介，我们可以知道，Glide主要的内存缓存策略采用了2级缓存，为ActiveResources和MemoryCache。下面我们从源码的角度分析这2个缓存的机制。</p>
<h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p>1、 根据源码，我们可知内存采用了一个HashMap进行内存的缓存，使用了弱引用ResourceWeakReference持有了Resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>2、当获取资源时，主要采用get方法进行获取，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">EngineResource&lt;?&gt; get(Key key) &#123;</div><div class="line">    ResourceWeakReference activeRef = activeEngineResources.get(key);</div><div class="line">    if (activeRef == null) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EngineResource&lt;?&gt; active = activeRef.get();</div><div class="line">    if (active == null) &#123;</div><div class="line">      cleanupActiveReference(activeRef);</div><div class="line">    &#125;</div><div class="line">    return active;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果命中，就返回资源。这里注意，如果当active==null，引用被回收时，会调用cleanupActiveReference方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;</div><div class="line">    Util.assertMainThread();</div><div class="line">    activeEngineResources.remove(ref.key);</div><div class="line"></div><div class="line">    if (!ref.isCacheable || ref.resource == null) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    EngineResource&lt;?&gt; newResource =</div><div class="line">        new EngineResource&lt;&gt;(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);</div><div class="line">    newResource.setResourceListener(ref.key, listener);</div><div class="line">    listener.onResourceReleased(ref.key, newResource);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果ref.resource！=null，则会重新生成一个EngineResource对象，并回调onResourceReleased方法，我们看具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123;</div><div class="line">  Util.assertMainThread();</div><div class="line">  activeResources.deactivate(cacheKey);</div><div class="line">  if (resource.isCacheable()) &#123;</div><div class="line">    cache.put(cacheKey, resource);</div><div class="line">  &#125; else &#123;</div><div class="line">    resourceRecycler.recycle(resource);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可知，会调用deactivate方法，从activeResources中移除，然后加入到MemoryCache中。</p>
<p>3、写入资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void activate(Key key, EngineResource&lt;?&gt; resource) &#123;</div><div class="line">   ResourceWeakReference toPut =</div><div class="line">       new ResourceWeakReference(</div><div class="line">           key,</div><div class="line">           resource,</div><div class="line">           getReferenceQueue(),</div><div class="line">           isActiveResourceRetentionAllowed);</div><div class="line"></div><div class="line">   ResourceWeakReference removed = activeEngineResources.put(key, toPut);</div><div class="line">   if (removed != null) &#123;</div><div class="line">     removed.reset();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="EngineResource"><a href="#EngineResource" class="headerlink" title="EngineResource"></a>EngineResource</h3><p>EngineResource中主要为了一个acquired变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private int acquired;</div></pre></td></tr></table></figure></p>
<p>当资源被使用时，会调用acquire,将变量值+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void acquire() &#123;</div><div class="line">  if (isRecycled) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Cannot acquire a recycled resource&quot;);</div><div class="line">  &#125;</div><div class="line">  if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;</div><div class="line">    throw new IllegalThreadStateException(&quot;Must call acquire on the main thread&quot;);</div><div class="line">  &#125;</div><div class="line">  ++acquired;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当资源被释放时，会调用release()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void release() &#123;</div><div class="line">   if (acquired &lt;= 0) &#123;</div><div class="line">     throw new IllegalStateException(&quot;Cannot release a recycled or not yet acquired resource&quot;);</div><div class="line">   &#125;</div><div class="line">   if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;</div><div class="line">     throw new IllegalThreadStateException(&quot;Must call release on the main thread&quot;);</div><div class="line">   &#125;</div><div class="line">   if (--acquired == 0) &#123;</div><div class="line">     listener.onResourceReleased(key, this);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里注意，当acquired == 0，表明资源没有被使用时，则会调用onResourceReleased，将资源存储到MemoryCache中。这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。</p>
<h3 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>Glide在Build的过程中会创建具体的MemoryCache对象，具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (memoryCache == null) &#123;</div><div class="line">     memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>从源码可知，MemoryCache的主要实现是采用了LRU算法，我们具体查看LruResourceCache的实现。发现其继承与LruCache，LruCache的关键实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final Map&lt;T, Y&gt; cache = new LinkedHashMap&lt;&gt;(100, 0.75f, true);</div></pre></td></tr></table></figure>
<p>从源码可知，Glide的内存缓存的LRU算法实现主要是使用了LinkedHashMap。</p>
<p>这里详细的说明可参考：<br><a href="https://blog.csdn.net/exceptional_derek/article/details/11713255" target="_blank" rel="external">如何用LinkedHashMap实现LRU缓存算法</a></p>
<p><strong>总结一下</strong></p>
<p>glide采用了2级的内存缓存，activeResources是一个以弱引用资源为value,的map,memory是使用LruResourceCache实现的。就是activeResources是一个随时有可能被回收资源。它存在的意义在于，memory的强引用的频繁读写也有可能造成内存激增频繁GC,而造成内存抖动。资源在使用的过程中将会保存在activeResources中，而activeResources是弱引用的，可以随时被系统回收，不会造成内存泄漏和过多的使用</p>
<h2 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>Glide缓存的资源分为两种（1，原图（SOURCE）原始图片   2，处理图（RESULT）经过压缩和变形等转化的图片）</p>
<p>硬盘缓存分为五种，具体看一面。可以通过调用diskCacheStrategy()方法并传入五种不同的参数</p>
<p>1，DiskCacheStrategy.NONE// 表示不缓存任何内容</p>
<p>2，DiskCacheStrategy.DATA// 表示只缓存原始图片</p>
<p>3，DiskCacheStrategy.RESOURCE// 表示只缓存转换过后的图片</p>
<p>4，DiskCacheStrategy.ALL // 表示既缓存原始图片，也缓存转换过后的图片</p>
<p>5，DiskCacheStrategy.AUTOMATIC//表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）</p>
<h3 id="缓存的获取"><a href="#缓存的获取" class="headerlink" title="缓存的获取"></a>缓存的获取</h3><p>1、根据上述的流程分析，我们知道具体磁盘缓存在DecodeJob中执行，当任务开始时，调用了runWrapped()方法，接着会调用getNextStage,这里会获取磁盘的加载策略Stage，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private Stage getNextStage(Stage current) &#123;</div><div class="line">    switch (current) &#123;</div><div class="line">      case INITIALIZE:</div><div class="line">        return diskCacheStrategy.decodeCachedResource()</div><div class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">        return diskCacheStrategy.decodeCachedData()</div><div class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</div><div class="line">      case DATA_CACHE:</div><div class="line">        // Skip loading from source if the user opted to only retrieve the resource from cache.</div><div class="line">        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</div><div class="line">      case SOURCE:</div><div class="line">      case FINISHED:</div><div class="line">        return Stage.FINISHED;</div><div class="line">      default:</div><div class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>接着会调用getNextGenerator方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private DataFetcherGenerator getNextGenerator() &#123;</div><div class="line">   switch (stage) &#123;</div><div class="line">     case RESOURCE_CACHE:</div><div class="line">       return new ResourceCacheGenerator(decodeHelper, this);</div><div class="line">     case DATA_CACHE:</div><div class="line">       return new DataCacheGenerator(decodeHelper, this);</div><div class="line">     case SOURCE:</div><div class="line">       return new SourceGenerator(decodeHelper, this);</div><div class="line">     case FINISHED:</div><div class="line">       return null;</div><div class="line">     default:</div><div class="line">       throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里获取下一步执行的策略，一共5种策略：<br>INITIALIZE，RESOURCE_CACHE，DATA_CACHE，SOURCE，FINISHED</p>
<p>其中加载数据的策略有三种：<br>RESOURCE_CACHE，DATA_CACHE，SOURCE，<br>分别对应的Generator:</p>
<p>ResourceCacheGenerator ：尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</p>
<p>DataCacheGenerator ：尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</p>
<p>SourceGenerator ：从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源</p>
<p>接着调用具体的Generator的startNext方法。磁盘的缓存获取实现在这个方法中获取。<br>这里ResourceCacheGenerator的关键缓存获取代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Key sourceId = sourceIds.get(sourceIdIndex);</div><div class="line">     Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</div><div class="line">     Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</div><div class="line">     // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,</div><div class="line">     // we only run until the first one succeeds, the loop runs for only a limited</div><div class="line">     // number of iterations on the order of 10-20 in the worst case.</div><div class="line">     currentKey =</div><div class="line">         new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops</div><div class="line">             helper.getArrayPool(),</div><div class="line">             sourceId,</div><div class="line">             helper.getSignature(),</div><div class="line">             helper.getWidth(),</div><div class="line">             helper.getHeight(),</div><div class="line">             transformation,</div><div class="line">             resourceClass,</div><div class="line">             helper.getOptions());</div><div class="line">     cacheFile = helper.getDiskCache().get(currentKey);</div><div class="line">     if (cacheFile != null) &#123;</div><div class="line">       sourceKey = sourceId;</div><div class="line">       modelLoaders = helper.getModelLoaders(cacheFile);</div><div class="line">       modelLoaderIndex = 0;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>DataCacheGenerator的关键缓存获取代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Key sourceId = cacheKeys.get(sourceIdIndex);</div><div class="line">    // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times</div><div class="line">    // and the actions it performs are much more expensive than a single allocation.</div><div class="line">    @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)</div><div class="line">    Key originalKey = new DataCacheKey(sourceId, helper.getSignature());</div><div class="line">    cacheFile = helper.getDiskCache().get(originalKey);</div><div class="line">    if (cacheFile != null) &#123;</div><div class="line">      this.sourceKey = sourceId;</div><div class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</div><div class="line">      modelLoaderIndex = 0;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="缓存的写入"><a href="#缓存的写入" class="headerlink" title="缓存的写入"></a>缓存的写入</h3><p>1、Data数据的缓存</p>
<p>从服务端获取数据的主要实现在SourceGenerator中，我们查看源码onDataReady可知其中判断了isDataCacheable（）会将数据赋值到dataToCache中。重新触发reschedule()；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onDataReady(Object data) &#123;</div><div class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</div><div class="line">  if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</div><div class="line">    dataToCache = data;</div><div class="line">    // We might be being called back on someone else&apos;s thread. Before doing anything, we should</div><div class="line">    // reschedule to get back onto Glide&apos;s thread.</div><div class="line">    cb.reschedule();</div><div class="line">  &#125; else &#123;</div><div class="line">    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</div><div class="line">        loadData.fetcher.getDataSource(), originalKey);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当再次出发startNext，关键实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public boolean startNext() &#123;</div><div class="line">   if (dataToCache != null) &#123;</div><div class="line">     Object data = dataToCache;</div><div class="line">     dataToCache = null;</div><div class="line">     cacheData(data);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>其中的cacheData,将原始的Data数据缓存到磁盘文件中，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void cacheData(Object dataToCache) &#123;</div><div class="line">   long startTime = LogTime.getLogTime();</div><div class="line">   try &#123;</div><div class="line">     Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</div><div class="line">     DataCacheWriter&lt;Object&gt; writer =</div><div class="line">         new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</div><div class="line">     originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());</div><div class="line">     helper.getDiskCache().put(originalKey, writer);</div><div class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">       Log.v(TAG, &quot;Finished encoding source to cache&quot;</div><div class="line">           + &quot;, key: &quot; + originalKey</div><div class="line">           + &quot;, data: &quot; + dataToCache</div><div class="line">           + &quot;, encoder: &quot; + encoder</div><div class="line">           + &quot;, duration: &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     loadData.fetcher.cleanup();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   sourceCacheGenerator =</div><div class="line">       new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>2、Resource数据的缓存</p>
<p>根据上述的流程分析，再DecodeJob中的onResourceDecoded回调中，关键的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,</div><div class="line">       encodeStrategy)) &#123;</div><div class="line">     if (encoder == null) &#123;</div><div class="line">       throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());</div><div class="line">     &#125;</div><div class="line">     final Key key;</div><div class="line">     switch (encodeStrategy) &#123;</div><div class="line">       case SOURCE:</div><div class="line">         key = new DataCacheKey(currentSourceKey, signature);</div><div class="line">         break;</div><div class="line">       case TRANSFORMED:</div><div class="line">         key =</div><div class="line">             new ResourceCacheKey(</div><div class="line">                 decodeHelper.getArrayPool(),</div><div class="line">                 currentSourceKey,</div><div class="line">                 signature,</div><div class="line">                 width,</div><div class="line">                 height,</div><div class="line">                 appliedTransformation,</div><div class="line">                 resourceSubClass,</div><div class="line">                 options);</div><div class="line">         break;</div><div class="line">       default:</div><div class="line">         throw new IllegalArgumentException(&quot;Unknown strategy: &quot; + encodeStrategy);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</div><div class="line">     deferredEncodeManager.init(key, encoder, lockedResult);</div><div class="line">     result = lockedResult;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>会初始化DeferredEncodeManager对象。接着会执行到notifyEncodeAndRelease()方法，其中关键的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">     if (deferredEncodeManager.hasResourceToEncode()) &#123;</div><div class="line">       deferredEncodeManager.encode(diskCacheProvider, options);</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     if (lockedResource != null) &#123;</div><div class="line">       lockedResource.unlock();</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>在encode中进行了resource数据的缓存，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void encode(DiskCacheProvider diskCacheProvider, Options options) &#123;</div><div class="line">   GlideTrace.beginSection(&quot;DecodeJob.encode&quot;);</div><div class="line">   try &#123;</div><div class="line">     diskCacheProvider.getDiskCache().put(key,</div><div class="line">         new DataCacheWriter&lt;&gt;(encoder, toEncode, options));</div><div class="line">   &#125; finally &#123;</div><div class="line">     toEncode.unlock();</div><div class="line">     GlideTrace.endSection();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><p>1、在Glide的Build方法中，我们可以看到磁盘缓存的工厂实例，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (diskCacheFactory == null) &#123;</div><div class="line">      diskCacheFactory = new InternalCacheDiskCacheFactory(context);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>2、InternalCacheDiskCacheFactory继承了DiskLruCacheFactory，工厂关键的build方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public DiskCache build() &#123;</div><div class="line">   File cacheDir = cacheDirectoryGetter.getCacheDirectory();</div><div class="line"></div><div class="line">   if (cacheDir == null) &#123;</div><div class="line">     return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (!cacheDir.mkdirs() &amp;&amp; (!cacheDir.exists() || !cacheDir.isDirectory())) &#123;</div><div class="line">     return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>3、可见实际的磁盘缓存对象为DiskLruCacheWrapper类，我们看对应的get、put方法，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public File get(Key key) &#123;</div><div class="line">   String safeKey = safeKeyGenerator.getSafeKey(key);</div><div class="line">   if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">     Log.v(TAG, &quot;Get: Obtained: &quot; + safeKey + &quot; for for Key: &quot; + key);</div><div class="line">   &#125;</div><div class="line">   File result = null;</div><div class="line">   try &#123;</div><div class="line">     // It is possible that the there will be a put in between these two gets. If so that shouldn&apos;t</div><div class="line">     // be a problem because we will always put the same value at the same key so our input streams</div><div class="line">     // will still represent the same data.</div><div class="line">     final DiskLruCache.Value value = getDiskCache().get(safeKey);</div><div class="line">     if (value != null) &#123;</div><div class="line">       result = value.getFile(0);</div><div class="line">     &#125;</div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">     if (Log.isLoggable(TAG, Log.WARN)) &#123;</div><div class="line">       Log.w(TAG, &quot;Unable to get from disk cache&quot;, e);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return result;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> @Override</div><div class="line"> public void put(Key key, Writer writer) &#123;</div><div class="line">   // We want to make sure that puts block so that data is available when put completes. We may</div><div class="line">   // actually not write any data if we find that data is written by the time we acquire the lock.</div><div class="line">   String safeKey = safeKeyGenerator.getSafeKey(key);</div><div class="line">   writeLocker.acquire(safeKey);</div><div class="line">   try &#123;</div><div class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">       Log.v(TAG, &quot;Put: Obtained: &quot; + safeKey + &quot; for for Key: &quot; + key);</div><div class="line">     &#125;</div><div class="line">     try &#123;</div><div class="line">       // We assume we only need to put once, so if data was written while we were trying to get</div><div class="line">       // the lock, we can simply abort.</div><div class="line">       DiskLruCache diskCache = getDiskCache();</div><div class="line">       Value current = diskCache.get(safeKey);</div><div class="line">       if (current != null) &#123;</div><div class="line">         return;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       DiskLruCache.Editor editor = diskCache.edit(safeKey);</div><div class="line">       if (editor == null) &#123;</div><div class="line">         throw new IllegalStateException(&quot;Had two simultaneous puts for: &quot; + safeKey);</div><div class="line">       &#125;</div><div class="line">       try &#123;</div><div class="line">         File file = editor.getFile(0);</div><div class="line">         if (writer.write(file)) &#123;</div><div class="line">           editor.commit();</div><div class="line">         &#125;</div><div class="line">       &#125; finally &#123;</div><div class="line">         editor.abortUnlessCommitted();</div><div class="line">       &#125;</div><div class="line">     &#125; catch (IOException e) &#123;</div><div class="line">       if (Log.isLoggable(TAG, Log.WARN)) &#123;</div><div class="line">         Log.w(TAG, &quot;Unable to put to disk cache&quot;, e);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     writeLocker.release(safeKey);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>4、最终可知磁盘缓存的实现为DiskLruCache，关于DiskLruCache缓存可参考如下博文</p>
<p><a href="https://www.jianshu.com/p/0c56dc217917" target="_blank" rel="external">DiskLruCache缓存</a></p>
<h1 id="Glide的底层网络实现是什么？"><a href="#Glide的底层网络实现是什么？" class="headerlink" title="Glide的底层网络实现是什么？"></a>Glide的底层网络实现是什么？</h1><p>通过上述的流程分析，我们可知最后的网络加载在SourceGenerator中的startNext()方法，通过初始注册的ModelLoader对应的DataFetcher去加载数据。我们以load一个GlideUrl地址来分析</p>
<p>在Glide的构造函数中，Register会注册ModelLoader，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())</div></pre></td></tr></table></figure></p>
<p>在SourceGenerator中的startNext()方法中会循环匹配出对应的ModelLoader，实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">boolean started = false;</div><div class="line">  while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</div><div class="line">    if (loadData != null</div><div class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</div><div class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</div><div class="line">      started = true;</div><div class="line">      loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>我们查看HttpGlideUrlLoader，其最后的LoadData实现为HttpUrlFetcher，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height,</div><div class="line">     @NonNull Options options) &#123;</div><div class="line">   // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</div><div class="line">   // spent parsing urls.</div><div class="line">   GlideUrl url = model;</div><div class="line">   if (modelCache != null) &#123;</div><div class="line">     url = modelCache.get(model, 0, 0);</div><div class="line">     if (url == null) &#123;</div><div class="line">       modelCache.put(model, 0, 0, model);</div><div class="line">       url = model;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   int timeout = options.get(TIMEOUT);</div><div class="line">   return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>HttpUrlFetcher具体加载网络的数据的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void loadData(@NonNull Priority priority,</div><div class="line">      @NonNull DataCallback&lt;? super InputStream&gt; callback) &#123;</div><div class="line">    long startTime = LogTime.getLogTime();</div><div class="line">    try &#123;</div><div class="line">      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());</div><div class="line">      callback.onDataReady(result);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</div><div class="line">        Log.d(TAG, &quot;Failed to load data for url&quot;, e);</div><div class="line">      &#125;</div><div class="line">      callback.onLoadFailed(e);</div><div class="line">    &#125; finally &#123;</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        Log.v(TAG, &quot;Finished http url fetcher fetch in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,</div><div class="line">      Map&lt;String, String&gt; headers) throws IOException &#123;</div><div class="line">    if (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</div><div class="line">      throw new HttpException(&quot;Too many (&gt; &quot; + MAXIMUM_REDIRECTS + &quot;) redirects!&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">      // Comparing the URLs using .equals performs additional network I/O and is generally broken.</div><div class="line">      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.</div><div class="line">      try &#123;</div><div class="line">        if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</div><div class="line">          throw new HttpException(&quot;In re-direct loop&quot;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">      &#125; catch (URISyntaxException e) &#123;</div><div class="line">        // Do nothing, this is best effort.</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    urlConnection = connectionFactory.build(url);</div><div class="line">    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</div><div class="line">      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</div><div class="line">    &#125;</div><div class="line">    urlConnection.setConnectTimeout(timeout);</div><div class="line">    urlConnection.setReadTimeout(timeout);</div><div class="line">    urlConnection.setUseCaches(false);</div><div class="line">    urlConnection.setDoInput(true);</div><div class="line"></div><div class="line">    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that</div><div class="line">    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.</div><div class="line">    urlConnection.setInstanceFollowRedirects(false);</div><div class="line"></div><div class="line">    // Connect explicitly to avoid errors in decoders if connection fails.</div><div class="line">    urlConnection.connect();</div><div class="line">    // Set the stream so that it&apos;s closed in cleanup to avoid resource leaks. See #2352.</div><div class="line">    stream = urlConnection.getInputStream();</div><div class="line">    if (isCancelled) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    final int statusCode = urlConnection.getResponseCode();</div><div class="line">    if (isHttpOk(statusCode)) &#123;</div><div class="line">      return getStreamForSuccessfulRequest(urlConnection);</div><div class="line">    &#125; else if (isHttpRedirect(statusCode)) &#123;</div><div class="line">      String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);</div><div class="line">      if (TextUtils.isEmpty(redirectUrlString)) &#123;</div><div class="line">        throw new HttpException(&quot;Received empty or null redirect url&quot;);</div><div class="line">      &#125;</div><div class="line">      URL redirectUrl = new URL(url, redirectUrlString);</div><div class="line">      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition</div><div class="line">      // to disconnecting the url connection below. See #2352.</div><div class="line">      cleanup();</div><div class="line">      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);</div><div class="line">    &#125; else if (statusCode == INVALID_STATUS_CODE) &#123;</div><div class="line">      throw new HttpException(statusCode);</div><div class="line">    &#125; else &#123;</div><div class="line">      throw new HttpException(urlConnection.getResponseMessage(), statusCode);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>通过分析可知，Glide默认的网络加载使用的是urlConnection。当然我们也可以通过自定义ModelLoader，使用okhttp、volley等的网络框架进行加载。</p>
<p>具体可参考博文<br> <a href="https://blog.csdn.net/chunqiuwei/article/details/78493288?locationNum=3&amp;fps=1" target="_blank" rel="external">Glide 4.x添加自定义组件原理</a></p>
<h1 id="Glide中代码运用了那些设计模式，有什么巧妙的设计？"><a href="#Glide中代码运用了那些设计模式，有什么巧妙的设计？" class="headerlink" title="Glide中代码运用了那些设计模式，有什么巧妙的设计？"></a>Glide中代码运用了那些设计模式，有什么巧妙的设计？</h1><p>1、建造者模式</p>
<p>Glide对象的创建使用Build模式，将复杂对象的创建和表示分离，调用者不需要知道复杂的创建过程，使用Build的相关方法进行配置创建对象。</p>
<p>2、外观模式</p>
<p>Glide对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、策略模式</p>
<p>关于DecodeJob中的DataFetcherGenerator资源获取，采用了策略模式，将数据加载的不同算法进行封装。</p>
<p>4、工厂模式 </p>
<p>ModelLoader的创建使用了ModelLoaderFactory、Engine中的EngineJobFactory、DiskLruCacheFactory等</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Glide正因为其强大的功能，高效的运行机制，所以源码的实现非常复杂。在学习的过程中也遇到很多的困难，最终还是一步一步坚持下来了。有时候放弃就是一瞬间的念头，但坚持下来，终究会有收获。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://blog.csdn.net/guolin_blog/article/details/78582548" target="_blank" rel="external">Android图片加载框架最全解析（八），带你全面了解Glide 4的用法</a></p>
<p>  <a href="https://blog.csdn.net/exceptional_derek/article/details/11713255" target="_blank" rel="external">如何用LinkedHashMap实现LRU缓存算法</a></p>
<p>  <a href="https://www.jianshu.com/p/0c56dc217917" target="_blank" rel="external">DiskLruCache缓存</a></p>
<p> <a href="https://blog.csdn.net/u011803341/article/details/62434085" target="_blank" rel="external">Glide解析-cache</a></p>
<p>  <a href="https://blog.csdn.net/chunqiuwei/article/details/78493288?locationNum=3&amp;fps=1" target="_blank" rel="external">Glide 4.x添加自定义组件原理</a></p>
<p> <a href="https://www.cnblogs.com/android-blogs/p/5735655.html" target="_blank" rel="external">Android Glide源码分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/07/Retrofit源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/07/Retrofit源码学习随笔/" itemprop="url">
                  Retrofit源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T17:06:09+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/07/Retrofit源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/07/Retrofit源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Retrofit是什么？"><a href="#Retrofit是什么？" class="headerlink" title="Retrofit是什么？"></a>Retrofit是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Retrofit，中文的翻译为“式样翻新”的意思，是一个基于OKHttp的RESTful网络请求框架。通俗一点来说，Retrofit就是一个网络请求框架的封装。同样是由Square公司开源的Android热门网络框架之一，其具有功能强大、简洁易用及高可拓展性特点。</p>
<p>官网网址：<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a></p>
<p>Github地址:<a href="https://github.com/square/retrofit" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、基于OkHttp并遵循Restful API设计风格</p>
<p>2、通过注解的形式，可简便的配置网络请求参数</p>
<p>3、支持同步及异步的网络请求方式</p>
<p>4、支持RxJava</p>
<p>5、支持多种数据格式的解析（Json、XML、Protobuf等）</p>
<h1 id="Retrofit怎么用？"><a href="#Retrofit怎么用？" class="headerlink" title="Retrofit怎么用？"></a>Retrofit怎么用？</h1><p>1、gradle引入库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.4.0&apos;</div><div class="line">implementation &apos;com.squareup.retrofit2:converter-gson:2.4.0&apos; //配置使用Gson解析响应数据 可选</div><div class="line">implementation &apos;com.squareup.retrofit2:adapter-rxjava:2.4.0&apos; //配置支持RxJava 可选</div></pre></td></tr></table></figure></p>
<p>2、初始化Retrofit对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">              .baseUrl(BASE_URL) //配置baseUrl</div><div class="line">              .addConverterFactory(GsonConverterFactory.create()) //配置使用Gson解析响应数据</div><div class="line">              .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) //配置支持RxJava</div><div class="line">              .build();</div></pre></td></tr></table></figure>
<h2 id="网络接口定义"><a href="#网络接口定义" class="headerlink" title="网络接口定义"></a>网络接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface WeatherService &#123;</div><div class="line">        //使用GET请求 直接返回原始数据</div><div class="line">        @GET(&quot;weather?location=%E5%98%89%E5%85%B4&amp;output=json&amp;ak=5slgyqGDENN7Sy7pw29IUvrZ&quot;)</div><div class="line">        Call&lt;ResponseBody&gt; cityNameQueryWeather();</div><div class="line">        </div><div class="line">        //使用GET请求 返回Json映射对象</div><div class="line">        @GET(&quot;&#123;weather&#125;?location=%E5%98%89%E5%85%B4&amp;output=json&quot;)</div><div class="line">        Call&lt;WeatherResp&gt; cityWeatherPath(@Path(&quot;weather&quot;) String weather, @Query(&quot;ak&quot;) String ak);</div><div class="line">        </div><div class="line">       //使用POST请求 支持RxJava返回</div><div class="line">        @FormUrlEncoded()</div><div class="line">        @POST(&quot;&#123;weather&#125;&quot;)</div><div class="line">        rx.Observable&lt;WeatherResp&gt; cityWeatherPost(@Path(&quot;weather&quot;) String weather, @Field(&quot;ak&quot;) String ak, @Field(&quot;location&quot;) String location, @Field(&quot;output&quot;) String output);</div><div class="line">        </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">        Call&lt;ResponseBody&gt; responseBodyCall = weatherService.cityNameQueryWeather();</div><div class="line">        try &#123;</div><div class="line">            Response&lt;ResponseBody&gt; responseBody = responseBodyCall.execute();</div><div class="line">            System.out.println(&quot;call:&quot; + responseBody.body().string());</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">       Call&lt;WeatherResp&gt; responseBodyCall = weatherService.cityWeatherPath(&quot;weather&quot;, &quot;5slgyqGDENN7Sy7pw29IUvrZ&quot;);</div><div class="line">       responseBodyCall.enqueue(new Callback&lt;WeatherResp&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;WeatherResp&gt; call, Response&lt;WeatherResp&gt; response) &#123;</div><div class="line">               System.out.println(&quot;call:&quot; + response.toString());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;WeatherResp&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<h2 id="RxJava支持"><a href="#RxJava支持" class="headerlink" title="RxJava支持"></a>RxJava支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">WeatherService weatherService = retrofit.create(WeatherService.class);</div><div class="line">       weatherService.rxCityWeatherPost(&quot;weather&quot;, &quot;5slgyqGDENN7Sy7pw29IUvrZ&quot;, &quot;%E5%98%89%E5%85%B4&quot;, &quot;json&quot;)</div><div class="line">               .subscribeOn(Schedulers.io())        //在新线程里面处理网络请求</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())  //在主线程里面接受返回的数据</div><div class="line">               .subscribe(new rx.Observer&lt;WeatherResp&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void onCompleted() &#123;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   @Override</div><div class="line">                   public void onError(Throwable e) &#123;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   @Override</div><div class="line">                   public void onNext(WeatherResp weatherResp) &#123;</div><div class="line">                       System.out.println(&quot;call:&quot; + weatherResp.toString());</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div></pre></td></tr></table></figure>
<p>详细的Retrofit的注解配置及各注解的使用，推荐参考</p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="external">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>
<h1 id="Retrofit核心执行流程是怎样？"><a href="#Retrofit核心执行流程是怎样？" class="headerlink" title="Retrofit核心执行流程是怎样？"></a>Retrofit核心执行流程是怎样？</h1><h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retrofit</td>
<td>里面包含了很多对象，serviceMethodCache(自定义的接口映射对象集合)、baseUrl（请求地址）、callFactory（默认为OKHttpCall）、converterFactories（数据解析器工厂集合）、callAdapterFactories（Call适配器工厂集合）、callbackExecutor（回调执行，Android平台默认为MainThreadExecutor）使用Builder模型构建</td>
</tr>
<tr>
<td>Platform</td>
<td>Retrofit中用来管理多平台的方法，支持Android、Java8。通过findPlatform获取对应的平台，同时也初始化了defaultCallAdapterFactory工厂</td>
</tr>
<tr>
<td>ServiceMethod</td>
<td>接口映射的网络请求对象，通过动态代理，将自定义接口的标注转换为该对象，将标注及参数生成OkHttp所需的Request对象。Retrofit的create通过动态代理拦截，将每一个自定义接口转换成为一个ServiceMethod对象，并通过通过serviceMethodCache进行缓存。</td>
</tr>
<tr>
<td>Call<t></t></td>
<td>Retrofit定义的网络请求接口，包含execute、enqueue等方法</td>
</tr>
<tr>
<td>OkHttpCall</td>
<td>Ohttp的Call实现，通过createRawCall得到真正的 okhttp3.Call对象，用于进行实际的网络请求</td>
</tr>
<tr>
<td>CallAdapter.Factory</td>
<td>CallAdapter的静态工厂，包含get的抽象方法，用于生产CallAdapter对象</td>
</tr>
<tr>
<td>ExecutorCallAdapterFactory</td>
<td>Android平台默认的CallAdapter工厂，get方法使用匿名内部类实现CallAdapter，返回ExecutorCallbackCall，实现了Call</td>
</tr>
<tr>
<td>ExecutorCallbackCall</td>
<td>采用静态代理设计，delegate实际为OkHttpCall，使用callbackExecutor实现回调在主线程中执行</td>
</tr>
<tr>
<td>RxJavaCallAdapterFactory</td>
<td>Rxjava平台的CallAdapter工厂，get方法返回RxJavaCallAdapter对象</td>
</tr>
<tr>
<td>RxJavaCallAdapter</td>
<td>Rxjava平台的设配器，返回observable对象</td>
</tr>
<tr>
<td>Converter.Factory</td>
<td>数据解析器工厂，用于生产Converter实例</td>
</tr>
<tr>
<td>GsonConverterFactory</td>
<td>数据解析工厂实例，返回了GsonResponseBodyConverter数据解析器</td>
</tr>
<tr>
<td>GsonResponseBodyConverter</td>
<td>Gson的数据解析器，将服务端返回的json对象转换成对应的java模型</td>
</tr>
<tr>
<td>Response<t></t></td>
<td>Retrofit网络请求响应的Response</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-e251df442d1596cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>通过Build模式构建Retrofit对象</li>
<li>自定义的接口interface，包含接口方法及相关标注</li>
<li>执行定义的接口方法</li>
<li>通过Proxy.newProxyInstance进行动态代理拦截</li>
<li>通过反射将定义的标注方法解析生成ServiceMethod对象（表示一个网络请求的封装对象）并加入serviceMethodCache队列中，避免重复解析</li>
<li>创建OkHttpCall对象， 继承了Call<t>接口，桥接okhttp3.Call rawCall</t></li>
<li>从Retrofit对象的callAdapterFactories工厂集合获取CallAdapter，并调用adapt方法。如果是默认的使用ExecutorCallAdapterFactory设配返回Call<object>，如果设置了RxJavaCallAdapterFactory，返回observable。</object></li>
<li>获取适配器转换后的对象，执行同步请求或者异步请求。</li>
<li>创建Okhttp的RealCall对象</li>
<li>通过反射的arg参数，调用serviceMethod.toCall()，构建生成Okhttp的RealCall所需要的Request对象</li>
<li>通过OkHttp的RealCall执行对应的同步或异步请求</li>
<li>请求成功，通过parseResponse解析请求参数</li>
<li>通过数据转换器responseConverter.convert(body)，将原始数据转换为对象</li>
<li>回调解析完的数据对象Respone(T)</li>
</ol>
<h1 id="Retrofit-如何将定义的interface转换成网络请求？"><a href="#Retrofit-如何将定义的interface转换成网络请求？" class="headerlink" title="Retrofit 如何将定义的interface转换成网络请求？"></a>Retrofit 如何将定义的interface转换成网络请求？</h1><p>我们都知道，Retrofit通过自定义interface及相关的标注来描述一个http的请求，使用非常简便，且易于维护。</p>
<p>这是Retrofit设计的精髓之一，，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象，ServiceMethod中封装了OKHttp网络请求所需的相关参数。</p>
<p>源码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">   Utils.validateServiceInterface(service);</div><div class="line">   if (validateEagerly) &#123;</div><div class="line">     eagerlyValidateMethods(service);</div><div class="line">   &#125;</div><div class="line">   return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">       new InvocationHandler() &#123;</div><div class="line">         private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">         @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</div><div class="line">             throws Throwable &#123;</div><div class="line">           // If the method is a method from Object then defer to normal invocation.</div><div class="line">           if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">             return method.invoke(this, args);</div><div class="line">           &#125;</div><div class="line">           if (platform.isDefaultMethod(method)) &#123;</div><div class="line">             return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">           &#125;</div><div class="line">           //生成ServiceMethod</div><div class="line">           ServiceMethod&lt;Object, Object&gt; serviceMethod =o</div><div class="line">               (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">           OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">           return serviceMethod.adapt(okHttpCall);</div><div class="line">         &#125;</div><div class="line">       &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>通过源码我们知道，具体的转换方法为 (ServiceMethod<object, object="">) loadServiceMethod(method)，具体的实现如下：</object,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">    if (result != null) return result;</div><div class="line"></div><div class="line">    synchronized (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      if (result == null) &#123;</div><div class="line">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过Builder构建模式，创建一个ServiceMethod对象，并加入缓存，具体的构造实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">     this.retrofit = retrofit;</div><div class="line">     this.method = method;</div><div class="line">     this.methodAnnotations = method.getAnnotations();</div><div class="line">     this.parameterTypes = method.getGenericParameterTypes();</div><div class="line">     this.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public ServiceMethod build() &#123;</div><div class="line">     callAdapter = createCallAdapter();</div><div class="line">     responseType = callAdapter.responseType();</div><div class="line">     if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</div><div class="line">       throw methodError(&quot;&apos;&quot;</div><div class="line">           + Utils.getRawType(responseType).getName()</div><div class="line">           + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</div><div class="line">     &#125;</div><div class="line">     responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">     for (Annotation annotation : methodAnnotations) &#123;</div><div class="line">       parseMethodAnnotation(annotation);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (httpMethod == null) &#123;</div><div class="line">       throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (!hasBody) &#123;</div><div class="line">       if (isMultipart) &#123;</div><div class="line">         throw methodError(</div><div class="line">             &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</div><div class="line">       &#125;</div><div class="line">       if (isFormEncoded) &#123;</div><div class="line">         throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</div><div class="line">             + &quot;request body (e.g., @POST).&quot;);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     int parameterCount = parameterAnnotationsArray.length;</div><div class="line">     parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">     for (int p = 0; p &lt; parameterCount; p++) &#123;</div><div class="line">       Type parameterType = parameterTypes[p];</div><div class="line">       if (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">         throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</div><div class="line">             parameterType);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">       if (parameterAnnotations == null) &#123;</div><div class="line">         throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</div><div class="line">       throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</div><div class="line">     &#125;</div><div class="line">     if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</div><div class="line">       throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</div><div class="line">     &#125;</div><div class="line">     if (isFormEncoded &amp;&amp; !gotField) &#123;</div><div class="line">       throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</div><div class="line">     &#125;</div><div class="line">     if (isMultipart &amp;&amp; !gotPart) &#123;</div><div class="line">       throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     return new ServiceMethod&lt;&gt;(this);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>build()方法会通过反射去解析method的标注、参数的类型等。详细的解析可参考源码ParameterHandler相关实现，这里主要对流程进行剖析。</p>
<p>总结一下，Retrofit通过自定义interface及相关的标注来描述一个http的请求，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象，ServiceMethod中封装了OKHttp网络请求所需的相关参数。这就是Retrofit将定义的interface转换成网络请求对象的过程。</p>
<h1 id="Retrofit的Converter机制是如何实现？"><a href="#Retrofit的Converter机制是如何实现？" class="headerlink" title="Retrofit的Converter机制是如何实现？"></a>Retrofit的Converter机制是如何实现？</h1><h2 id="Converter种类"><a href="#Converter种类" class="headerlink" title="Converter种类"></a>Converter种类</h2><p>Retrofit支持多种数据解析方式，使用时需要在Gradle添加依赖。</p>
<table>
<thead>
<tr>
<th>数据解析器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.4.0</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.4.0</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.4.0</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.4.0</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.4.0</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.4.0</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.4.0</td>
</tr>
</tbody>
</table>
<h2 id="Converter实现流程"><a href="#Converter实现流程" class="headerlink" title="Converter实现流程"></a>Converter实现流程</h2><h3 id="添加Converter工厂"><a href="#添加Converter工厂" class="headerlink" title="添加Converter工厂"></a>添加Converter工厂</h3><p>首先在Retrofit的初始化添加Converter，addConverterFactory(GsonConverterFactory.create())。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Builder addConverterFactory(Converter.Factory factory) &#123;</div><div class="line">    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>将Converter的工厂加入到converterFactories集合中。</p>
<h3 id="触发数据转换"><a href="#触发数据转换" class="headerlink" title="触发数据转换"></a>触发数据转换</h3><p>通过上述的流程分析，我们知道Retrofit当网络请求成功后会执行，OkHttpCall中的parseResponse方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">   ResponseBody rawBody = rawResponse.body();</div><div class="line"></div><div class="line">   // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</div><div class="line">   rawResponse = rawResponse.newBuilder()</div><div class="line">       .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">       .build();</div><div class="line"></div><div class="line">   int code = rawResponse.code();</div><div class="line">   if (code &lt; 200 || code &gt;= 300) &#123;</div><div class="line">     try &#123;</div><div class="line">       // Buffer the entire body to avoid future I/O.</div><div class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class="line">       return Response.error(bufferedBody, rawResponse);</div><div class="line">     &#125; finally &#123;</div><div class="line">       rawBody.close();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (code == 204 || code == 205) &#123;</div><div class="line">     rawBody.close();</div><div class="line">     return Response.success(null, rawResponse);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">   try &#123;</div><div class="line">     T body = serviceMethod.toResponse(catchingBody);</div><div class="line">     return Response.success(body, rawResponse);</div><div class="line">   &#125; catch (RuntimeException e) &#123;</div><div class="line">     // If the underlying source threw an exception, propagate that rather than indicating it was</div><div class="line">     // a runtime exception.</div><div class="line">     catchingBody.throwIfCaught();</div><div class="line">     throw e;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>其中关键的代码为 T body = serviceMethod.toResponse(catchingBody)，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Builds a method return value from an HTTP response body. */</div><div class="line"> R toResponse(ResponseBody body) throws IOException &#123;</div><div class="line">   return responseConverter.convert(body);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="数据转换器的创建"><a href="#数据转换器的创建" class="headerlink" title="数据转换器的创建"></a>数据转换器的创建</h3><p>这里就是 Converter实现转换的地方，那么responseConverter在哪里进行初始化呢？在ServiceMethod的Build方法中，会调用createResponseConverter()进行数据解析器的创建，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123;</div><div class="line">     Annotation[] annotations = method.getAnnotations();</div><div class="line">     try &#123;</div><div class="line">       return retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">     &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</div><div class="line">       throw methodError(e, &quot;Unable to create converter for %s&quot;, responseType);</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用了 retrofit.responseBodyConverter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;</div><div class="line">   return nextResponseBodyConverter(null, type, annotations);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>调用了 retrofit.nextResponseBodyConverter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</div><div class="line">     @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</div><div class="line">   checkNotNull(type, &quot;type == null&quot;);</div><div class="line">   checkNotNull(annotations, &quot;annotations == null&quot;);</div><div class="line"></div><div class="line">   int start = converterFactories.indexOf(skipPast) + 1;</div><div class="line">   for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">     Converter&lt;ResponseBody, ?&gt; converter =</div><div class="line">         converterFactories.get(i).responseBodyConverter(type, annotations, this);</div><div class="line">     if (converter != null) &#123;</div><div class="line">       //noinspection unchecked</div><div class="line">       return (Converter&lt;ResponseBody, T&gt;) converter;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   StringBuilder builder = new StringBuilder(&quot;Could not locate ResponseBody converter for &quot;)</div><div class="line">       .append(type)</div><div class="line">       .append(&quot;.\n&quot;);</div><div class="line">   if (skipPast != null) &#123;</div><div class="line">     builder.append(&quot;  Skipped:&quot;);</div><div class="line">     for (int i = 0; i &lt; start; i++) &#123;</div><div class="line">       builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</div><div class="line">     &#125;</div><div class="line">     builder.append(&apos;\n&apos;);</div><div class="line">   &#125;</div><div class="line">   builder.append(&quot;  Tried:&quot;);</div><div class="line">   for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">     builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</div><div class="line">   &#125;</div><div class="line">   throw new IllegalArgumentException(builder.toString());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>通过Retrofit的converterFactories工厂集合匹配获取开始添加的数据转换工厂</p>
<h3 id="默认的数据转换工厂"><a href="#默认的数据转换工厂" class="headerlink" title="默认的数据转换工厂"></a>默认的数据转换工厂</h3><p>通过Retrofit build() 中发现如下代码，converterFactories.add(new BuiltInConverters())，可知Retrofit默认的数据转换器工厂为BuiltInConverters。主要实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</div><div class="line">     Retrofit retrofit) &#123;</div><div class="line">   if (type == ResponseBody.class) &#123;</div><div class="line">     return Utils.isAnnotationPresent(annotations, Streaming.class)</div><div class="line">         ? StreamingResponseBodyConverter.INSTANCE</div><div class="line">         : BufferingResponseBodyConverter.INSTANCE;</div><div class="line">   &#125;</div><div class="line">   if (type == Void.class) &#123;</div><div class="line">     return VoidResponseBodyConverter.INSTANCE;</div><div class="line">   &#125;</div><div class="line">   return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>会将数据转换为ResponseBody对象，所以如果Retrofit默认不使用任何数据解析器，定义interface方法时接收数据对象使用 Call<responsebody>。</responsebody></p>
<h1 id="Retrofit的CallAdapter机制是如何实现？"><a href="#Retrofit的CallAdapter机制是如何实现？" class="headerlink" title="Retrofit的CallAdapter机制是如何实现？"></a>Retrofit的CallAdapter机制是如何实现？</h1><p>Retrofit支持多种网络请求适配器方式：guava、Java8和rxjava 。Android默认的适配器工厂为ExecutorCallAdapterFactory，最后的回调通过ExecutorCallbackCall切换至主线程运行。</p>
<h2 id="CallAdapter种类"><a href="#CallAdapter种类" class="headerlink" title="CallAdapter种类"></a>CallAdapter种类</h2><table>
<thead>
<tr>
<th>网络请求适配器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.4.0</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.4.0</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.4.0</td>
</tr>
</tbody>
</table>
<h2 id="CallAdapter实现流程"><a href="#CallAdapter实现流程" class="headerlink" title="CallAdapter实现流程"></a>CallAdapter实现流程</h2><h3 id="添加CallAdapter工厂"><a href="#添加CallAdapter工厂" class="headerlink" title="添加CallAdapter工厂"></a>添加CallAdapter工厂</h3><p>首先在Retrofit的初始化添加CallAdapter工厂，addCallAdapterFactory(RxJavaCallAdapterFactory.create())。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123;</div><div class="line">  callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将CallAdapter的工厂加入到callAdapterFactories集合中。</p>
<h3 id="CallAdapter的adapt实现"><a href="#CallAdapter的adapt实现" class="headerlink" title="CallAdapter的adapt实现"></a>CallAdapter的adapt实现</h3><p>通过上述Retrofit的create方法中分析可知，当拦截到interface的方法调用后最后会执行 return serviceMethod.adapt(okHttpCall)。adapt的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T adapt(Call&lt;R&gt; call) &#123;</div><div class="line">  return callAdapter.adapt(call);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是在这个地方触发了callAdapter的adapt方法。返回最终适配的具体对象。</p>
<h3 id="默认的CallAdapter工厂"><a href="#默认的CallAdapter工厂" class="headerlink" title="默认的CallAdapter工厂"></a>默认的CallAdapter工厂</h3><p>Android平台默认的CallAdapter工厂为ExecutorCallAdapterFactory。通过Retrofit的build()方法可知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Make a defensive copy of the adapters and add the default Call adapter.</div><div class="line">     List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">     callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div></pre></td></tr></table></figure></p>
<p>platform.defaultCallAdapterFactory的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</div><div class="line">   if (callbackExecutor != null) &#123;</div><div class="line">     return new ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">   &#125;</div><div class="line">   return DefaultCallAdapterFactory.INSTANCE;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>ExecutorCallAdapterFactory的CallAdapter创建如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">       if (getRawType(returnType) != Call.class) &#123;</div><div class="line">           return null;</div><div class="line">       &#125; else &#123;</div><div class="line">           final Type responseType = Utils.getCallResponseType(returnType);</div><div class="line">           return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">               public Type responseType() &#123;</div><div class="line">                   return responseType;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">                   return new ExecutorCallAdapterFactory.ExecutorCallbackCall(ExecutorCallAdapterFactory.this.callbackExecutor, call);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>adapt方法最后返回还是Call<object>对象，具体的适配实现由ExecutorCallbackCall执行，具体源码如下：</object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">        final Executor callbackExecutor;</div><div class="line">        final Call&lt;T&gt; delegate;</div><div class="line"></div><div class="line">        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">            this.callbackExecutor = callbackExecutor;</div><div class="line">            this.delegate = delegate;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">            Utils.checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line">            this.delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">                public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">                    ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() &#123;</div><div class="line">                        public void run() &#123;</div><div class="line">                            if (ExecutorCallbackCall.this.delegate.isCanceled()) &#123;</div><div class="line">                                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">                            &#125; else &#123;</div><div class="line">                                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">                    ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() &#123;</div><div class="line">                        public void run() &#123;</div><div class="line">                            callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       </div><div class="line"></div><div class="line">        public Response&lt;T&gt; execute() throws IOException &#123;</div><div class="line">            return this.delegate.execute();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的执行还是通过delegate（OkHttpCall）来执行，但是在回调使用了 ExecutorCallbackCall.this.callbackExecutor.execute()方法，Android平台的callbackExecutor实现为MainThreadExecutor。具体源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class MainThreadExecutor implements Executor &#123;</div><div class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">      @Override public void execute(Runnable r) &#123;</div><div class="line">        handler.post(r);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>所以ExecutorCallAdapterFactory中适配最后的设配对象还是Call<object>,实现还是OkHttpCall，通过 MainThreadExecutor，将回调切换在UI线程中运行</object></p>
<h3 id="CallAdapter的创建"><a href="#CallAdapter的创建" class="headerlink" title="CallAdapter的创建"></a>CallAdapter的创建</h3><p>在ServiceMethod的Build方法中，createCallAdapter()进行适配器的的创建，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</div><div class="line">    Type returnType = method.getGenericReturnType();</div><div class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</div><div class="line">      throw methodError(</div><div class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</div><div class="line">    &#125;</div><div class="line">    if (returnType == void.class) &#123;</div><div class="line">      throw methodError(&quot;Service methods cannot return void.&quot;);</div><div class="line">    &#125;</div><div class="line">    Annotation[] annotations = method.getAnnotations();</div><div class="line">    try &#123;</div><div class="line">      //noinspection unchecked</div><div class="line">      return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</div><div class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</div><div class="line">      throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用了 retrofit.callAdapter</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</div><div class="line">  return nextCallAdapter(null, returnType, annotations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了 retrofit.nextCallAdapter</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</div><div class="line">    Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(returnType, &quot;returnType == null&quot;);</div><div class="line">  checkNotNull(annotations, &quot;annotations == null&quot;);</div><div class="line"></div><div class="line">  int start = callAdapterFactories.indexOf(skipPast) + 1;</div><div class="line">  for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);</div><div class="line">    if (adapter != null) &#123;</div><div class="line">      return adapter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</div><div class="line">      .append(returnType)</div><div class="line">      .append(&quot;.\n&quot;);</div><div class="line">  if (skipPast != null) &#123;</div><div class="line">    builder.append(&quot;  Skipped:&quot;);</div><div class="line">    for (int i = 0; i &lt; start; i++) &#123;</div><div class="line">      builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</div><div class="line">    &#125;</div><div class="line">    builder.append(&apos;\n&apos;);</div><div class="line">  &#125;</div><div class="line">  builder.append(&quot;  Tried:&quot;);</div><div class="line">  for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</div><div class="line">  &#125;</div><div class="line">  throw new IllegalArgumentException(builder.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Retrofit的callAdapterFactories工厂集合匹配获取开始添加的适配器工厂</p>
<h1 id="如何自定义一个Converter及CallAdapter？"><a href="#如何自定义一个Converter及CallAdapter？" class="headerlink" title="如何自定义一个Converter及CallAdapter？"></a>如何自定义一个Converter及CallAdapter？</h1><h2 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h2><p>1、需要定义一个工厂类继承Converter.Factory</p>
<p>2、复写responseBodyConverter及requestBodyConverter方法</p>
<p>3、在Retrofit定义时加入自定义的Converter，addConverterFactory(new CustomConverterFactory())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author allen</div><div class="line"> * @date 2018/8/7</div><div class="line"> * 返回服务端返回的string结果</div><div class="line"> */</div><div class="line">public class CustomConverterFactory extends Converter.Factory &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        return StringResponseBodyConverter.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</div><div class="line">        return StringRequestBodyConverter.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static final class StringResponseBodyConverter implements Converter&lt;ResponseBody, String&gt; &#123;</div><div class="line">        static final CustomConverterFactory.StringResponseBodyConverter INSTANCE = new CustomConverterFactory.StringResponseBodyConverter();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String convert(ResponseBody value) &#123;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;CustomConverterFactory&quot;);</div><div class="line">                return value.string();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    static final class StringRequestBodyConverter implements Converter&lt;RequestBody, RequestBody&gt; &#123;</div><div class="line">        static final CustomConverterFactory.StringRequestBodyConverter INSTANCE = new CustomConverterFactory.StringRequestBodyConverter();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public RequestBody convert(@NonNull RequestBody value) &#123;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义CallAdapter"><a href="#自定义CallAdapter" class="headerlink" title="自定义CallAdapter"></a>自定义CallAdapter</h2><p>1、需要定义一个工厂类继承CallAdapter.Factory</p>
<p>2、复写CallAdapter&lt;?, ?&gt; get方法</p>
<p>3、在Retrofit定义时加入自定义的CallAdapter， addCallAdapterFactory(new CustomCallAdapterFactory())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author allen</div><div class="line"> * @date 2018/8/7</div><div class="line"> */</div><div class="line">public class CustomCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line"></div><div class="line">        return new CallAdapter&lt;Object, Object&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Type responseType() &#123;</div><div class="line">                return String.class;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public Object adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">                System.out.println(&quot;CustomCallAdapterFactory adapt(&quot;);</div><div class="line">                return call;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Retrofit中运用了那些设计模式？"><a href="#Retrofit中运用了那些设计模式？" class="headerlink" title="Retrofit中运用了那些设计模式？"></a>Retrofit中运用了那些设计模式？</h1><p>1、建造者模式</p>
<p>Retrofit对象的创建、ServiceMethod对象创建都使用Build模式，将复杂对象的创建和表示分离，调用者不需要知道复杂的创建过程，使用Build的相关方法进行配置创建对象。</p>
<p>2、外观模式 </p>
<p>Retrofit对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、动态代理模式</p>
<p>通过动态代理的方式，当调用Retrofit的create()方法时，会进行动态代理监听。当执行具体的接口方法时，会回调InvocationHandler。通过反射解析method的标注及参数，生成ServiceMethod对象。</p>
<p>4、静态代理模式<br>Android平台默认的适配器ExecutorCallbackCall，采用静态代理的模式。具体的实现delegate为OkHttpCall。</p>
<p>5、工厂模式<br>Converter及CallAdapter的创建都采用了工厂模式进行创建。</p>
<p>6、适配器模式<br>CallAdapter的adapt采用了适配器模式，使得interface的返回对象可以动态扩展，增强了灵活性</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>大多数流行的开源框架都是经过顶级coder的设计，包含了很多精妙的设计。多学习分析，收益良多。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="external">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73732115" target="_blank" rel="external">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2018/08/02/OkHttp源码学习随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/02/OkHttp源码学习随笔/" itemprop="url">
                  OkHttp源码学习随笔
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T15:13:51+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/02/OkHttp源码学习随笔/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/OkHttp源码学习随笔/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OkHttp是什么？"><a href="#OkHttp是什么？" class="headerlink" title="OkHttp是什么？"></a>OkHttp是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OkHttp是一款优秀的HTTP框架，它支持get请求和post请求，支持基于Http的文件上传和下载，支持加载图片，支持下载文件透明的GZIP压缩，支持响应缓存避免重复的网络请求，支持使用连接池来降低响应延迟问题。OkHttp由Square公司开发，是目前Android最热门的网络框架之一。</p>
<p>官网网址：<a href="http://square.github.io/okhttp/" target="_blank" rel="external">OKHttp官网</a></p>
<p>Github地址:<a href="https://github.com/square/okhttp" target="_blank" rel="external">Github</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>支持HTTP2/SPDY</li>
<li>socket自动选择最好路线，并支持自动重连</li>
<li>拥有自动维护的socket连接池，减少握手次数</li>
<li>拥有队列线程池，轻松写并发</li>
<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）基于Headers的缓存策略</li>
</ol>
<h1 id="OkHttp怎么用？"><a href="#OkHttp怎么用？" class="headerlink" title="OkHttp怎么用？"></a>OkHttp怎么用？</h1><p>1、gradle引入库，implementation ‘com.squareup.okhttp3:okhttp:3.11.0’</p>
<p>2、初始化OkHttpClient对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client = new OkHttpClient.Builder()</div><div class="line">               .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .readTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .writeTimeout(15, TimeUnit.SECONDS)</div><div class="line">               .build();</div></pre></td></tr></table></figure>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void okHttpSync() &#123;</div><div class="line">        Request request = new Request.Builder()</div><div class="line">                .url(&quot;https://www.baidu.com&quot;)</div><div class="line">                .build();</div><div class="line">        Call call = client.newCall(request);</div><div class="line">        try &#123;</div><div class="line">            Response response = call.execute();</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                System.out.println(&quot;response.code()==&quot; + response.code());</div><div class="line">                System.out.println(&quot;response.heard()==&quot; + response.headers());</div><div class="line">                System.out.println(&quot;response.message()==&quot; + response.message());</div><div class="line">                System.out.println(&quot;res==&quot; + response.body().string());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void okHttpAsync() &#123;</div><div class="line">    Request request = new Request.Builder()</div><div class="line">            .url(&quot;https://www.baidu.com&quot;)</div><div class="line">            .build();</div><div class="line">    Call call = client.newCall(request);</div><div class="line">    call.enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;</div><div class="line">            needCancelled.set(true);</div><div class="line">            System.out.println(&quot;url==&quot; + call.request().url());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                System.out.println(&quot;response.code()==&quot; + response.code());</div><div class="line">                System.out.println(&quot;response.heard()==&quot; + response.headers());</div><div class="line">                System.out.println(&quot;response.message()==&quot; + response.message());</div><div class="line">                System.out.println(&quot;res==&quot; + response.body().string());</div><div class="line">                needCancelled.set(true);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细的OkHttp使用可参考<a href="https://blog.csdn.net/fightingXia/article/details/70947701" target="_blank" rel="external">OKHttp使用详解</a></p>
<h1 id="OkHttp核心执行流程是怎样？"><a href="#OkHttp核心执行流程是怎样？" class="headerlink" title="OkHttp核心执行流程是怎样？"></a>OkHttp核心执行流程是怎样？</h1><h2 id="关键类功能说明"><a href="#关键类功能说明" class="headerlink" title="关键类功能说明"></a>关键类功能说明</h2><table>
<thead>
<tr>
<th>类</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OKHttpClient</td>
<td>里面包含了很多对象，OKhttp的很多功能模块都包装进这个类，让这个类单独提供对外的API，使用Builder模型构建</td>
</tr>
<tr>
<td>Request、Response</td>
<td>抽象的网络输入及响应模型</td>
</tr>
<tr>
<td>Call</td>
<td>HTTP请求任务封装，是一个接口</td>
</tr>
<tr>
<td>RealCall</td>
<td>Call的实现，实现execute()同步方法、enqueue(Callback responseCallback)异步方法， getResponseWithInterceptorChain() 获取拦截器响应</td>
</tr>
<tr>
<td>AsyncCall</td>
<td>RealCall的内部类。继承了Runnable接口，后续在异步的线程池中执行</td>
</tr>
<tr>
<td>Dispatcher</td>
<td>核心调度类，内部维护为了readyAsyncCalls、runningAsyncCalls、runningSyncCalls队列，实际RealCall后续也是调用该类进行同步、异步的具体实现。内部维护了一个线程池，限制了最大并发数maxRequests=64。</td>
</tr>
<tr>
<td>RealInterceptorChain</td>
<td>拦截器链，维护了一个interceptors队列，每次proceed通过index + 1会执行下一拦截器的intercept方法</td>
</tr>
<tr>
<td>RetryAndFollowUpInterceptor</td>
<td>负责失败重连以及重定向</td>
</tr>
<tr>
<td>BridgeInterceptor</td>
<td>负责对Request和Response报文进行加工</td>
</tr>
<tr>
<td>CacheInterceptor</td>
<td>负责缓存拦截器</td>
</tr>
<tr>
<td>ConnectInterceptor</td>
<td>负责维护连接拦截器</td>
</tr>
<tr>
<td>CallServerInterceptor</td>
<td>负责最后网络IO的读写</td>
</tr>
</tbody>
</table>
<h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-308f8d448174afa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>1、通过Builder模式统一构建OkHttpClient对象</p>
<p>2、通过Call，实现类RealCall进行请求发送</p>
<p>3、RealCall通过调用了Dispatcher的execute()及enqueue()方法进行同步及异步的请求</p>
<p>4、最终调用ReallCall的getResponseWithInterceptorChain()方法进行拦截链的拦截</p>
<p>5、依次通过重定向拦截器、桥接拦截器、缓存拦截器、连接拦截器、网络拦截器依次进行处理</p>
<p>6、最后通过intercept的return往回返回Response，最终返回给客户端请求的结果</p>
<h1 id="OkHttp如何进行线程调度控制？"><a href="#OkHttp如何进行线程调度控制？" class="headerlink" title="OkHttp如何进行线程调度控制？"></a>OkHttp如何进行线程调度控制？</h1><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在Dispatcher中维护了一个线程池，异步的请求会将任务加入到线程池中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public synchronized ExecutorService executorService() &#123;</div><div class="line">   if (executorService == null) &#123;</div><div class="line">     executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</div><div class="line">         new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">   &#125;</div><div class="line">   return executorService;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>默认的最大并发数为maxRequests=64，如果超过限制会加入到等待队列中，执行异步的方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">   if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">     runningAsyncCalls.add(call);</div><div class="line">     executorService().execute(call);</div><div class="line">   &#125; else &#123;</div><div class="line">     readyAsyncCalls.add(call);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>最后线程池执行AsyncCall中的execute()方法，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override protected void execute() &#123;</div><div class="line">   boolean signalledCallback = false;</div><div class="line">   try &#123;</div><div class="line">     Response response = getResponseWithInterceptorChain();</div><div class="line">     if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">       signalledCallback = true;</div><div class="line">       responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">     &#125; else &#123;</div><div class="line">       signalledCallback = true;</div><div class="line">       responseCallback.onResponse(RealCall.this, response);</div><div class="line">     &#125;</div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">     if (signalledCallback) &#123;</div><div class="line">       // Do not signal the callback twice!</div><div class="line">       Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">     &#125; else &#123;</div><div class="line">       eventListener.callFailed(RealCall.this, e);</div><div class="line">       responseCallback.onFailure(RealCall.this, e);</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     client.dispatcher().finished(this);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="队列机制"><a href="#队列机制" class="headerlink" title="队列机制"></a>队列机制</h2><p>Dispathcer中维护了3个队列，分别为异步等待队列、异步执行队列、同步执行队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** Ready async calls in the order they&apos;ll be run. */</div><div class="line"> private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"> /** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line"> private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"> /** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line"> private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>不管是同步还是异步，最终在finally块都会调用dispatcher的finished方法，会移除掉该队列任务，最后实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int runningCallsCount;</div><div class="line">   Runnable idleCallback;</div><div class="line">   synchronized (this) &#123;</div><div class="line">     if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</div><div class="line">     if (promoteCalls) promoteCalls();</div><div class="line">     runningCallsCount = runningCallsCount();</div><div class="line">     idleCallback = this.idleCallback;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</div><div class="line">     idleCallback.run();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>在finish中会再调用promoteCalls方法，会重新检索准备中的队列，将队列加入到线程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void promoteCalls() &#123;</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="OkHttp的拦截器及调用链是怎么执行？"><a href="#OkHttp的拦截器及调用链是怎么执行？" class="headerlink" title="OkHttp的拦截器及调用链是怎么执行？"></a>OkHttp的拦截器及调用链是怎么执行？</h1><h2 id="调用链执行流程"><a href="#调用链执行流程" class="headerlink" title="调用链执行流程"></a>调用链执行流程</h2><p>通过上述的分析，我们知道不管同步还是异步，最终调用到的都是RealCall的getResponseWithInterceptorChain()方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">   // Build a full stack of interceptors.</div><div class="line">   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">   interceptors.addAll(client.interceptors());</div><div class="line">   interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">   interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">   interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">   interceptors.add(new ConnectInterceptor(client));</div><div class="line">   if (!forWebSocket) &#123;</div><div class="line">     interceptors.addAll(client.networkInterceptors());</div><div class="line">   &#125;</div><div class="line">   interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">   Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</div><div class="line">       originalRequest, this, eventListener, client.connectTimeoutMillis(),</div><div class="line">       client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line"></div><div class="line">   return chain.proceed(originalRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>其中定义了拦截器集合及RealInterceptorChain拦截链，具体执行了拦截链的proceed方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">     RealConnection connection) throws IOException &#123;</div><div class="line">   if (index &gt;= interceptors.size()) throw new AssertionError();</div><div class="line"></div><div class="line">   calls++;</div><div class="line"></div><div class="line">   // If we already have a stream, confirm that the incoming request will use it.</div><div class="line">   if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">         + &quot; must retain the same host and port&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we already have a stream, confirm that this is the only call to chain.proceed().</div><div class="line">   if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">         + &quot; must call proceed() exactly once&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Call the next interceptor in the chain.</div><div class="line">   RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</div><div class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</div><div class="line">       writeTimeout);</div><div class="line">   Interceptor interceptor = interceptors.get(index);</div><div class="line">   Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">   // Confirm that the next interceptor made its required call to chain.proceed().</div><div class="line">   if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</div><div class="line">     throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</div><div class="line">         + &quot; must call proceed() exactly once&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Confirm that the intercepted response isn&apos;t null.</div><div class="line">   if (response == null) &#123;</div><div class="line">     throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (response.body() == null) &#123;</div><div class="line">     throw new IllegalStateException(</div><div class="line">         &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return response;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>1、先判断是否超过list的size，如果超过则遍历结束，如果没有超过则继续执行</p>
<p>2、calls+1</p>
<p>3、new了一个RealInterceptorChain，其中然后下标index+1</p>
<p>4、从list取出下一个interceptor对象</p>
<p>5、执行interceptor的intercept方法</p>
<p>总结一下就是每一个RealInterceptorChain对应一个interceptor,然后每一个interceptor再产生下一个RealInterceptorChain，直到List迭代完成。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-0e1febbb5a84fe77?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>从上面的调用关系可以看出除了红色圈出的拦截器之外都是系统提供的拦截器，这整个过程是递归的执行过程，在 CallServerInterceptor 中得到最终的 Response 之后，将 response 按递归逐级进行返回，期间会经过 NetworkInterceptor 最后到达  Application Interceptor 。</p>
<h1 id="OkHttp是如何进行数据缓存？"><a href="#OkHttp是如何进行数据缓存？" class="headerlink" title="OkHttp是如何进行数据缓存？"></a>OkHttp是如何进行数据缓存？</h1><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>OkHttp使用了CacheInterceptor拦截器进行数据缓存的控制使用了CacheStrategy实现了上面的流程图，它根据之前缓存的结果与当前将要发送Request的header进行策略，并得出是否进行请求的结果。根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下：</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>result 结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>null</td>
<td>only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误)</td>
</tr>
<tr>
<td>null</td>
<td>non-null</td>
<td>不进行网络请求，直接返回缓存，不请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td>null</td>
<td>需要进行网络请求，而且缓存不存在或者过去，直接访问网络</td>
</tr>
<tr>
<td>non-null</td>
<td>non-null</td>
<td>Header中包含ETag/Last-Modified标签，需要在满足条件下请求，还是需要访问网络</td>
</tr>
</tbody>
</table>
<h2 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h2><p>通过分析CacheInterceptor拦截器的intercept方法，我们可以发现具体的缓存都是使用了Cache类进行，最后具体的实现在DiskLruCache类中。缓存实际上是一个比较复杂的逻辑，单独的功能块，实际上不属于OKhttp上的功能，实际上是通过是http协议和DiskLruCache做了处理。LinkedHashMap可以实现LRU算法，并且在这个case里，它被用作对DiskCache的内存索引</p>
<p>有兴趣可以参考如下2篇文章的具体实现：</p>
<p><a href="https://www.jianshu.com/p/b32d13655be7" target="_blank" rel="external">OKHttp源码解析(六)–中阶之缓存基础</a></p>
<p><a href="https://www.jianshu.com/p/a68dc1ca6120" target="_blank" rel="external">OKHttp源码解析(七)–中阶之缓存机制</a></p>
<h1 id="OkHttp的连接池复用机制是怎么样？"><a href="#OkHttp的连接池复用机制是怎么样？" class="headerlink" title="OkHttp的连接池复用机制是怎么样？"></a>OkHttp的连接池复用机制是怎么样？</h1><h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><p>RealConnection是Connection的实现类，代表着链接socket的链路，如果拥有了一个RealConnection就代表了我们已经跟服务器有了一条通信链路，而且通过<br>RealConnection代表是连接socket链路，RealConnection对象意味着我们已经跟服务端有了一条通信链路。<br>另外StreamAllocation类为流的桥梁，在RetryAndFollowUpInterceptor中进行初始化，在ConnectInterceptor中进行newStream操作，具体的连接拦截器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">   RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">   Request request = realChain.request();</div><div class="line">   StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">   // We need the network to satisfy this request. Possibly for validating a conditional GET.</div><div class="line">   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</div><div class="line">   HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</div><div class="line">   RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">   return realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>newStream创建留最后会调用到findConnection方法，这里面是连接复用的关键，如果再连接池中找到能复用的连接，则直接返回。<br>否则将RealConnection加入到链接池ConnectionPool中,具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</div><div class="line">     int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123;</div><div class="line">   boolean foundPooledConnection = false;</div><div class="line">   RealConnection result = null;</div><div class="line">   Route selectedRoute = null;</div><div class="line">   Connection releasedConnection;</div><div class="line">   Socket toClose;</div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     if (released) throw new IllegalStateException(&quot;released&quot;);</div><div class="line">     if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</div><div class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">     // Attempt to use an already-allocated connection. We need to be careful here because our</div><div class="line">     // already-allocated connection may have been restricted from creating new streams.</div><div class="line">     releasedConnection = this.connection;</div><div class="line">     toClose = releaseIfNoNewStreams();</div><div class="line">     if (this.connection != null) &#123;</div><div class="line">       // We had an already-allocated connection and it&apos;s good.</div><div class="line">       result = this.connection;</div><div class="line">       releasedConnection = null;</div><div class="line">     &#125;</div><div class="line">     if (!reportedAcquired) &#123;</div><div class="line">       // If the connection was never reported acquired, don&apos;t report it as released!</div><div class="line">       releasedConnection = null;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (result == null) &#123;</div><div class="line">       // Attempt to get a connection from the pool.</div><div class="line">       Internal.instance.get(connectionPool, address, this, null);</div><div class="line">       if (connection != null) &#123;</div><div class="line">         foundPooledConnection = true;</div><div class="line">         result = connection;</div><div class="line">       &#125; else &#123;</div><div class="line">         selectedRoute = route;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   closeQuietly(toClose);</div><div class="line"></div><div class="line">   if (releasedConnection != null) &#123;</div><div class="line">     eventListener.connectionReleased(call, releasedConnection);</div><div class="line">   &#125;</div><div class="line">   if (foundPooledConnection) &#123;</div><div class="line">     eventListener.connectionAcquired(call, result);</div><div class="line">   &#125;</div><div class="line">   if (result != null) &#123;</div><div class="line">     // If we found an already-allocated or pooled connection, we&apos;re done.</div><div class="line">     return result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we need a route selection, make one. This is a blocking operation.</div><div class="line">   boolean newRouteSelection = false;</div><div class="line">   if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123;</div><div class="line">     newRouteSelection = true;</div><div class="line">     routeSelection = routeSelector.next();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">     if (newRouteSelection) &#123;</div><div class="line">       // Now that we have a set of IP addresses, make another attempt at getting a connection from</div><div class="line">       // the pool. This could match due to connection coalescing.</div><div class="line">       List&lt;Route&gt; routes = routeSelection.getAll();</div><div class="line">       for (int i = 0, size = routes.size(); i &lt; size; i++) &#123;</div><div class="line">         Route route = routes.get(i);</div><div class="line">         Internal.instance.get(connectionPool, address, this, route);</div><div class="line">         if (connection != null) &#123;</div><div class="line">           foundPooledConnection = true;</div><div class="line">           result = connection;</div><div class="line">           this.route = route;</div><div class="line">           break;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (!foundPooledConnection) &#123;</div><div class="line">       if (selectedRoute == null) &#123;</div><div class="line">         selectedRoute = routeSelection.next();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Create a connection and assign it to this allocation immediately. This makes it possible</div><div class="line">       // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.</div><div class="line">       route = selectedRoute;</div><div class="line">       refusedStreamCount = 0;</div><div class="line">       result = new RealConnection(connectionPool, selectedRoute);</div><div class="line">       acquire(result, false);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // If we found a pooled connection on the 2nd time around, we&apos;re done.</div><div class="line">   if (foundPooledConnection) &#123;</div><div class="line">     eventListener.connectionAcquired(call, result);</div><div class="line">     return result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Do TCP + TLS handshakes. This is a blocking operation.</div><div class="line">   result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</div><div class="line">       connectionRetryEnabled, call, eventListener);</div><div class="line">   routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">   Socket socket = null;</div><div class="line">   synchronized (connectionPool) &#123;</div><div class="line">     reportedAcquired = true;</div><div class="line"></div><div class="line">     // Pool the connection.</div><div class="line">     Internal.instance.put(connectionPool, result);</div><div class="line"></div><div class="line">     // If another multiplexed connection to the same address was created concurrently, then</div><div class="line">     // release this connection and acquire that one.</div><div class="line">     if (result.isMultiplexed()) &#123;</div><div class="line">       socket = Internal.instance.deduplicate(connectionPool, address, this);</div><div class="line">       result = connection;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   closeQuietly(socket);</div><div class="line"></div><div class="line">   eventListener.connectionAcquired(call, result);</div><div class="line">   return result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>OkHttp中使用ConnectionPool管理http和http/2的链接，以便减少网络请求延迟。同一个address将共享同一个connection。该类实现了复用连接的目标。一个OkHttpClient只包含一个ConnectionPool，其实例化也是在OkHttpClient的过程。这里说一下ConnectionPool各个方法的调用并没有直接对外暴露，而是通过OkHttpClient的Internal接口统一对外暴露。</p>
<p>1、获取连接使用get方法,或获取是否有合适的链接，否则返回null，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123;</div><div class="line">   assert (Thread.holdsLock(this));</div><div class="line">   for (RealConnection connection : connections) &#123;</div><div class="line">     if (connection.isEligible(address, route)) &#123;</div><div class="line">       streamAllocation.acquire(connection, true);</div><div class="line">       return connection;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>2、加入连接使用put方法，并且会是会触发cleanupRunnable，清理连接。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void put(RealConnection connection) &#123;</div><div class="line">    assert (Thread.holdsLock(this));</div><div class="line">    if (!cleanupRunning) &#123;</div><div class="line">      cleanupRunning = true;</div><div class="line">      executor.execute(cleanupRunnable);</div><div class="line">    &#125;</div><div class="line">    connections.add(connection);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>3、具体的连接回收机制，首先统计空闲连接数量，然后通过for循环查找最长空闲时间的连接以及对应空闲时长，然后判断是否超出最大空闲连接数(maxIdleConnections)或者或者超过最大空闲时间(keepAliveDurationNs)，满足其一则清除最长空闲时长的连接。如果不满足清理条件，则返回一个对应等待时间。具体的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">long cleanup(long now) &#123;</div><div class="line">    int inUseConnectionCount = 0;</div><div class="line">    int idleConnectionCount = 0;</div><div class="line">    RealConnection longestIdleConnection = null;</div><div class="line">    long longestIdleDurationNs = Long.MIN_VALUE;</div><div class="line"></div><div class="line">    // Find either a connection to evict, or the time that the next eviction is due.</div><div class="line">    synchronized (this) &#123;</div><div class="line">      for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</div><div class="line">        RealConnection connection = i.next();</div><div class="line"></div><div class="line">        // If the connection is in use, keep searching.</div><div class="line">        if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123;</div><div class="line">          inUseConnectionCount++;</div><div class="line">          continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        idleConnectionCount++;</div><div class="line"></div><div class="line">        // If the connection is ready to be evicted, we&apos;re done.</div><div class="line">        long idleDurationNs = now - connection.idleAtNanos;</div><div class="line">        if (idleDurationNs &gt; longestIdleDurationNs) &#123;</div><div class="line">          longestIdleDurationNs = idleDurationNs;</div><div class="line">          longestIdleConnection = connection;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (longestIdleDurationNs &gt;= this.keepAliveDurationNs</div><div class="line">          || idleConnectionCount &gt; this.maxIdleConnections) &#123;</div><div class="line">        // We&apos;ve found a connection to evict. Remove it from the list, then close it below (outside</div><div class="line">        // of the synchronized block).</div><div class="line">        connections.remove(longestIdleConnection);</div><div class="line">      &#125; else if (idleConnectionCount &gt; 0) &#123;</div><div class="line">        // A connection will be ready to evict soon.</div><div class="line">        return keepAliveDurationNs - longestIdleDurationNs;</div><div class="line">      &#125; else if (inUseConnectionCount &gt; 0) &#123;</div><div class="line">        // All connections are in use. It&apos;ll be at least the keep alive duration &apos;til we run again.</div><div class="line">        return keepAliveDurationNs;</div><div class="line">      &#125; else &#123;</div><div class="line">        // No connections, idle or in use.</div><div class="line">        cleanupRunning = false;</div><div class="line">        return -1;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    closeQuietly(longestIdleConnection.socket());</div><div class="line"></div><div class="line">    // Cleanup again immediately.</div><div class="line">    return 0;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="OkHttp的底层网络实现是什么？"><a href="#OkHttp的底层网络实现是什么？" class="headerlink" title="OkHttp的底层网络实现是什么？"></a>OkHttp的底层网络实现是什么？</h1><p>1、OkHttp使用okio进行io的操作。okio是由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。OKHttp底层也是用该库作为支持。而且okio使用起来很简单，减少了很多io操作的基本代码，并且对内存和CPU使用做了优化。</p>
<p>2、没有依赖其他的关于Http实现的库，底层使用了Socket，自己实现了Http1.X及2.X的协议。</p>
<h1 id="OkHttp中代码运用了那些设计模式，有什么巧妙的设计？"><a href="#OkHttp中代码运用了那些设计模式，有什么巧妙的设计？" class="headerlink" title="OkHttp中代码运用了那些设计模式，有什么巧妙的设计？"></a>OkHttp中代码运用了那些设计模式，有什么巧妙的设计？</h1><p>1、建造者模式</p>
<p>不管是OkHttpClient对象的创建还是Request对象、Respone对象，都使用了建造者模式，将复杂的对象创建统一在不同方法中，使得创建的过程更加简单。</p>
<p>2、外观模式<br>OkHttpClient对外提供了统一的调度，屏蔽了内部的实现，使得使用该网络库简单便捷。</p>
<p>3、责任链模式<br>OkHttp中的拦截器使用了责任链模式，将不同的拦截器独立实现，动态组成链的调用形式。责任清晰，可动态扩展。</p>
<h1 id="为什么要用OkHttp？"><a href="#为什么要用OkHttp？" class="headerlink" title="为什么要用OkHttp？"></a>为什么要用OkHttp？</h1><p>目前Android开发中，主要的网络框架有HttpClient、Volley、HttpURLConnection、OkHttp。</p>
<p>其中Android早就不推荐httpclient，5.0之后干脆废弃，6.0删除了HttpClient。所以HttpClient不考虑。Volley框架现在也已经不再升级了，故目前考虑使用的有、HttpURLConnection及OkHttp。</p>
<p>相对HttpURLConnection，OkHttp使用更加便捷及灵活，且第三方社区活跃，相关资料齐全，成熟稳定性高。OkHttp也得到了官方的认可，并在不断优化更新，所以建议应用优先选择OkHttp作为网络框架。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在项目的开发过程中，我们经常使用到大量的第三方框架，但可能知其然不知其所以然，通过不断的思考反问为什么，从而去研究源码中的实现。能让我们对框架更加运用自如及解决一些底层疑难的问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/fightingXia/article/details/70947701" target="_blank" rel="external">OKHttp使用详解</a></p>
<p><a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="external">OKHTTP结合官网示例分析两种自定义拦截器的区别</a></p>
<p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="external">OKHttp源码解析(一)系列</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://avatar.csdn.net/0/6/2/1_junbin1011.jpg"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">优秀是一种习惯，坚持是一种品质。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-jun-bin-48/" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
