<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="锁锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程-锁及并发容器">
<meta property="og:url" content="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/index.html">
<meta property="og:site_name" content="黄俊彬个人博客">
<meta property="og:description" content="锁锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-77d650be264e60e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-d28778b6ec512021?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-ac27c7bad8a42712?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-04-24T08:12:18.777Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程-锁及并发容器">
<meta name="twitter:description" content="锁锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5125122-77d650be264e60e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/"/>





  <title> Java并发编程-锁及并发容器 | 黄俊彬个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄俊彬个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">优秀是一种习惯，坚持是一种品质。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEBc90ae3b4054ea1c24355c6f72b3a4ba6?method=download&shareKey=5c0d26947cc7ff6ae5dd2eb1e6065b72">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄俊彬个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java并发编程-锁及并发容器
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T18:52:01+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/Java并发编程-锁及并发容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/10/Java并发编程-锁及并发容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<h2 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h2><p><img src="http://upload-images.jianshu.io/upload_images/5125122-77d650be264e60e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。ReentrantLock是java.unti.concurrent包下的一个类，它的一般使用结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void lockMethod() &#123;  </div><div class="line">    ReentrantLock myLock = new ReentrantLock();  </div><div class="line">    myLock.lock();  </div><div class="line">    try&#123;  </div><div class="line">        // 受保护的代码段  </div><div class="line">        //critical section  </div><div class="line">    &#125; finally &#123;  </div><div class="line">        // 可以保证发生异常 锁可以得到释放 避免死锁的发生  </div><div class="line">        myLock.unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock与synchronized的比较"><a href="#ReentrantLock与synchronized的比较" class="headerlink" title="ReentrantLock与synchronized的比较"></a>ReentrantLock与synchronized的比较</h3><ul>
<li>相同：ReentrantLock提供了synchronized类似的功能和内存语义。</li>
<li>不同：</li>
</ul>
<ol>
<li>ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</li>
<li>ReentrantLock 的性能比synchronized会好点。</li>
<li>ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。</li>
</ol>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>  在Java的ReentrantLock构造函数中提供了两种锁：创建公平锁和非公平锁（默认）。代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  public ReentrantLock() &#123;</div><div class="line"></div><div class="line">       sync = new NonfairSync();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> public ReentrantLock(boolean fair) &#123;</div><div class="line">          sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。</p>
<p>非公平锁性能高于公平锁性能的原因：<br>在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。</p>
<h2 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h2><p>之前提到锁基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写<br>的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-d28778b6ec512021?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度图片搜索"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Cache &#123;</div><div class="line">static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</div><div class="line">static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</div><div class="line">static Lock r = rwl.readLock();</div><div class="line">static Lock w = rwl.writeLock();</div><div class="line">// 获取一个key对应的value</div><div class="line">public static final Object get(String key) &#123;</div><div class="line">r.lock();</div><div class="line">try &#123;</div><div class="line">return map.get(key);</div><div class="line">&#125; finally &#123;</div><div class="line">r.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 设置key对应的value，并返回旧的value</div><div class="line">public static final Object put(String key, Object value) &#123;</div><div class="line">w.lock();</div><div class="line">try &#123;</div><div class="line">return map.put(key, value);</div><div class="line">&#125; finally &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 清空所有的内容</div><div class="line">public static final void clear() &#123;</div><div class="line">w.lock();</div><div class="line">try &#123;</div><div class="line">map.clear();</div><div class="line">&#125; finally &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的<br>读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使<br>得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新<br>HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而<br>只有写锁被释放之后，其他读写操作才能继续。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。</p>
<p>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p>
<ul>
<li>Conditon中的await()对应Object的wait()</li>
<li>Condition中的signal()对应Object的notify()</li>
<li>Condition中的signalAll()对应Object的notifyAll()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class ConTest &#123;  </div><div class="line">      </div><div class="line">     final Lock lock = new ReentrantLock();  </div><div class="line">     final Condition condition = lock.newCondition();  </div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        // TODO Auto-generated method stub  </div><div class="line">        ConTest test = new ConTest();  </div><div class="line">        Producer producer = test.new Producer();  </div><div class="line">        Consumer consumer = test.new Consumer();  </div><div class="line">                </div><div class="line">          </div><div class="line">        consumer.start();   </div><div class="line">        producer.start();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">     class Consumer extends Thread&#123;  </div><div class="line">           </div><div class="line">            @Override  </div><div class="line">            public void run() &#123;  </div><div class="line">                consume();  </div><div class="line">            &#125;  </div><div class="line">                </div><div class="line">            private void consume() &#123;  </div><div class="line">                               </div><div class="line">                    try &#123;  </div><div class="line">                           lock.lock();  </div><div class="line">                        System.out.println(&quot;我在等一个新信号&quot;+this.currentThread().getName());  </div><div class="line">                        condition.await();  </div><div class="line">                          </div><div class="line">                    &#125; catch (InterruptedException e) &#123;  </div><div class="line">                        // TODO Auto-generated catch block  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125; finally&#123;  </div><div class="line">                        System.out.println(&quot;拿到一个信号&quot;+this.currentThread().getName());  </div><div class="line">                        lock.unlock();  </div><div class="line">                    &#125;  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">       </div><div class="line">     class Producer extends Thread&#123;  </div><div class="line">           </div><div class="line">            @Override  </div><div class="line">            public void run() &#123;  </div><div class="line">                produce();  </div><div class="line">            &#125;  </div><div class="line">                </div><div class="line">            private void produce() &#123;                   </div><div class="line">                    try &#123;  </div><div class="line">                           lock.lock();  </div><div class="line">                           System.out.println(&quot;我拿到锁&quot;+this.currentThread().getName());  </div><div class="line">                            condition.signalAll();                             </div><div class="line">                        System.out.println(&quot;我发出了一个信号：&quot;+this.currentThread().getName());  </div><div class="line">                    &#125; finally&#123;  </div><div class="line">                        lock.unlock();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">     &#125;  </div><div class="line">          </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">我在等一个新信号Thread-1</div><div class="line">我拿到锁Thread-0</div><div class="line">我发出了一个信号：Thread-0</div><div class="line">拿到一个信号Thread-1</div></pre></td></tr></table></figure></p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public boolean add(T e) &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();</div><div class="line">    try &#123;</div><div class="line"></div><div class="line">        Object[] elements = getArray();</div><div class="line"></div><div class="line">        int len = elements.length;</div><div class="line">        // 复制出新数组</div><div class="line"></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class="line">        // 把新元素添加到新数组里</div><div class="line"></div><div class="line">        newElements[len] = e;</div><div class="line">        // 把原数组引用指向新数组</div><div class="line"></div><div class="line">        setArray(newElements);</div><div class="line"></div><div class="line">        return true;</div><div class="line"></div><div class="line">    &#125; finally &#123;</div><div class="line"></div><div class="line">        lock.unlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">final void setArray(Object[] a) &#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">    return get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>ConcurrentHashMap是线程安全且高效的HashMap。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-ac27c7bad8a42712?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><ul>
<li>线程不安全的HashMap</li>
</ul>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap</p>
<ul>
<li>效率低下的HashTable</li>
</ul>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低</p>
<ul>
<li>ConcurrentHashMap的锁分段技术可有效提升并发访问率</li>
</ul>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</p>
<h3 id="hash定位"><a href="#hash定位" class="headerlink" title="hash定位"></a>hash定位</h3><p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　　// 定位Segment所使用的hash算法</div><div class="line">int index = hash &amp; (tab.length - 1);　　// 定位HashEntry所使用的hash算法</div></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散<br>列运算定位到Segment，再通过散列算法定位到元素，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">int hash = hash(key.hashCode());</div><div class="line">return segmentFor(hash).get(key, hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。我们<br>知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">       Segment&lt;K,V&gt; s;</div><div class="line">       if (value == null)</div><div class="line">           throw new NullPointerException();</div><div class="line">       int hash = hash(key);</div><div class="line">       int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">       if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</div><div class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</div><div class="line">           s = ensureSegment(j);</div><div class="line">       return s.put(key, hash, value, false);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Segment的put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">         HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">             scanAndLockForPut(key, hash, value);</div><div class="line">         V oldValue;</div><div class="line">         try &#123;</div><div class="line">             HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">             int index = (tab.length - 1) &amp; hash;</div><div class="line">             HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">             for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                 if (e != null) &#123;</div><div class="line">                     K k;</div><div class="line">                     if ((k = e.key) == key ||</div><div class="line">                         (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                         oldValue = e.value;</div><div class="line">                         if (!onlyIfAbsent) &#123;</div><div class="line">                             e.value = value;</div><div class="line">                             ++modCount;</div><div class="line">                         &#125;</div><div class="line">                         break;</div><div class="line">                     &#125;</div><div class="line">                     e = e.next;</div><div class="line">                 &#125;</div><div class="line">                 else &#123;</div><div class="line">                     if (node != null)</div><div class="line">                         node.setNext(first);</div><div class="line">                     else</div><div class="line">                         node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                     int c = count + 1;</div><div class="line">                     if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                         rehash(node);</div><div class="line">                     else</div><div class="line">                         setEntryAt(tab, index, node);</div><div class="line">                     ++modCount;</div><div class="line">                     count = c;</div><div class="line">                     oldValue = null;</div><div class="line">                     break;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125; finally &#123;</div><div class="line">             unlock();</div><div class="line">         &#125;</div><div class="line">         return oldValue;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。<br>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不<br>满。</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器</li>
</ol>
<p>插入和移除操作的4中处理方式</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td> 移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(e,time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue<br>full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移<br>除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者<br>线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队<br>列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程<br>一段时间，如果超过了指定的时间，生产者线程就会退出</li>
</ul>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下。</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
</ul>
<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列 </p>
<ul>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
</ul>
<p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>
<ul>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
</ul>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序 </p>
<ul>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
</ul>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素</p>
<ul>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
<p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素</p>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
</ul>
<p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<ul>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">《Java并发编程的艺术》</a></p>
<p><a href="http://blog.csdn.net/zmx729618/article/details/51593666" target="_blank" rel="external">ReentrantLock之公平锁与非公平锁浅析</a></p>
<p><a href="http://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="external"> java condition使用及分析</a></p>
<p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">聊聊并发-Java中的Copy-On-Write容器</a></p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="external">Java集合—ConcurrentHashMap原理分析</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/09/Java并发编程-原子类及并发工具类/" rel="next" title="Java并发编程-原子类及并发工具类">
                <i class="fa fa-chevron-left"></i> Java并发编程-原子类及并发工具类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/14/玩转Android状态栏/" rel="prev" title="玩转Android状态栏">
                玩转Android状态栏 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/10/10/Java并发编程-锁及并发容器/"
           data-title="Java并发编程-锁及并发容器" data-url="https://junbin1011.github.io/2017/10/10/Java并发编程-锁及并发容器/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://note.youdao.com/yws/api/personal/file/WEBc90ae3b4054ea1c24355c6f72b3a4ba6?method=download&shareKey=5c0d26947cc7ff6ae5dd2eb1e6065b72"
               alt="黄俊彬" />
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">优秀是一种习惯，坚持是一种品质。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">76</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-jun-bin-48/" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#锁"><span class="nav-number">1.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重入锁ReentrantLock"><span class="nav-number">1.1.</span> <span class="nav-text">重入锁ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock与synchronized的比较"><span class="nav-number">1.1.1.</span> <span class="nav-text">ReentrantLock与synchronized的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平性"><span class="nav-number">1.2.</span> <span class="nav-text">公平性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁ReentrantReadWriteLock"><span class="nav-number">1.3.</span> <span class="nav-text">读写锁ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition接口"><span class="nav-number">1.4.</span> <span class="nav-text">Condition接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发容器"><span class="nav-number">2.</span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWrite容器"><span class="nav-number">2.1.</span> <span class="nav-text">CopyOnWrite容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap的实现原理与使用"><span class="nav-number">2.2.</span> <span class="nav-text">ConcurrentHashMap的实现原理与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用ConcurrentHashMap"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么要使用ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash定位"><span class="nav-number">2.2.2.</span> <span class="nav-text">hash定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">2.2.3.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put"><span class="nav-number">2.2.4.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#size"><span class="nav-number">2.2.5.</span> <span class="nav-text">size</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列"><span class="nav-number">2.3.</span> <span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java里的阻塞队列"><span class="nav-number">2.3.1.</span> <span class="nav-text">Java里的阻塞队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">3.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
