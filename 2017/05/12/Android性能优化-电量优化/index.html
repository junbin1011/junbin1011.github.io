<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Android,Android性能优化,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="前言电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：  移动设备，不能一直使用电源供电，且电池容量有限 对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高   曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡">
<meta name="keywords" content="Android,Android性能优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化-电量优化">
<meta property="og:url" content="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/index.html">
<meta property="og:site_name" content="JunBin">
<meta property="og:description" content="前言电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：  移动设备，不能一直使用电源供电，且电池容量有限 对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高   曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-f3d81d33d585aa7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-c9a590b400a4a292?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-5be155e7a92274b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-e7c2717bc74a7d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-1be98683a95ee9a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-6ddb4cbc82b1a33a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-db908127e9e5e7ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-8320242fc1011e82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5125122-fb4297e921d3402f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-04-24T08:12:18.771Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android性能优化-电量优化">
<meta name="twitter:description" content="前言电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：  移动设备，不能一直使用电源供电，且电池容量有限 对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高   曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5125122-f3d81d33d585aa7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/">





  <title> Android性能优化-电量优化 | JunBin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b3ffb4912eee79c795100275f268095c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JunBin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一花一世界，一码一浮生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄俊彬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JunBin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android性能优化-电量优化
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T16:40:55+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/12/Android性能优化-电量优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/12/Android性能优化-电量优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>电量优化，这个名词在传统PC时代，我们基本很少听见。然而到了诺基亚时代，我们也同样很少关注。直到了移动互联的智能机时代。电量优化才被慢慢的重视起来。可能的原因如下：</p>
<ol>
<li>移动设备，不能一直使用电源供电，且电池容量有限</li>
<li>对于用户来说, 实际上App的电量损耗也是用户体验的一个方面。 特别是当今人们对移动设备的依赖度越来越高</li>
</ol>
<blockquote>
<p>曾经我们一个BOSS发现使用APP，挂在后台。然后手机插着充电，然后睡了个觉。起床发现电量只充满了70-80%，然后… …<br>最后发现是一个重要原因由于内测版本的长连接开启了日志记录，频繁的进行IO操作引起.<br>这个时候你还不能狡辩了，因为用户最简单能通过系统设置来查看应用的耗电量排名。</p>
</blockquote>
<p>在电子编程世界，这种硬件消耗电量 来执行任务的过程，叫做超时电流消耗，<br>任何电子编程专业的人都会告诉你，你的设备的各项活动在相同时间内，消耗的电量是不同的。比如，很多手机号称待机好几天，这个确实是真的，不过就是使用飞行模式放在家里什么都不干，确实可以甚至可以坚持10多天。但是我们一旦使用它，比如使用蜂窝式无线数据交换(3G4G)、屏幕保持唤醒状态等。作为开发者，我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情（所以很多设备都把这个监测电量的功能阉割掉了。）。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-f3d81d33d585aa7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Google电量优化-示例图"></p>
<h1 id="手机那些地方最耗电？"><a href="#手机那些地方最耗电？" class="headerlink" title="手机那些地方最耗电？"></a>手机那些地方最耗电？</h1><h2 id="唤醒屏幕"><a href="#唤醒屏幕" class="headerlink" title="唤醒屏幕"></a>唤醒屏幕</h2><p>当用户电量屏幕的时候，意味着系统的各组件要开始进行工作，界面也需要开始执行渲染。</p>
<p>待机状态的电量消耗：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-c9a590b400a4a292?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>使用和唤醒屏幕后：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-5be155e7a92274b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当设备从休眠状态中，被应用程序假面唤醒时，你会看到在第一次唤醒时，这里有一条电量使用高峰线</p>
<h2 id="CPU唤醒使用"><a href="#CPU唤醒使用" class="headerlink" title="CPU唤醒使用"></a>CPU唤醒使用</h2><p>CUP唤醒时的高峰线：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-e7c2717bc74a7d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>接下来就是后续的一些执行的消耗了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-1be98683a95ee9a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量</p>
<h2 id="蜂窝式无线"><a href="#蜂窝式无线" class="headerlink" title="蜂窝式无线"></a>蜂窝式无线</h2><p>当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。接下来还有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-6ddb4cbc82b1a33a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>
<ul>
<li>Full power: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li>Low power: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li>Standby: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>
<h1 id="如何进行电量使用分析？"><a href="#如何进行电量使用分析？" class="headerlink" title="如何进行电量使用分析？"></a>如何进行电量使用分析？</h1><p>电量使用优化, 基本上是我们最不怎么关注的一项优化。可能很多公司连QA/Tester也不会关注测试App电量的使用。一般来说开发和测试的测试设备也一直是连着USB处于充电状态的,感官上也体会不到电量的损耗。要进行电量优化，我们首先得知道电都消耗到那里去了，不然如何进行针对性的优化呢？答案是通过google开源的Battery Historian来进行分析。</p>
<h2 id="电量数据收集"><a href="#电量数据收集" class="headerlink" title="电量数据收集"></a>电量数据收集</h2><p>Android 5.0及以上的设备, 允许我们通过adb命令dump出电量使用统计信息.</p>
<ol>
<li><p>因为电量统计数据是持续的, 会非常大, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys batterystats --reset</span><br><span class="line">Battery stats reset.</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开测试设备, 操作我们的待测试App.</p>
</li>
<li>重新连接设备, 使用adb命令导出相关统计数据:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.</span><br><span class="line">$ adb bugreport &gt; bugreport.txt</span><br></pre></td></tr></table></figure>
<p>导出的统计数据存储到bugreport.txt, 此时我们可以借助如下工具来图形化展示电池的消耗情况.</p>
<blockquote>
<p>注意, 官方SDK文档导出文件方式为:<br>adb shell dumpsys batterystats &gt; batterystats.txt<br>使用python historian.py batterystats.txt &gt; batterystats.html查看数据<br>是battery-historian老版本的使用方式. 目前Battery Historian已更新2.0版本, 推荐使用bugreport方式导出数据分析, 可以看到更多信息.</p>
</blockquote>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>工具开源地址: <a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">Battery Historian</a></p>
<p>根据gitbub上面介绍，Battery History工具的安装有两种方式：</p>
<ol>
<li>通过安装Docker环境来安装。（这种方式很简单，Docker真心好用，太彪悍了！）<br>Docker是一种容器，一般用于云计算和大数据平台。提倡的一种思想就是：软件即服务。这句话不是盖的，一句话就可以将别人发布的docker服务环境一次全部copy过来(注意是整个软件环境哦，相当于复制了一台一模一样的主机，连软件都不要安装了，全有了。彪悍吧！)<br>Docker只支持Windows10</li>
</ol>
<blockquote>
<p>由于笔者使用的window，无法通过Docker的方式，所以是采用第2点进行安装</p>
</blockquote>
<p>2.通过编译gitbub上面的源码来安装</p>
<p>这真是一个虐心的过程，因为Battery History是Go语言开发的。我们需要安装Go环境、Pytho环境、Git环境，并配置好相关的环境变量。具体的软件安装教程就不附上了，这里贴一下工具的下载地址。</p>
<p>Go下载地址：<a href="https://golang.org/doc/install?download=go1.7.3.windows-amd64.msi" target="_blank" rel="noopener">GO环境安装</a></p>
<p>Python下载地址：<a href="https://www.python.org/" target="_blank" rel="noopener">Python环境安装</a></p>
<p>Git下载地址：<a href="https://git-scm.com/" target="_blank" rel="noopener">Git环境安装</a></p>
<blockquote>
<p>需要注意的是, Battery Historian是Go语言的, 安装Go的时候需要配置其bin的环境变量.<br>Python环境需要是2.7的(3.x不行), 建议使用pyenv管理本地的python环境.<br>另外, 因为Battery Historian是一个网页版工具, 涉及一些JS引用, 有时需要翻墙.</p>
</blockquote>
<p>安装及成果配置环境变量后</p>
<p>1.输入命令行go get -d -u github.com/google/battery-historian/…<br>**下载到GOPATH配置目录下</p>
<p>2.进入到$GOPATH/src/github.com/google/battery-historian目录下方<br>$ cd $GOPATH/src/github.com/google/battery-historian</p>
<p>3.运行Battery Historian</p>
<p>1） go run setup.go<br>Compile Javascript files using the Closure compiler<br>$ go run setup.go<br>等待数分钟或者10分钟左右，如果仍然没有下载成功，可以手动下载，如下操作<br>**下载【closure-library】和【closure-compiler】和【flot-axislabels】，解压放到GOROOT目录下third_party文件夹下方的的closure-compiler和closure-library和flot-axislabels文件夹 ../battery-historian\third_party；如果没有均手动创建</p>
<p>2）go run cmd/battery-historian/battery-historian.go<br>Run Historian on your machine (make sure $PATH contains $GOBIN)<br>$ go run cmd/battery-historian/battery-historian.go [–port <a href="default:9999" target="_blank" rel="noopener">default:9999</a>]</p>
<p>4.检查/battery-historian是否运行，登录网址 <a href="http://localhost:9999查看" target="_blank" rel="noopener">http://localhost:9999查看</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5125122-db908127e9e5e7ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<blockquote>
<p>千呼万唤使出来，不容易。这里建议使用Chrome浏览器，并且一定要使用VPN，不然各种莫名的问题</p>
</blockquote>
<h2 id="分析指标"><a href="#分析指标" class="headerlink" title="分析指标"></a>分析指标</h2><p>工具安装完成后，我们将adb采集的数据上传至Battery Historian，就可以得到电量的分析情况。<br><img src="http://upload-images.jianshu.io/upload_images/5125122-8320242fc1011e82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="http://upload-images.jianshu.io/upload_images/5125122-fb4297e921d3402f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>那么关键来了，这些指标具体代表什么含义呢？这里我们来做一下解释。</p>
<ol>
<li>横坐标 </li>
</ol>
<p>横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取bugreport内容时刻为终点。我们一共采集了多长时间的数据</p>
<ol start="2">
<li>纵坐标</li>
</ol>
<p>关键的数据点我们用表格来汇总一下。</p>
<table>
<thead>
<tr>
<th>数据项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>battery_level</td>
<td>电量，可以看出电量的变化</td>
</tr>
<tr>
<td>plugged</td>
<td>充电状态，这一栏显示是否进行了充电，以及充电的时间范围</td>
</tr>
<tr>
<td>screen</td>
<td>屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息</td>
</tr>
<tr>
<td>top</td>
<td>该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app，用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助</td>
</tr>
<tr>
<td>wake_lock</td>
<td>wake_lock 该属性是记录wake_lock模块的工作时间。是否有停止的时候等</td>
</tr>
<tr>
<td>running</td>
<td>界面的状态，主要判断是否处于idle的状态。用来判断无操作状态下电量的消耗</td>
</tr>
<tr>
<td>Job</td>
<td>后台的工作，比如服务service的运行</td>
</tr>
<tr>
<td>data_conn</td>
<td>数据连接方式的改变，上面的edge是说明采用的gprs的方式连接网络的。此数据可以看出手机是使用2g，3g，4g还是wifi进行数据交换的。这一栏可以看出不同的连接方式对电量使用的影响</td>
</tr>
<tr>
<td>status</td>
<td>电池状态信息，有充电，放电，未充电，已充满，未知等不同状态</td>
</tr>
<tr>
<td>phone_signal_strength</td>
<td>手机信号状态的改变。 这一栏记录手机信号的强弱变化图，依次来判断手机信号对电量的影响</td>
</tr>
<tr>
<td>health</td>
<td>电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间</td>
</tr>
<tr>
<td>plug</td>
<td>充电方式，usb或者插座，以及显示连接的时间</td>
</tr>
<tr>
<td>Sync</td>
<td>是否跟后台同步</td>
</tr>
<tr>
<td>phone_in_call</td>
<td>是否进行通话</td>
</tr>
<tr>
<td>gps</td>
<td>gps是否开启</td>
</tr>
</tbody>
</table>
<h1 id="如何进行电量优化？"><a href="#如何进行电量优化？" class="headerlink" title="如何进行电量优化？"></a>如何进行电量优化？</h1><p>关键的地方来了。了解了手机关键耗电的地方及分析耗电的工具后。接下来就是我们的核心，如何来进行电量的优化呢？首先我们先简单总结汇总一下耗电的相关因素</p>
<ul>
<li>屏幕亮暗相关</li>
<li>设备awake,sleep的切换,尤其是唤醒.</li>
<li>CPU运行相关</li>
<li>网络</li>
<li>传感器</li>
</ul>
<p>我们接下来根据因素来逐一进行优化建议。</p>
<h2 id="点滴积累"><a href="#点滴积累" class="headerlink" title="点滴积累"></a>点滴积累</h2><p>我们都知道屏幕的渲染及CPU的运行是耗电的主要因素之一。所以其实当我们在做内存优化、渲染优化、计算优化的时候，就已然在做电量优化。所以平时的开发中，我们要注意点滴性能的优化积累，实际上当我们来做电量分析的时候，也是在找自己挖的坑。所以尽量有意识在项目的开发过程中尽量少挖坑。所以这一点是我们在分析其他优化项首先要提到的一个点。</p>
<h2 id="监听手机充电状态"><a href="#监听手机充电状态" class="headerlink" title="监听手机充电状态"></a>监听手机充电状态</h2><p>我们可以通过下面的代码来获取手机的当前充电状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// It is very easy to subscribe to changes to the battery state, but you can get the current</span><br><span class="line">// state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</span><br><span class="line">IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = this.registerReceiver(null, filter);</span><br><span class="line">int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">if (acCharge) &#123;</span><br><span class="line">    Log.v(LOG_TAG,“The phone is charging!”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时 才去执行一些非常耗电的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This method checks for power by comparing the current battery state against all possible</span><br><span class="line"> * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or</span><br><span class="line"> * wireless charge. (Wireless charge was introduced in API Level 17.)</span><br><span class="line"> */</span><br><span class="line">private boolean checkForPower() &#123;</span><br><span class="line">    // It is very easy to subscribe to changes to the battery state, but you can get the current</span><br><span class="line">    // state by simply passing null in as your receiver.  Nifty, isn&apos;t that?</span><br><span class="line">    IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">    Intent batteryStatus = this.registerReceiver(null, filter);</span><br><span class="line"></span><br><span class="line">    // There are currently three ways a device can be plugged in. We should check them all.</span><br><span class="line">    int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">    boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);</span><br><span class="line">    boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">    boolean wirelessCharge = false;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">        wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);</span><br><span class="line">    &#125;</span><br><span class="line">    return (usbCharge || acCharge || wirelessCharge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里我们就需要思考，根据我们自己的业务，那些为了省电，可以放当手机插上电源的时候去做。<br>往往这样的情况非常多。像这些不需要及时地和用户交互的操作可以放到后面处理。<br>比如：360手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人等到云端；再比如我们自己的APP，其中有一块业务是相册备份，这个时候有一个选项控制让用户选择是否在低于15%的电量时还继续进行备份，从而避免当用户手机低电量时，任然继续进行耗电操作。</p>
</blockquote>
<h2 id="屏幕唤醒"><a href="#屏幕唤醒" class="headerlink" title="屏幕唤醒"></a>屏幕唤醒</h2><p>当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。</p>
<p>保持屏幕常亮<br>最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。<br>另一个方式是在布局文件中使用android:keepScreenOn属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:keepScreenOn=&quot;true&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。使用代码的好处是你允许你在需要的地方关闭屏幕。</p>
<p>注意：一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</p>
<blockquote>
<p>所以这里我们自己的APP需要根据业务来控制好是否保持屏幕常量。比如我们的APP需要支持视频播放。那么在播放的界面需要控制好不熄屏。当退出播放时，当然就没有了这个设置。</p>
</blockquote>
<h2 id="WakeLock"><a href="#WakeLock" class="headerlink" title="WakeLock"></a>WakeLock</h2><p>wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题。<br>需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述的FLAG_KEEP_SCREEN_ON。<br>只有一种合理的使用场景，是在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。 要使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止，这不是我们想要的。</p>
<blockquote>
<p>有的人可能认为我以前写的后台服务就没掉过链子呀运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。</p>
</blockquote>
<p>唤醒锁可划分为并识别四种用户唤醒锁：</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>CPU</th>
<th>屏幕</th>
<th>键盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>开启</td>
<td>关闭</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>开启</td>
<td>变暗</td>
<td>关闭</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>关闭</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>开启</td>
<td>变亮</td>
<td>变亮</td>
</tr>
</tbody>
</table>
<p>请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。<br>第一步就是添加唤醒锁权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>直接使用唤醒锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);</span><br><span class="line">WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;MyWakelockTag&quot;);</span><br><span class="line">wakeLock.acquire();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在使用该类的时候，必须保证acquire和release是成对出现的。不然当我们业务已经不需要时，当CPU处于唤醒状态，这个时候就会损耗多余的电量。</p>
</blockquote>
<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p> 自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobSchedule的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理。这样做有两个好处：</p>
<p>避免频繁的唤醒硬件模块，造成不必要的电量消耗。<br>避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量；<br>JobScheduler的简单使用，首先自定义一个Service类，继承自JobService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedulerService extends JobService&#123;</span><br><span class="line">    private String TAG = JobSchedulerService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(JobParameters jobParameters) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStartJob:&quot; + jobParameters.getJobId());</span><br><span class="line"></span><br><span class="line">        if(true) &#123;</span><br><span class="line">            // JobService在主线程运行，如果我们这里需要处理比较耗时的业务逻辑需单独开启一条子线程来处理并返回true，</span><br><span class="line">            // 当给定的任务完成时通过调用jobFinished(JobParameters params, boolean needsRescheduled)告知系统。</span><br><span class="line"></span><br><span class="line">            //假设开启一个线程去下载文件</span><br><span class="line">            new DownloadTask().execute(jobParameters);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //如果只是在本方法内执行一些简单的逻辑话返回false就可以了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 比如我们的服务设定的约束条件为在WIFI状态下运行，结果在任务运行的过程中WIFI断开了系统</span><br><span class="line">     * 就会通过回掉onStopJob()来通知我们停止运行，正常的情况下不会回掉此方法</span><br><span class="line">     *</span><br><span class="line">     * @param jobParameters</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters jobParameters) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStopJob:&quot; + jobParameters.getJobId());</span><br><span class="line"></span><br><span class="line">        //如果需要服务在设定的约定条件再次满足时再次执行服务请返回true，反之false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DownloadTask extends AsyncTask&lt;JobParameters, Object, Object&gt; &#123;</span><br><span class="line">        JobParameters mJobParameters;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInBackground(JobParameters... jobParameterses) &#123;</span><br><span class="line">            mJobParameters = jobParameterses[0];</span><br><span class="line"></span><br><span class="line">            //比如说我们这里处理一个下载任务</span><br><span class="line">            //或是处理一些比较复杂的运算逻辑</span><br><span class="line">            //...</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(30*1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Object o) &#123;</span><br><span class="line">            super.onPostExecute(o);</span><br><span class="line">            //如果在onStartJob()中返回true的话,处理完成逻辑后一定要执行jobFinished()告知系统已完成，</span><br><span class="line">            //如果需要重新安排服务请true，反之false</span><br><span class="line">            jobFinished(mJobParameters, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得在Manifest文件内配置Service <service android:name=".JobSchedulerService" android:permission="android.permission.BIND_JOB_SERVICE"></service></p>
<p>创建工作计划<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity&#123;</span><br><span class="line">    private JobScheduler mJobScheduler;</span><br><span class="line">    private final int JOB_ID = 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.mai_layout);</span><br><span class="line"></span><br><span class="line">        mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE );</span><br><span class="line"></span><br><span class="line">        //通过JobInfo.Builder来设定触发服务的约束条件，最少设定一个条件</span><br><span class="line">        JobInfo.Builder jobBuilder = new JobInfo.Builder(JOB_ID, new ComponentName(this, JobSchedulerService.class));</span><br><span class="line"></span><br><span class="line">        //循环触发，设置任务每三秒定期运行一次</span><br><span class="line">        jobBuilder.setPeriodic(3000);</span><br><span class="line"></span><br><span class="line">        //单次定时触发，设置为三秒以后去触发。这是与setPeriodic(long time)不兼容的，</span><br><span class="line">        // 并且如果同时使用这两个函数将会导致抛出异常。</span><br><span class="line">        jobBuilder.setMinimumLatency(3000);</span><br><span class="line"></span><br><span class="line">        //在约定的时间内设置的条件都没有被触发时三秒以后开始触发。类似于setMinimumLatency(long time)，</span><br><span class="line">        // 这个函数是与 setPeriodic(long time) 互相排斥的，并且如果同时使用这两个函数，将会导致抛出异常。</span><br><span class="line">        jobBuilder.setOverrideDeadline(3000);</span><br><span class="line"></span><br><span class="line">        //在设备重新启动后设置的触发条件是否还有效</span><br><span class="line">        jobBuilder.setPersisted(false);</span><br><span class="line"></span><br><span class="line">        // 只有在设备处于一种特定的网络状态时，它才触发。</span><br><span class="line">        // JobInfo.NETWORK_TYPE_NONE,无论是否有网络均可触发，这个是默认值；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_ANY，有网络连接时就触发；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_UNMETERED，非蜂窝网络中触发；</span><br><span class="line">        // JobInfo.NETWORK_TYPE_NOT_ROAMING，非漫游网络时才可触发；</span><br><span class="line">        jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);</span><br><span class="line"></span><br><span class="line">        //设置手机充电状态下触发</span><br><span class="line">        jobBuilder.setRequiresCharging(true);</span><br><span class="line"></span><br><span class="line">        //设置手机处于空闲状态时触发</span><br><span class="line">        jobBuilder.setRequiresDeviceIdle(true);</span><br><span class="line"></span><br><span class="line">        //得到JobInfo对象</span><br><span class="line">        JobInfo jobInfo = jobBuilder.build();</span><br><span class="line"></span><br><span class="line">        //设置开始安排任务，它将返回一个状态码</span><br><span class="line">        //JobScheduler.RESULT_SUCCESS，成功</span><br><span class="line">        //JobScheduler.RESULT_FAILURE，失败</span><br><span class="line">        if (mJobScheduler.schedule(jobInfo) == JobScheduler.RESULT_FAILURE) &#123;</span><br><span class="line">            //安排任务失败</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //停止指定JobId的工作服务</span><br><span class="line">        mJobScheduler.cancel(JOB_ID);</span><br><span class="line">        //停止全部的工作服务</span><br><span class="line">        mJobScheduler.cancelAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h2><h3 id="选择合适的Location-Provider"><a href="#选择合适的Location-Provider" class="headerlink" title="选择合适的Location Provider"></a>选择合适的Location Provider</h3><p>Android系统支持多个Location Provider：</p>
<ul>
<li>GPS_PROVIDER:</li>
</ul>
<p>GPS定位，利用GPS芯片通过卫星获得自己的位置信息。定位精准度高，一般在10米左右，耗电量大；但是在室内，GPS定位基本没用。</p>
<ul>
<li>NETWORK_PROVIDER：</li>
</ul>
<p>网络定位，利用手机基站和WIFI节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或WIF节点信息翻译成位置信息的服务器的能力。</p>
<ul>
<li>PASSIVE_PROVIDER:</li>
</ul>
<p>被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接收到消息后直接读取就可以了。比如如果系统中已经安装了百度地图，高德地图(室内可以实现精确定位)，你只要使用它们定位过后，再使用这种方法在你的程序肯定是可以拿到比较精确的定位信息。</p>
<p>例如你的App只是需要一个粗略的定位那么就不需要使用GPS进行定位，既耗费电量，定位的耗时也久。</p>
<h3 id="及时注销定位监听"><a href="#及时注销定位监听" class="headerlink" title="及时注销定位监听"></a>及时注销定位监听</h3><p>在获取到定位之后或者程序处于后台时，注销定位监听，此时监听GPS传感器相当于执行no-op（无操作指令），用户不会有感知但是却耗电。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onPause() &#123;</span><br><span class="line">    super.onPause();</span><br><span class="line">    locationManager.removeListener(locationListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onResume()&#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    locationManager.requestLocationUpdates(locationManager.getBestProvider(criteria, true),6000,100,locationListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多模块使用定位尽量复用"><a href="#多模块使用定位尽量复用" class="headerlink" title="多模块使用定位尽量复用"></a>多模块使用定位尽量复用</h3><p>多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗；例如：在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。</p>
<h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><p>使用传感器，选择合适的采样率，越高的采样率类型则越费电；</p>
<ul>
<li><p>SENSOR_DELAY_NOMAL (200000微秒)</p>
</li>
<li><p>SENSOR_DELAY_UI (60000微秒)</p>
</li>
<li><p>SENSOR_DELAY_GAME (20000微秒)</p>
</li>
<li><p>SENSOR_DELAY_FASTEST (0微秒)</p>
</li>
</ul>
<p>在后台时注意及时注销传感器监听</p>
<h2 id="Doze-and-App-Standby"><a href="#Doze-and-App-Standby" class="headerlink" title="Doze and App Standby"></a>Doze and App Standby</h2><p>最后提这一点，理论上不是电量优化，而是做电量优化要注意的一个坑。Doze and App Standby是Android 6.0以后，提供了两种省电延长电池寿命的功能。</p>
<p>具体可参考google官方介绍文档。<br><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html</a></p>
<blockquote>
<p>这个东西目前已基本无解，特别是国内的不支持google的GCM。这个地方只能控制让用户授权加入白名单来解除限制。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>
<p><a href="http://www.kancloud.cn/kancloud/android-performance/53235" target="_blank" rel="noopener">Android性能优化篇(谷歌官方)</a></p>
<p><a href="http://www.jianshu.com/p/5d83d8649c98" target="_blank" rel="noopener">Android性能优化（九）之不可忽视的电量</a></p>
<p><a href="http://www.jianshu.com/p/ebac88cdf9d6" target="_blank" rel="noopener">Android应用耗电量分析与优化建议</a></p>
<p>推荐资料(Google方法教程)</p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/index.html" target="_blank" rel="noopener">官方建议优化的一些方法</a></p>
<p><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a></p>
<p><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perf" target="_blank" rel="noopener">Android 7.0新特性对电池管理进一步加强，一些新的变化可能多对我们现有的业务会造成影响需关注</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Android性能优化/" rel="tag"># Android性能优化</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/08/JVM学习笔记-3-垃圾收集算法/" rel="next" title="JVM学习笔记(3)-垃圾收集算法">
                <i class="fa fa-chevron-left"></i> JVM学习笔记(3)-垃圾收集算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/23/程序员，30而立。你是否觉得迷茫？/" rel="prev" title="程序员，30而立。你是否觉得迷茫？">
                程序员，30而立。你是否觉得迷茫？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/05/12/Android性能优化-电量优化/" data-title="Android性能优化-电量优化" data-url="https://junbin1011.github.io/2017/05/12/Android性能优化-电量优化/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/WEB917b08143504a6f8c96228312fcb5245?method=download&shareKey=03cb5c302c83b56bbb91668c5008444f" alt="黄俊彬">
          <p class="site-author-name" itemprop="name">黄俊彬</p>
           
              <p class="site-description motion-element" itemprop="description">一花一世界，一码一浮生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">81</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/junbin1011" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#手机那些地方最耗电？"><span class="nav-number">2.</span> <span class="nav-text">手机那些地方最耗电？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#唤醒屏幕"><span class="nav-number">2.1.</span> <span class="nav-text">唤醒屏幕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU唤醒使用"><span class="nav-number">2.2.</span> <span class="nav-text">CPU唤醒使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#蜂窝式无线"><span class="nav-number">2.3.</span> <span class="nav-text">蜂窝式无线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何进行电量使用分析？"><span class="nav-number">3.</span> <span class="nav-text">如何进行电量使用分析？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#电量数据收集"><span class="nav-number">3.1.</span> <span class="nav-text">电量数据收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装工具"><span class="nav-number">3.2.</span> <span class="nav-text">安装工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析指标"><span class="nav-number">3.3.</span> <span class="nav-text">分析指标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何进行电量优化？"><span class="nav-number">4.</span> <span class="nav-text">如何进行电量优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#点滴积累"><span class="nav-number">4.1.</span> <span class="nav-text">点滴积累</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监听手机充电状态"><span class="nav-number">4.2.</span> <span class="nav-text">监听手机充电状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#屏幕唤醒"><span class="nav-number">4.3.</span> <span class="nav-text">屏幕唤醒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WakeLock"><span class="nav-number">4.4.</span> <span class="nav-text">WakeLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JobScheduler"><span class="nav-number">4.5.</span> <span class="nav-text">JobScheduler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPS"><span class="nav-number">4.6.</span> <span class="nav-text">GPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择合适的Location-Provider"><span class="nav-number">4.6.1.</span> <span class="nav-text">选择合适的Location Provider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#及时注销定位监听"><span class="nav-number">4.6.2.</span> <span class="nav-text">及时注销定位监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多模块使用定位尽量复用"><span class="nav-number">4.6.3.</span> <span class="nav-text">多模块使用定位尽量复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传感器"><span class="nav-number">4.7.</span> <span class="nav-text">传感器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Doze-and-App-Standby"><span class="nav-number">4.8.</span> <span class="nav-text">Doze and App Standby</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄俊彬</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"junbin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
